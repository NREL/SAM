
//*************************************************************************************
//PV Reliability and Performance Model Version 2.0 
//Inputs and Control Script -- DRAFT --
//Janine Freeman, NREL
//16 December 2016
//*************************************************************************************

//Import the function to simulate a single instance of a system
import 'PVRPM_Function.lk';


//*******************************************************************************************************************************************************************************
// USER-DEFINED INPUTS
// Please modify these inputs to match your system configuration and desired assumptions.
//*******************************************************************************************************************************************************************************

//----System setup---------------------------------------------------------------------------------------------
	num_combiners = 2; //total number of DC combiner boxes
	num_transformers = 1; //total number of Transformers
	num_trackers = 0; //
	
//----Financial inputs-----------------------------------------------------------------------------------------
	present_day_labor_rate = 100; //dollars per hour
	inflation = 3; //%
	
//----Tracker failure algorithm--------------------------------------------------------------------------------
	use_worst_case_tracker = false;

//----Degradation input function-------------------------------------------------------------------------------
	/*
	Equation format must follow:
	Inputs: 	percent_per_day = degradation rate in percent per DAY
				t = time (in DAYS) since the module was new or replaced
	Return: Current degradation factor in fractional form, 
	i.e. if module is 2% degraded, returns 0.98
	*/
	function current_degradation_rate(percent_per_day, t)
	{
		return 1 / pow((1 + percent_per_day / 100), t);
	}	

//----Number of stochastic realizations to be run--------------------------------------------------------------
	num_realizations = 2;

//********************************************************************************************************************************************************************************
// CASE-DEFINED INPUTS
// System inputs are taken from the active SAM case. The user SHOULD NOT modify these inputs.
//********************************************************************************************************************************************************************************

	if (active_case() == '')
	{
		msgbox('Please select a SAM case.');
		exit;
	}
	
	num_modules = get('total_modules');
	num_modules_per_string = get('modules_per_string');
	num_strings = get('strings_in_parallel');
	num_inverters = get('inverter_count');
	inverter_size = ?(get('inverter_model')) [get('inv_snl_paco'), get('inv_ds_paco'), get('inv_pd_paco')];
	num_disconnects = num_inverters; //assume 1 AC disconnect per inverter
	num_strings_per_combiner = floor(num_strings / num_combiners);
	num_inverters_per_transformer = floor(num_inverters / num_transformers);
	
	system_lifetime_yrs = get('analysis_period');
	has_multiple_subarrays = ( (get('subarray2_enable') == 1) || (get('subarray3_enable') == 1) || (get('subarray4_enable') == 1) );
	is_tracking_system = false;
	if ((get('subarray1_track_mode') == 1 || get('subarray1_track_mode') == 2 || get('subarray1_track_mode') == 3))
		is_tracking_system = true;
	if (get('subarray2_enable') == 1 && (get('subarray2_track_mode') == 1 || get('subarray2_track_mode') == 2 || get('subarray2_track_mode') == 3))
		is_tracking_system = true;
	if (get('subarray3_enable') == 1 && (get('subarray3_track_mode') == 1 || get('subarray3_track_mode') == 2 || get('subarray3_track_mode') == 3))
		is_tracking_system = true;
	if (get('subarray4_enable') == 1 && (get('subarray4_track_mode') == 1 || get('subarray4_track_mode') == 2 || get('subarray4_track_mode') == 3))
		is_tracking_system = true;
		
		
//********************************************************************************************************************************************************************************
// USER-DEFINED COMPONENT META DATA
// These inputs control the failure and repair modes and costs for the different component types. Please modify these inputs.
//********************************************************************************************************************************************************************************
//----Component meta information-------------------------------------------------------------------------------
	// The structure of a component meta container is as follows
	/*
	name = a string containing the name of the component type, used for error reporting
	number = number of that type of component in the system
	can_fail = true if component is allowed to fail
	can_repair = true if component is allowed to be repaired after failing
	warranty
		has_warranty = true if the component has a warranty, otherwise false
		days = number of days that the warranty is for (e.g. a 20 year warranty would be 20 * 365 days)
	failure[i]
		distribution = distribution type of failure mode i
		parameters = a table of parameters for failure mode i (e.g. [45, 15] )
		times = a vector of failure times for failure mode i
		labor_time = number of hours of labor it takes to repair this type of failure
		cost = parts cost to repair this type of failure
		***OPTIONAL PARAMETER
		***fraction = If fraction is defined, then failure mode i is a defective failure mode, and "fraction" represents the fraction of this type of component that are defective
	repair[i]
		distribution = distribution type of repair times
		parameters = parameters of the repair distribution
		times = a vector of repair times
		**NOTE: If there is only ONE repair distribution (repair[0]), then ALL failure modes will use that distribution! Otherwise, # repair modes must equal # failure modes.
	degradation (MODULES ONLY)
		can_degrade = true if the component has degradation
		rate = degradation rate (%/year)
	*/

//----Modules--------------------------------------------------------------------------------------------------
	global module_meta = null;
	module_meta.name = 'module';	
	module_meta.can_fail = true;
	module_meta.can_repair = true;
	module_meta.number = num_modules;
	module_meta.warranty.has_warranty = true;
	module_meta.warranty.days = 20 * 365; //years converted to days
	//failure mode 1: normal failures
	module_meta.failure[0].distribution = 'normal';
	module_meta.failure[0].parameters = [4 * 365, 1 * 365]; //mean, std, years converted to days
	module_meta.failure[0].times = null;
	module_meta.failure[0].labor_time = 2; //hours
	module_meta.failure[0].cost = 322; //$
	//failure mode 2: defective failures
	module_meta.failure[1].distribution = 'exponential';
	module_meta.failure[1].parameters = [0.5 / 365]; //failures per year converted to days
	module_meta.failure[1].times = null;
	module_meta.failure[1].labor_time = 2; //hours
	module_meta.failure[1].cost = 322; //$
	module_meta.failure[1].fraction = 20 / 100; //% converted to fraction
	//repair mode: only one repair mode for both failure types
	module_meta.repair[0].distribution = 'lognormal';
	module_meta.repair[0].parameters =  [60, 20]; //mean, std, in days
	module_meta.repair[0].times = null;
	module_meta.degradation.can_degrade = true;
	module_meta.degradation.rate = 5; //%/year
	
//----Strings--------------------------------------------------------------------------------------------------
	global string_meta = null;
	string_meta.name = 'string';
	string_meta.can_fail = true;
	string_meta.can_repair = true;
	string_meta.number = num_strings;
	string_meta.warranty.has_warranty = false;
	string_meta.failure[0].distribution = 'exponential';
	string_meta.failure[0].parameters = [(2 / 365)]; //failures per year converted to per day
	string_meta.failure[0].times = null;
	string_meta.failure[0].labor_time = 1; //hours
	string_meta.failure[0].cost = 20; //$
	string_meta.repair[0].distribution = 'lognormal';
	string_meta.repair[0].parameters = [7, 3]; //mean, std, days
	string_meta.repair[0].times = null;
	string_meta.degradation.can_degrade = false;
	
//----Combiners------------------------------------------------------------------------------------------------
	global combiner_meta = null;
	combiner_meta.name = 'combiner';
	combiner_meta.can_fail = true;
	combiner_meta.can_repair = true;
	combiner_meta.number = num_combiners;
	combiner_meta.warranty.has_warranty = false;
	combiner_meta.failure[0].distribution = 'normal';
	combiner_meta.failure[0].parameters = [2 * 365, 0.5 * 365]; //mean, std, years converted to days
	combiner_meta.failure[0].times = null;
	combiner_meta.failure[0].labor_time = 2; //hours
	combiner_meta.failure[0].cost = 976; //$
	combiner_meta.repair[0].distribution = 'exponential';
	combiner_meta.repair[0].parameters = [3]; //mean, days
	combiner_meta.repair[0].times = null;
	combiner_meta.degradation.can_degrade = false;
	
//----Inverters------------------------------------------------------------------------------------------------
	global inverter_meta = null;
	inverter_meta.name = 'inverter';
	inverter_meta.can_fail = true;
	inverter_meta.can_repair = true;
	inverter_meta.number = num_inverters;
	inverter_meta.warranty.has_warranty = false; 
	//failure mode 1: component failure
	inverter_meta.failure[0].distribution = 'exponential';
	inverter_meta.failure[0].parameters = [1 / 365]; //failures per year converted to per day
	inverter_meta.failure[0].times = null;
	inverter_meta.failure[0].labor_time = 0;
	inverter_meta.failure[0].cost = 0.2 * 0.35 * inverter_size; //0.2 times catastrophic cost, which is 35 cents/Watt
	//failure mode 2: routine failures
	inverter_meta.failure[1].distribution = 'exponential';
	inverter_meta.failure[1].parameters = [1 / 365]; //failures per year converted to per day
	inverter_meta.failure[1].times = null;
	inverter_meta.failure[1].labor_time = 0;
	inverter_routine_cost = 0;
	if (inverter_size <= 10000)
		inverter_routine_cost = 200;
	else if (inverter_size <= 100000)
		inverter_routine_cost = 500;
	else
		inverter_routine_cost = 1000;
	inverter_meta.failure[1].cost = inverter_routine_cost;
	//failure mode 3: catastrophic failure
	inverter_meta.failure[2].distribution = 'normal';
	inverter_meta.failure[2].parameters = [500, 365.25]; //mean, std, in days
	inverter_meta.failure[2].times = null;
	inverter_meta.failure[2].labor_time = 0;
	inverter_meta.failure[2].cost = 0.35 * get('inv_snl_paco'); //35 cents per watt
	//repair mode 1: component failure
	inverter_meta.repair[0].distribution = 'lognormal';
	inverter_meta.repair[0].parameters = [3, 1.5]; //mean, std, in days
	inverter_meta.repair[0].times = null;
	//repair mode 2: routine failure
	inverter_meta.repair[1].distribution = 'exponential';
	inverter_meta.repair[1].parameters = [0.5]; //days
	inverter_meta.repair[1].times = null;
	//repair mode 3: catastrophic failure
	inverter_meta.repair[2].distribution = 'lognormal';
	inverter_meta.repair[2].parameters = [3, 1.5]; //mean, std, in days
	inverter_meta.repair[2].times = null;
	//degradation
	inverter_meta.degradation.can_degrade = false;
	
//----AC Disconnects-------------------------------------------------------------------------------------------
	global disconnect_meta = null;
	disconnect_meta.name = 'disconnect';
	disconnect_meta.can_fail = true;
	disconnect_meta.can_repair = true;
	disconnect_meta.number = num_disconnects;
	disconnect_meta.warranty.has_warranty = false;
	disconnect_meta.failure[0].distribution = 'weibull';
	disconnect_meta.failure[0].parameters = [0.3477, 3 * 365]; //slope (same as shape factor)- unitless, mean- years converted to days
	disconnect_meta.failure[0].times = null;
	disconnect_meta.failure[0].labor_time = 4; //hours
	disconnect_meta.failure[0].cost = 500; //$
	disconnect_meta.repair[0].distribution = 'lognormal';
	disconnect_meta.repair[0].parameters = [1, 0.5]; //mean, std, in years converted to days
	disconnect_meta.repair[0].times = null;
	disconnect_meta.degradation.can_degrade = false;
	
//----Transformers---------------------------------------------------------------------------------------------
	global transformer_meta = null;
	transformer_meta.name = 'transformer';
	transformer_meta.can_fail = true;
	transformer_meta.can_repair = true;
	transformer_meta.number = num_transformers;
	transformer_meta.warranty.has_warranty = false;
	transformer_meta.failure[0].distribution = 'weibull';
	transformer_meta.failure[0].parameters = [0.3477, 1 * 365]; //slope (shape factor)- unitless, mean- days
	transformer_meta.failure[0].times = null;
	transformer_meta.failure[0].labor_time = 10; //hours
	transformer_meta.failure[0].cost = 32868; //$
	transformer_meta.repair[0].distribution = 'lognormal';
	transformer_meta.repair[0].parameters = [0.25, 0.5]; //mean, std, in days
	transformer_meta.repair[0].times = null;
	transformer_meta.degradation.can_degrade = false;
	
//----Grid-----------------------------------------------------------------------------------------------------
	global grid_meta = null;
	grid_meta.name = 'grid';
	grid_meta.can_fail = true;
	grid_meta.can_repair = true;
	grid_meta.number = 1;
	grid_meta.warranty.has_warranty = false;
	grid_meta.failure[0].distribution = 'weibull';
	grid_meta.failure[0].parameters = [0.75, 100]; //slope (shape factor)- unitless, mean- days
	grid_meta.failure[0].times = null;
	grid_meta.failure[0].labor_time = 0;
	grid_meta.failure[0].cost = 0;
	grid_meta.repair[0].distribution = 'exponential';
	grid_meta.repair[0].parameters = [0.5]; //mean in days
	grid_meta.repair[0].times = null;
	grid_meta.degradation.can_degrade = false;
	
//----Trackers-------------------------------------------------------------------------------------------------
	// Only required for tracking systems, otherwise can be deleted or commented out
	/*
	global trackers = alloc(num_trackers);
	global tracker_meta = null;
	tracker_meta.name = 'tracker';
	tracker_meta.can_fail = true;
	tracker_meta.can_repair = true;
	tracker_meta.number = num_trackers;
	tracker_meta.warranty.has_warranty = false;
	tracker_meta.failure[0].distribution = 'exponential';
	tracker_meta.failure[0].parameters = [0.002]; //mean per year in days
	tracker_meta.failure[0].times = null;
	tracker_meta.failure[0].labor_time = 0;
	tracker_meta.failure[0].cost = 2000; //present day tracker cost, will be inflated
	tracker_meta.repair[0].distribution = 'lognormal';
	tracker_meta.repair[0].parameters = [30, 10]; //mean, std, in days
	tracker_meta.repair[0].times = null;
	tracker_meta.degradation.can_degrade = false;
	*/



//********************************************************************************************************************************************************************************
// SYSTEM CONFIGURATION AND ACTIVE CASE ERROR CHECKING
//********************************************************************************************************************************************************************************

	// There must be an integer number of strings per combiner
	if (num_strings_per_combiner * num_combiners != num_strings) 
	{
		msgbox('Error: there must be an integer number of strings per combiner.');
		exit;
	}
	// There must be an integer number of inverters per transformer
	if (num_inverters_per_transformer * num_transformers != num_inverters) 
	{
		msgbox('Error: there must be an integer number of inverters per transformer.');
		exit;
	}
	
	cfg = configuration();
	fin = cfg[1];
	tech = cfg[0];
	// Technology must be detailed PV model
	if (tech != 'Flat Plate PV')
	{
		msgbox('Error: This script is only applicable to the detailed photovoltaic model. Exiting simulation.');
		exit;
	}
	// Financial models third party, LCOE calculator, and None don't have lifetime mode (note that ALL financial models calculate LCOE, not just the LCOE calculator!)
	if (fin == 'Third Party' || fin == 'LCOE Calculator' || fin == 'None')
	{
		msgbox('Error: This script cannot be run from financial model: ' + fin + '. Exiting simulation.');
		exit;
	}
	// Must be run in lifetime mode
	is_lifetime_mode = get('pv_lifetime_simulation');
	if (!is_lifetime_mode)
	{
		make_lifetime_mode = yesno('PV simulations must be run in lifetime mode with this script. Change your case to lifetime mode now?');
		if (!make_lifetime_mode)
		{
			msgbox('Error: Please modify your case to use lifetime mode. Exiting simulation');
			exit;
		}
		set('pv_lifetime_simulation', 1);
	}
	// Lifetime daily DC and AC loss structures must be empty to run.
	if (get('en_dc_lifetime_losses') || get('en_ac_lifetime_losses'))
	{
		proceed = yesno('This script will overwrite any user-entered lifetime daily losses, and they will be lost. Proceed?');
		if (!proceed)
		{
			msgbox('Please modify the case not to use user-entered lifetime daily losses. Exiting simulation.');
			exit;
		}
	}
	// Multiple subarrays can't have tracker failures
	if (has_multiple_subarrays && is_tracking_system && tracker_meta.can_fail)
	{
		msgbox('Error: Tracker failures may only be modeled for a system consisting of a single subarray. Exiting simulation.');
		exit;
	}
	// Tracking systems can't be 2-axis or azimuth-axis
	if (is_tracking_system)
	{
		//only need to check subarray 1, since at this point tracking systems with multiple subarrays will have been terminated.
		if (get('subarray1_track_mode') == 2 || get('subarray1_track_mode') == 3)
		{
			msgbox('Error: This script is not configured to run with 2-axis tracking or azimuth-axis tracking systems. Exiting simulation.');
			exit;
		}
	}
	
//********************************************************************************************************************************************************************************
// PRE-CALCULATE THE TRACKER LOSSES FOR A TRACKING SYSTEM WHERE FAILURES ARE ENABLED, SINCE THIS WILL BE CONSTANT BETWEEN SIMULATIONS
//********************************************************************************************************************************************************************************
daily_tracker_coeffs = alloc(365);
if (is_tracking_system && tracker_meta.can_fail)
{
	
	if (get('subarray1_tilt') != 0)
	{
		msgbox('This script can only model tracker failures for 0 degree tilt trackers. Exiting simulation.');
		exit;
	}
	
	// calculate hourly performance with tracker for one year
	user_analysis_period = get('analysis_period');
	set('analysis_period', 1);
	set('en_ac_lifetime_losses', 0);
	set('en_dc_lifetime_losses', 0);
	if (!simulate('', 0))
	{
		msgbox('Error simulating first-year tracker performance');
		set('analysis_period', user_analysis_period);
		exit;
	}
	timeseries_with_tracker = get('dc_net');
	
	// calculate hourly performance without trackers for one year
	user_tracking_mode = get('subarray1_track_mode');
	user_azimuth = get('subarray1_azimuth');
	user_tilt = get('subarray1_tilt');
	set('subarray1_track_mode', 0); //set to fixed tilt
	if (user_azimuth > 360 || user_azimuth < 0)
	{
		msgbox('Azimuth must be between 0 and 360. Please adjust the azimuth and try again.');
		exit;
	}
	//assume worst case tracker gets stuck to north. If axis is north-south, assume gets stuck to west.
	if (use_worst_case_tracker)
	{
		worst_case_az = user_azimuth;
		if (user_azimuth < 180)
			worst_case_az -= 90;
		else
			worst_case_az += 90;
		if (worst_case_az < 0)
			worst_case_az += 360;
		if (worst_case_az >= 360)
			worst_case_az -=360;
		set('subarray1_azimuth', worst_case_az);
		set('subarray1_tilt', get('subarray1_rotlim'));
	}
	//assume average case is that tracker gets stuck flat
	else
		set('subarray1_tilt', 0); //doesn't matter what az is if it's flat
	if (!simulate('', 0))
	{
		msgbox('Error simulating first-year tracker failure performance');
		set('analysis_period', user_analysis_period);
		set('subarray1_track_mode', user_tracking_mode); 
		set('subarray1_azimuth', user_azimuth);
		set('subarray1_tilt', user_tilt);
		exit;
	}
	timeseries_without_tracker = get('dc_net');
	
	//calculate daily loss statistics
	timestep = (#timeseries_with_tracker / 8760);
	index = 0;
	for (d=0; d<365; d++)
	{
		sum_without_tracker = 0;
		sum_with_tracker = 0;
		for (h=0; h<24; h++)
			for (ts=0; ts<timestep; ts++)
			{
				sum_without_tracker += timeseries_without_tracker[index];
				sum_with_tracker += timeseries_with_tracker[index];
				index++;
			}
		//NOTE: On some cloudy days, daily_tracker_coeff might be positive!! See help for details.
		daily_tracker_coeffs[d] = sum_without_tracker / sum_with_tracker;
	}
	
	//reset the inputs to user specified values
	set('analysis_period', user_analysis_period);
	set('subarray1_track_mode', user_tracking_mode); 
	set('subarray1_azimuth', user_azimuth);
	set('subarray1_tilt', user_tilt);
}


//********************************************************************************************************************************************************************************
// RUN THE SYSTEM REALIZATIONS
//********************************************************************************************************************************************************************************
lcoe = run_system_realization();
outln(lcoe);

















