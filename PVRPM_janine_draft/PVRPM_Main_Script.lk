
//*************************************************************************************
//PV Reliability and Performance Model Version 2.0 
//Inputs and Control Script -- DRAFT --
//Janine Freeman, NREL
//16 December 2016
//*************************************************************************************

//Import the function to simulate a single instance of a system
import 'PVRPM_Function.lk';

results_file = 'C:/users/jfreeman/desktop/pvrpm_results.csv';

//*******************************************************************************************************************************************************************************
// USER-DEFINED INPUTS
// Please modify these inputs to match your system configuration and desired assumptions.
//*******************************************************************************************************************************************************************************

//----System setup---------------------------------------------------------------------------------------------
	num_combiners = 2; //total number of DC combiner boxes
	num_transformers = 1; //total number of Transformers
	num_trackers = 0; //
	
//----Financial inputs-----------------------------------------------------------------------------------------
	present_day_labor_rate = 100; //dollars per hour
	inflation = 3; //%
	
//----Tracker failure algorithm--------------------------------------------------------------------------------
	use_worst_case_tracker = false;

//----Degradation input function-------------------------------------------------------------------------------
	/*
	Equation format must follow:
	Inputs: 	percent_per_day = degradation rate in percent per DAY
				t = time (in DAYS) since the module was new or replaced
	Return: Current degradation factor in fractional form, 
	i.e. if module is 2% degraded, returns 0.98
	*/
	function current_degradation_rate(percent_per_day, t)
	{
		return 1 / pow((1 + percent_per_day / 100), t);
	}	

//----Number of stochastic realizations to be run--------------------------------------------------------------
	num_realizations = 5;
	p_value = 75; //PXX is what will get calculated

//********************************************************************************************************************************************************************************
// CASE-DEFINED INPUTS
// System inputs are taken from the active SAM case. The user SHOULD NOT modify these inputs.
//********************************************************************************************************************************************************************************

	if (active_case() == '')
	{
		msgbox('Please select a SAM case.');
		exit;
	}
	
	num_modules = get('total_modules');
	num_modules_per_string = get('modules_per_string');
	num_strings = get('strings_in_parallel');
	num_inverters = get('inverter_count');
	inverter_size = ?(get('inverter_model')) [get('inv_snl_paco'), get('inv_ds_paco'), get('inv_pd_paco')];
	num_disconnects = num_inverters; //assume 1 AC disconnect per inverter
	num_strings_per_combiner = floor(num_strings / num_combiners);
	num_inverters_per_transformer = floor(num_inverters / num_transformers);
	
	system_lifetime_yrs = get('analysis_period');
	has_multiple_subarrays = ( (get('subarray2_enable') == 1) || (get('subarray3_enable') == 1) || (get('subarray4_enable') == 1) );
	is_tracking_system = false;
	if ((get('subarray1_track_mode') == 1 || get('subarray1_track_mode') == 2 || get('subarray1_track_mode') == 3))
		is_tracking_system = true;
	if (get('subarray2_enable') == 1 && (get('subarray2_track_mode') == 1 || get('subarray2_track_mode') == 2 || get('subarray2_track_mode') == 3))
		is_tracking_system = true;
	if (get('subarray3_enable') == 1 && (get('subarray3_track_mode') == 1 || get('subarray3_track_mode') == 2 || get('subarray3_track_mode') == 3))
		is_tracking_system = true;
	if (get('subarray4_enable') == 1 && (get('subarray4_track_mode') == 1 || get('subarray4_track_mode') == 2 || get('subarray4_track_mode') == 3))
		is_tracking_system = true;
		
		
//********************************************************************************************************************************************************************************
// USER-DEFINED COMPONENT META DATA
// These inputs control the failure and repair modes and costs for the different component types. Please modify these inputs.
//********************************************************************************************************************************************************************************
//----Component meta information-------------------------------------------------------------------------------
	// The structure of a component meta container is as follows
	/*
	name = a string containing the name of the component type, used for error reporting
	number = number of that type of component in the system
	can_fail = true if component is allowed to fail
	can_repair = true if component is allowed to be repaired after failing
	warranty
		has_warranty = true if the component has a warranty, otherwise false
		days = number of days that the warranty is for (e.g. a 20 year warranty would be 20 * 365 days)
	failure[i]
		distribution = distribution type of failure mode i
		parameters = a table of parameters for failure mode i (e.g. [45, 15] )
		times = a vector of failure times for failure mode i
		labor_time = number of hours of labor it takes to repair this type of failure
		cost = parts cost to repair this type of failure
		***OPTIONAL PARAMETER
		***fraction = If fraction is defined, then failure mode i is a defective failure mode, and "fraction" represents the fraction of this type of component that are defective
	repair[i]
		distribution = distribution type of repair times
		parameters = parameters of the repair distribution
		times = a vector of repair times
		**NOTE: If there is only ONE repair distribution (repair[0]), then ALL failure modes will use that distribution! Otherwise, # repair modes must equal # failure modes.
	degradation (MODULES ONLY)
		can_degrade = true if the component has degradation
		rate = degradation rate (%/year)
	*/

//----Modules--------------------------------------------------------------------------------------------------
	global module_meta = null;
	module_meta.name = 'module';	
	module_meta.can_fail = true;
	module_meta.can_repair = true;
	module_meta.number = num_modules;
	module_meta.warranty.has_warranty = true;
	module_meta.warranty.days = 20 * 365; //years converted to days
	//failure mode 1: normal failures
	module_meta.failure[0].distribution = 'normal';
	module_meta.failure[0].parameters = [4 * 365, 1 * 365]; //mean, std, years converted to days
	module_meta.failure[0].times = null;
	module_meta.failure[0].labor_time = 2; //hours
	module_meta.failure[0].cost = 322; //$
	//failure mode 2: defective failures
	module_meta.failure[1].distribution = 'exponential';
	module_meta.failure[1].parameters = [0.5 / 365]; //failures per year converted to days
	module_meta.failure[1].times = null;
	module_meta.failure[1].labor_time = 2; //hours
	module_meta.failure[1].cost = 322; //$
	module_meta.failure[1].fraction = 20 / 100; //% converted to fraction
	//repair mode: only one repair mode for both failure types
	module_meta.repair[0].distribution = 'lognormal';
	module_meta.repair[0].parameters =  [60, 20]; //mean, std, in days
	module_meta.repair[0].times = null;
	module_meta.degradation.can_degrade = true;
	module_meta.degradation.rate = 5; //%/year
	
//----Strings--------------------------------------------------------------------------------------------------
	global string_meta = null;
	string_meta.name = 'string';
	string_meta.can_fail = true;
	string_meta.can_repair = true;
	string_meta.number = num_strings;
	string_meta.warranty.has_warranty = false;
	string_meta.failure[0].distribution = 'exponential';
	string_meta.failure[0].parameters = [(2 / 365)]; //failures per year converted to per day
	string_meta.failure[0].times = null;
	string_meta.failure[0].labor_time = 1; //hours
	string_meta.failure[0].cost = 20; //$
	string_meta.repair[0].distribution = 'lognormal';
	string_meta.repair[0].parameters = [7, 3]; //mean, std, days
	string_meta.repair[0].times = null;
	string_meta.degradation.can_degrade = false;
	
//----Combiners------------------------------------------------------------------------------------------------
	global combiner_meta = null;
	combiner_meta.name = 'combiner';
	combiner_meta.can_fail = true;
	combiner_meta.can_repair = true;
	combiner_meta.number = num_combiners;
	combiner_meta.warranty.has_warranty = false;
	combiner_meta.failure[0].distribution = 'normal';
	combiner_meta.failure[0].parameters = [2 * 365, 0.5 * 365]; //mean, std, years converted to days
	combiner_meta.failure[0].times = null;
	combiner_meta.failure[0].labor_time = 2; //hours
	combiner_meta.failure[0].cost = 976; //$
	combiner_meta.repair[0].distribution = 'exponential';
	combiner_meta.repair[0].parameters = [3]; //mean, days
	combiner_meta.repair[0].times = null;
	combiner_meta.degradation.can_degrade = false;
	
//----Inverters------------------------------------------------------------------------------------------------
	global inverter_meta = null;
	inverter_meta.name = 'inverter';
	inverter_meta.can_fail = true;
	inverter_meta.can_repair = true;
	inverter_meta.number = num_inverters;
	inverter_meta.warranty.has_warranty = false; 
	//failure mode 1: component failure
	inverter_meta.failure[0].distribution = 'exponential';
	inverter_meta.failure[0].parameters = [1 / 365]; //failures per year converted to per day
	inverter_meta.failure[0].times = null;
	inverter_meta.failure[0].labor_time = 0;
	inverter_meta.failure[0].cost = 0.2 * 0.35 * inverter_size; //0.2 times catastrophic cost, which is 35 cents/Watt
	//failure mode 2: routine failures
	inverter_meta.failure[1].distribution = 'exponential';
	inverter_meta.failure[1].parameters = [1 / 365]; //failures per year converted to per day
	inverter_meta.failure[1].times = null;
	inverter_meta.failure[1].labor_time = 0;
	inverter_routine_cost = 0;
	if (inverter_size <= 10000)
		inverter_routine_cost = 200;
	else if (inverter_size <= 100000)
		inverter_routine_cost = 500;
	else
		inverter_routine_cost = 1000;
	inverter_meta.failure[1].cost = inverter_routine_cost;
	//failure mode 3: catastrophic failure
	inverter_meta.failure[2].distribution = 'normal';
	inverter_meta.failure[2].parameters = [500, 365.25]; //mean, std, in days
	inverter_meta.failure[2].times = null;
	inverter_meta.failure[2].labor_time = 0;
	inverter_meta.failure[2].cost = 0.35 * get('inv_snl_paco'); //35 cents per watt
	//repair mode 1: component failure
	inverter_meta.repair[0].distribution = 'lognormal';
	inverter_meta.repair[0].parameters = [3, 1.5]; //mean, std, in days
	inverter_meta.repair[0].times = null;
	//repair mode 2: routine failure
	inverter_meta.repair[1].distribution = 'exponential';
	inverter_meta.repair[1].parameters = [0.5]; //days
	inverter_meta.repair[1].times = null;
	//repair mode 3: catastrophic failure
	inverter_meta.repair[2].distribution = 'lognormal';
	inverter_meta.repair[2].parameters = [3, 1.5]; //mean, std, in days
	inverter_meta.repair[2].times = null;
	//degradation
	inverter_meta.degradation.can_degrade = false;
	
//----AC Disconnects-------------------------------------------------------------------------------------------
	global disconnect_meta = null;
	disconnect_meta.name = 'disconnect';
	disconnect_meta.can_fail = true;
	disconnect_meta.can_repair = true;
	disconnect_meta.number = num_disconnects;
	disconnect_meta.warranty.has_warranty = false;
	disconnect_meta.failure[0].distribution = 'weibull';
	disconnect_meta.failure[0].parameters = [0.3477, 3 * 365]; //slope (same as shape factor)- unitless, mean- years converted to days
	disconnect_meta.failure[0].times = null;
	disconnect_meta.failure[0].labor_time = 4; //hours
	disconnect_meta.failure[0].cost = 500; //$
	disconnect_meta.repair[0].distribution = 'lognormal';
	disconnect_meta.repair[0].parameters = [1, 0.5]; //mean, std, in years converted to days
	disconnect_meta.repair[0].times = null;
	disconnect_meta.degradation.can_degrade = false;
	
//----Transformers---------------------------------------------------------------------------------------------
	global transformer_meta = null;
	transformer_meta.name = 'transformer';
	transformer_meta.can_fail = true;
	transformer_meta.can_repair = true;
	transformer_meta.number = num_transformers;
	transformer_meta.warranty.has_warranty = false;
	transformer_meta.failure[0].distribution = 'weibull';
	transformer_meta.failure[0].parameters = [0.3477, 1 * 365]; //slope (shape factor)- unitless, mean- days
	transformer_meta.failure[0].times = null;
	transformer_meta.failure[0].labor_time = 10; //hours
	transformer_meta.failure[0].cost = 32868; //$
	transformer_meta.repair[0].distribution = 'lognormal';
	transformer_meta.repair[0].parameters = [0.25, 0.5]; //mean, std, in days
	transformer_meta.repair[0].times = null;
	transformer_meta.degradation.can_degrade = false;
	
//----Grid-----------------------------------------------------------------------------------------------------
	global grid_meta = null;
	grid_meta.name = 'grid';
	grid_meta.can_fail = true;
	grid_meta.can_repair = true;
	grid_meta.number = 1;
	grid_meta.warranty.has_warranty = false;
	grid_meta.failure[0].distribution = 'weibull';
	grid_meta.failure[0].parameters = [0.75, 100]; //slope (shape factor)- unitless, mean- days
	grid_meta.failure[0].times = null;
	grid_meta.failure[0].labor_time = 0;
	grid_meta.failure[0].cost = 0;
	grid_meta.repair[0].distribution = 'exponential';
	grid_meta.repair[0].parameters = [0.5]; //mean in days
	grid_meta.repair[0].times = null;
	grid_meta.degradation.can_degrade = false;
	
//----Trackers-------------------------------------------------------------------------------------------------
	// Only required for tracking systems, otherwise can be deleted or commented out
	/*
	global trackers = alloc(num_trackers);
	global tracker_meta = null;
	tracker_meta.name = 'tracker';
	tracker_meta.can_fail = true;
	tracker_meta.can_repair = true;
	tracker_meta.number = num_trackers;
	tracker_meta.warranty.has_warranty = false;
	tracker_meta.failure[0].distribution = 'exponential';
	tracker_meta.failure[0].parameters = [0.002]; //mean per year in days
	tracker_meta.failure[0].times = null;
	tracker_meta.failure[0].labor_time = 0;
	tracker_meta.failure[0].cost = 2000; //present day tracker cost, will be inflated
	tracker_meta.repair[0].distribution = 'lognormal';
	tracker_meta.repair[0].parameters = [30, 10]; //mean, std, in days
	tracker_meta.repair[0].times = null;
	tracker_meta.degradation.can_degrade = false;
	*/



//********************************************************************************************************************************************************************************
// SYSTEM CONFIGURATION AND ACTIVE CASE ERROR CHECKING
//********************************************************************************************************************************************************************************

	// There must be an integer number of strings per combiner
	if (num_strings_per_combiner * num_combiners != num_strings) 
	{
		msgbox('Error: there must be an integer number of strings per combiner.');
		exit;
	}
	// There must be an integer number of inverters per transformer
	if (num_inverters_per_transformer * num_transformers != num_inverters) 
	{
		msgbox('Error: there must be an integer number of inverters per transformer.');
		exit;
	}
	
	cfg = configuration();
	fin = cfg[1];
	tech = cfg[0];
	// Technology must be detailed PV model
	if (tech != 'Flat Plate PV')
	{
		msgbox('Error: This script is only applicable to the detailed photovoltaic model. Exiting simulation.');
		exit;
	}
	// Financial models third party, LCOE calculator, and None don't have lifetime mode (note that ALL financial models calculate LCOE, not just the LCOE calculator!)
	if (fin == 'Third Party' || fin == 'LCOE Calculator' || fin == 'None')
	{
		msgbox('Error: This script cannot be run from financial model: ' + fin + '. Exiting simulation.');
		exit;
	}
	// Must be run in lifetime mode
	is_lifetime_mode = get('pv_lifetime_simulation');
	if (!is_lifetime_mode)
	{
		make_lifetime_mode = yesno('PV simulations must be run in lifetime mode with this script. Change your case to lifetime mode now?');
		if (!make_lifetime_mode)
		{
			msgbox('Error: Please modify your case to use lifetime mode. Exiting simulation');
			exit;
		}
		set('pv_lifetime_simulation', 1);
	}
	// Lifetime daily DC and AC loss structures must be empty to run.
	if (get('en_dc_lifetime_losses') || get('en_ac_lifetime_losses'))
	{
		proceed = yesno('This script will overwrite any user-entered lifetime daily losses, and they will be lost. Proceed?');
		if (!proceed)
		{
			msgbox('Please modify the case not to use user-entered lifetime daily losses. Exiting simulation.');
			exit;
		}
	}
	// Multiple subarrays can't have tracker failures
	if (has_multiple_subarrays && is_tracking_system && tracker_meta.can_fail)
	{
		msgbox('Error: Tracker failures may only be modeled for a system consisting of a single subarray. Exiting simulation.');
		exit;
	}
	// Tracking systems can't be 2-axis or azimuth-axis
	if (is_tracking_system)
	{
		//only need to check subarray 1, since at this point tracking systems with multiple subarrays will have been terminated.
		if (get('subarray1_track_mode') == 2 || get('subarray1_track_mode') == 3)
		{
			msgbox('Error: This script is not configured to run with 2-axis tracking or azimuth-axis tracking systems. Exiting simulation.');
			exit;
		}
	}
	// Limitations of empirical P-value calculation
	//Or, do we extrapolate the last data point if there are too few realizations?
	//Or, do we give a choice between assuming a normal distribution, and empirical calculation?
	max_p_value = (1 - 1 / num_realizations) * 100;
	if ( p_value > max_p_value )
	{
		msgbox('Error: The maximum p-value that can be calculated with ' + num_realizations + 'is ' + max_p_value + '. Please either lower your desired p-value or increase the number of realizations.');
		exit;
	}
	
//********************************************************************************************************************************************************************************
// PRE-CALCULATE THE TRACKER LOSSES FOR A TRACKING SYSTEM WHERE FAILURES ARE ENABLED, SINCE THIS WILL BE CONSTANT BETWEEN SIMULATIONS
//********************************************************************************************************************************************************************************
daily_tracker_coeffs = alloc(365);
if (is_tracking_system && tracker_meta.can_fail)
{
	
	if (get('subarray1_tilt') != 0)
	{
		msgbox('This script can only model tracker failures for 0 degree tilt trackers. Exiting simulation.');
		exit;
	}
	
	// calculate hourly performance with tracker for one year
	user_analysis_period = get('analysis_period');
	set('analysis_period', 1);
	set('en_ac_lifetime_losses', 0);
	set('en_dc_lifetime_losses', 0);
	if (!simulate('', 0))
	{
		msgbox('Error simulating first-year tracker performance');
		set('analysis_period', user_analysis_period);
		exit;
	}
	timeseries_with_tracker = get('dc_net');
	
	// calculate hourly performance without trackers for one year
	user_tracking_mode = get('subarray1_track_mode');
	user_azimuth = get('subarray1_azimuth');
	user_tilt = get('subarray1_tilt');
	set('subarray1_track_mode', 0); //set to fixed tilt
	if (user_azimuth > 360 || user_azimuth < 0)
	{
		msgbox('Azimuth must be between 0 and 360. Please adjust the azimuth and try again.');
		exit;
	}
	//assume worst case tracker gets stuck to north. If axis is north-south, assume gets stuck to west.
	if (use_worst_case_tracker)
	{
		worst_case_az = user_azimuth;
		if (user_azimuth < 180)
			worst_case_az -= 90;
		else
			worst_case_az += 90;
		if (worst_case_az < 0)
			worst_case_az += 360;
		if (worst_case_az >= 360)
			worst_case_az -=360;
		set('subarray1_azimuth', worst_case_az);
		set('subarray1_tilt', get('subarray1_rotlim'));
	}
	//assume average case is that tracker gets stuck flat
	else
		set('subarray1_tilt', 0); //doesn't matter what az is if it's flat
	if (!simulate('', 0))
	{
		msgbox('Error simulating first-year tracker failure performance');
		set('analysis_period', user_analysis_period);
		set('subarray1_track_mode', user_tracking_mode); 
		set('subarray1_azimuth', user_azimuth);
		set('subarray1_tilt', user_tilt);
		exit;
	}
	timeseries_without_tracker = get('dc_net');
	
	//calculate daily loss statistics
	timestep = (#timeseries_with_tracker / 8760);
	index = 0;
	for (d=0; d<365; d++)
	{
		sum_without_tracker = 0;
		sum_with_tracker = 0;
		for (h=0; h<24; h++)
			for (ts=0; ts<timestep; ts++)
			{
				sum_without_tracker += timeseries_without_tracker[index];
				sum_with_tracker += timeseries_with_tracker[index];
				index++;
			}
		//NOTE: On some cloudy days, daily_tracker_coeff might be positive!! See help for details.
		daily_tracker_coeffs[d] = sum_without_tracker / sum_with_tracker;
	}
	
	//reset the inputs to user specified values
	set('analysis_period', user_analysis_period);
	set('subarray1_track_mode', user_tracking_mode); 
	set('subarray1_azimuth', user_azimuth);
	set('subarray1_tilt', user_tilt);
}


//********************************************************************************************************************************************************************************
// RUN THE SYSTEM REALIZATIONS
//********************************************************************************************************************************************************************************
lcoe_array = alloc(num_realizations);
pb = progressbar( {title='Simulation progress', message='Initializing',cancelbutton=true, time=true, max=system_lifetime_yrs * 365});
for (i=0; i<num_realizations; i++)
{
	results[i] = run_system_realization(i, false);
	outln('Completed realization ' + i);
}
progressbar(pb);

//outln(results);


//********************************************************************************************************************************************************************************
// CALCULATE STATISTICS AND WRITE RESULTS
//********************************************************************************************************************************************************************************
lifetime = get('analysis_period');
num_module_failure_modes = #results[0].module_failures_by_type;
num_inverter_failure_modes = #results[0].inverter_failures_by_type;
for (i=0; i<num_realizations; i++)
{
	data.realization[i] = i;
	data.lcoe[i] = results[i].lcoe;
	data.total_module_failures[i] = results[i].total_module_failures;
	for (j=0; j<num_module_failure_modes; j++)
		data{'module_failures_' + j}[i] = results[i].module_failures_by_type[j];
	data.total_string_failures[i] = results[i].total_string_failures;
	data.total_combiner_failures[i] = results[i].total_combiner_failures;
	data.total_inverter_failures[i] = results[i].total_inverter_failures;
	for (j=0; j<num_inverter_failure_modes; j++)
		data{'inverter_failures_' + j}[i] = results[i].inverter_failures_by_type[j];
	data.total_disconnect_failures[i] = results[i].total_disconnect_failures;
	data.total_transformer_failures[i] = results[i].total_transformer_failures;
	data.total_grid_failures[i] = results[i].total_grid_failures;
	//outln('Inverter failures by type = ' + inverter_failures_by_type);
	for (j=1; j<=lifetime; j++) //start at 1 because the array returns year 0, where the energy production is always 0, and goes through the full lifetime (so a 5-year system would have 6 entries in the annual energy output)
		data{'annual_energy_' + j}[i] = results[i].annual_energy[j];
}

//Calculate statistics
data_columns = @data;
for (c=0; c<#data_columns; c++)
{
	current_row = num_realizations; //start at the end of the individual realization results for each column
	array = data{data_columns[c]};
	
	//calculate minimum
	array_min = min(array);
	data.realization[current_row] = 'min';
	data{data_columns[c]}[current_row] = array_min;
	current_row++;
	
	//calculate maximum
	array_max = max(array);
	data.realization[current_row] = 'max';
	data{data_columns[c]}[current_row] = array_max;
	current_row++;
	
	//calculate mean
	array_mean = mean(array);
	data.realization[current_row] = 'mean';
	data{data_columns[c]}[current_row] = array_mean;
	current_row++;	
	
	//calculate desired PXX
	//first, sort the results smallest to largest
	for (i=0; i<num_realizations-1; i++)
	{
		//start at the current spot in the output
		smallest = i;
		for (j=i+1; j<num_realizations; j++) //find the index of the smallest number in the remaining range
			if (array[j] < array[smallest])
				smallest = j; 
		//swap the spots of the current i and the smallest number
		if (smallest != i)
		{
			array_temp = array[i];
			array[i] = array[smallest];
			array[smallest] = array_temp;	
		}			
	}
	//then, calculate the PXX by linearly interpolating between the point below and point above
	//point x0, y0 is the lower CDF value and corresponding result, respectively
	//point x1, y1 is the next highest CDF value and corresponding result, respectively
	//x is the desired CDF (calculated from the p-value)
	//y is the result corresponding to x
	//P90n = mean - (1.282 * stdDev); normal P90, maybe include later???
	x = 1 - p_value / 100; //calculate the CDF corresponding to the given p-value: ex: a p-value of 90 would have a corresponding CDF of 0.1
	idx0 = floor(x * num_realizations + 0.001) - 1; //subtract 1 from the calculated index because arrays are 0-indexed, the +0.001 is to avoid problems with the representation of double precision numbers
	idx1 = idx0 + 1;
	x0 = (idx0 + 1) * 1 / num_realizations;
	y0 = array[idx0];
	x1 = (idx1 + 1) * 1 / num_realizations;
	y1 = array[idx1];
	array_p = y0 + (x-x0) * (y1-y0) / (x1-x0); //see linear interpolation formula from https://en.wikipedia.org/wiki/Linear_interpolation*/
	data.realization[current_row] = 'P' + p_value;
	data{data_columns[c]}[current_row] = array_p;
	current_row++; //in case we add more calculated variables later
	
}

//write the output file
csvwrite(results_file, data);















