
//*************************************************************************************
//PV Reliability and Performance Model Version 2.0 
//Inputs and Control Script -- DRAFT --
//Janine Freeman, NREL
//21 April 2017
//*************************************************************************************

//Supporting functions located in a separate file
import 'PVRPM_Function.lk';

//Specify results options
//results_file = 'C:/users/jfreeman/desktop/pvrpm_results/pvrpm_results.csv';
global results_folder = 'C:/users/jfreeman/desktop/pvrpm_results';
show_realization_graphs = false;

//*******************************************************************************************************************************************************************************
// USER-DEFINED INPUTS
// Please modify these inputs to match your system configuration and desired assumptions.
//*******************************************************************************************************************************************************************************

//----System setup---------------------------------------------------------------------------------------------
	num_combiners = 2; //total number of DC combiner boxes
	num_transformers = 1; //total number of Transformers
	num_trackers = 2; //total number of trackers
	
//----Financial inputs-----------------------------------------------------------------------------------------
	present_day_labor_rate = 100; //dollars per hour
	inflation = 3; //%
	
//----Tracker failure algorithm--------------------------------------------------------------------------------
	use_worst_case_tracker = true;

//----Degradation input function-------------------------------------------------------------------------------
	/*
	Equation format must follow:
	Inputs: 	percent_per_day = degradation rate in percent per DAY
				t = time (in DAYS) since the module was new or replaced
	Return: Current degradation factor in fractional form, 
	i.e. if module is 2% degraded, returns 0.98
	*/
	function current_degradation_rate(percent_per_day, t)
	{
		return 1 / pow((1 + percent_per_day / 100), t);
	}	

//----Number of stochastic realizations to be run--------------------------------------------------------------
	num_realizations = 3; //must be 2 or greater
	p_value = 50; //PXX is what will get calculated

//********************************************************************************************************************************************************************************
// CASE-DEFINED INPUTS
// System inputs are taken from the active SAM case. The user SHOULD NOT modify these inputs.
//********************************************************************************************************************************************************************************
	
	//run pre-checks on the case and system configuration to make sure that it will run appropriately
	check_case();
		
//********************************************************************************************************************************************************************************
// USER-DEFINED COMPONENT META DATA
// These inputs control the failure and repair modes and costs for the different component types. Please modify these inputs.
//********************************************************************************************************************************************************************************
//----Component meta information-------------------------------------------------------------------------------
	// The structure of a component meta container is as follows
	/*
	module
	string
	combiner
	inverter
	disconnect
	transformer
	grid
		name = a string containing the name of the component type, used for error reporting
		number = number of that type of component in the system
		can_fail = true if component is allowed to fail
		can_repair = true if component is allowed to be repaired after failing
		warranty
			has_warranty = true if the component has a warranty, otherwise false
			days = number of days that the warranty is for (e.g. a 20 year warranty would be 20 * 365 days)
		failure[i]
			distribution = distribution type of failure mode i
			parameters = a table of parameters for failure mode i (e.g. [45, 15] )
			times = a vector of failure times for failure mode i
			labor_time = number of hours of labor it takes to repair this type of failure
			cost = parts cost to repair this type of failure
			***OPTIONAL PARAMETER
			***fraction = If fraction is defined, then failure mode i is a defective failure mode, and "fraction" represents the fraction of this type of component that are defective
		repair[i]
			distribution = distribution type of repair times
			parameters = parameters of the repair distribution
			times = a vector of repair times
			**NOTE: If there is only ONE repair distribution (repair[0]), then ALL failure modes will use that distribution! Otherwise, # repair modes must equal # failure modes.
		degradation (MODULES ONLY)
			can_degrade = true if the component has degradation
			rate = degradation rate (%/year)
	*/

global meta = null; 

//----Modules--------------------------------------------------------------------------------------------------
	//global meta.module = null;
	meta.module.name = 'module';	
	meta.module.can_fail = true;
	meta.module.can_repair = false;
	meta.module.number = num_modules;
	meta.module.warranty.has_warranty = true;
	meta.module.warranty.days = 20 * 365; //years converted to days
	//failure mode 1: normal failures
	meta.module.failure[0].distribution = 'normal';
	meta.module.failure[0].parameters = [4 * 365, 1 * 365]; //mean, std, years converted to days
	meta.module.failure[0].times = null;
	meta.module.failure[0].labor_time = 2; //hours
	meta.module.failure[0].cost = 322; //$
	//failure mode 2: defective failures
	meta.module.failure[1].distribution = 'exponential';
	meta.module.failure[1].parameters = [0.5 / 365]; //failures per year converted to days
	meta.module.failure[1].times = null;
	meta.module.failure[1].labor_time = 2; //hours
	meta.module.failure[1].cost = 322; //$
	meta.module.failure[1].fraction = 20 / 100; //% converted to fraction
	//repair mode: only one repair mode for both failure types
	meta.module.repair[0].distribution = 'lognormal';
	meta.module.repair[0].parameters =  [60, 20]; //mean, std, in days
	meta.module.repair[0].times = null;
	meta.module.degradation.can_degrade = false;
	meta.module.degradation.rate = 20; //%/year
	
//----Strings--------------------------------------------------------------------------------------------------
	//global meta.string = null;
	meta.string.name = 'string';
	meta.string.can_fail = true;
	meta.string.can_repair = true;
	meta.string.number = num_strings;
	meta.string.warranty.has_warranty = false;
	meta.string.failure[0].distribution = 'exponential';
	meta.string.failure[0].parameters = [(2 / 365)]; //failures per year converted to per day
	meta.string.failure[0].times = null;
	meta.string.failure[0].labor_time = 1; //hours
	meta.string.failure[0].cost = 20; //$
	meta.string.repair[0].distribution = 'lognormal';
	meta.string.repair[0].parameters = [7, 3]; //mean, std, days
	meta.string.repair[0].times = null;
	meta.string.degradation.can_degrade = false;
	
//----Combiners------------------------------------------------------------------------------------------------
	//global meta.combiner = null;
	meta.combiner.name = 'combiner';
	meta.combiner.can_fail = true;
	meta.combiner.can_repair = true;
	meta.combiner.number = num_combiners;
	meta.combiner.warranty.has_warranty = false;
	meta.combiner.failure[0].distribution = 'normal';
	meta.combiner.failure[0].parameters = [2 * 365, 0.5 * 365]; //mean, std, years converted to days
	meta.combiner.failure[0].times = null;
	meta.combiner.failure[0].labor_time = 2; //hours
	meta.combiner.failure[0].cost = 976; //$
	meta.combiner.repair[0].distribution = 'exponential';
	meta.combiner.repair[0].parameters = [3]; //mean, days
	meta.combiner.repair[0].times = null;
	meta.combiner.degradation.can_degrade = false;
	
//----Inverters------------------------------------------------------------------------------------------------
	//global meta.inverter = null;
	meta.inverter.name = 'inverter';
	meta.inverter.can_fail = true;
	meta.inverter.can_repair = true;
	meta.inverter.number = num_inverters;
	meta.inverter.warranty.has_warranty = false; 
	//failure mode 1: component failure
	meta.inverter.failure[0].distribution = 'exponential';
	meta.inverter.failure[0].parameters = [1 / 365]; //failures per year converted to per day
	meta.inverter.failure[0].times = null;
	meta.inverter.failure[0].labor_time = 0;
	meta.inverter.failure[0].cost = 0.2 * 0.35 * inverter_size; //0.2 times catastrophic cost, which is 35 cents/Watt
	//failure mode 2: routine failures
	meta.inverter.failure[1].distribution = 'exponential';
	meta.inverter.failure[1].parameters = [1 / 365]; //failures per year converted to per day
	meta.inverter.failure[1].times = null;
	meta.inverter.failure[1].labor_time = 0;
	inverter_routine_cost = 0;
	if (inverter_size <= 10000)
		inverter_routine_cost = 200;
	else if (inverter_size <= 100000)
		inverter_routine_cost = 500;
	else
		inverter_routine_cost = 1000;
	meta.inverter.failure[1].cost = inverter_routine_cost;
	//failure mode 3: catastrophic failure
	meta.inverter.failure[2].distribution = 'normal';
	meta.inverter.failure[2].parameters = [500, 365.25]; //mean, std, in days
	meta.inverter.failure[2].times = null;
	meta.inverter.failure[2].labor_time = 0;
	meta.inverter.failure[2].cost = 0.35 * get('inv_snl_paco'); //35 cents per watt
	//repair mode 1: component failure
	meta.inverter.repair[0].distribution = 'lognormal';
	meta.inverter.repair[0].parameters = [3, 1.5]; //mean, std, in days
	meta.inverter.repair[0].times = null;
	//repair mode 2: routine failure
	meta.inverter.repair[1].distribution = 'exponential';
	meta.inverter.repair[1].parameters = [0.5]; //days
	meta.inverter.repair[1].times = null;
	//repair mode 3: catastrophic failure
	meta.inverter.repair[2].distribution = 'lognormal';
	meta.inverter.repair[2].parameters = [3, 1.5]; //mean, std, in days
	meta.inverter.repair[2].times = null;
	//degradation
	meta.inverter.degradation.can_degrade = false;
	
//----AC Disconnects-------------------------------------------------------------------------------------------
	//global meta.disconnect = null;
	meta.disconnect.name = 'disconnect';
	meta.disconnect.can_fail = true;
	meta.disconnect.can_repair = true;
	meta.disconnect.number = num_disconnects;
	meta.disconnect.warranty.has_warranty = false;
	meta.disconnect.failure[0].distribution = 'weibull';
	meta.disconnect.failure[0].parameters = [0.3477, 3 * 365]; //slope (same as shape factor)- unitless, mean- years converted to days
	meta.disconnect.failure[0].times = null;
	meta.disconnect.failure[0].labor_time = 4; //hours
	meta.disconnect.failure[0].cost = 500; //$
	meta.disconnect.repair[0].distribution = 'lognormal';
	meta.disconnect.repair[0].parameters = [1, 0.5]; //mean, std, in years converted to days
	meta.disconnect.repair[0].times = null;
	meta.disconnect.degradation.can_degrade = false;
	
//----Transformers---------------------------------------------------------------------------------------------
	//global meta.transformer = null;
	meta.transformer.name = 'transformer';
	meta.transformer.can_fail = true;
	meta.transformer.can_repair = true;
	meta.transformer.number = num_transformers;
	meta.transformer.warranty.has_warranty = false;
	meta.transformer.failure[0].distribution = 'weibull';
	meta.transformer.failure[0].parameters = [0.3477, 1 * 365]; //slope (shape factor)- unitless, mean- days
	meta.transformer.failure[0].times = null;
	meta.transformer.failure[0].labor_time = 10; //hours
	meta.transformer.failure[0].cost = 32868; //$
	meta.transformer.repair[0].distribution = 'lognormal';
	meta.transformer.repair[0].parameters = [0.25, 0.5]; //mean, std, in days
	meta.transformer.repair[0].times = null;
	meta.transformer.degradation.can_degrade = false;
	
//----Grid-----------------------------------------------------------------------------------------------------
	//global meta.grid = null;
	meta.grid.name = 'grid';
	meta.grid.can_fail = true;
	meta.grid.can_repair = true;
	meta.grid.number = 1;
	meta.grid.warranty.has_warranty = false;
	meta.grid.failure[0].distribution = 'weibull';
	meta.grid.failure[0].parameters = [0.75, 100]; //slope (shape factor)- unitless, mean- days
	meta.grid.failure[0].times = null;
	meta.grid.failure[0].labor_time = 0;
	meta.grid.failure[0].cost = 0;
	meta.grid.repair[0].distribution = 'exponential';
	meta.grid.repair[0].parameters = [0.5]; //mean in days
	meta.grid.repair[0].times = null;
	meta.grid.degradation.can_degrade = false;
	
//----Trackers-------------------------------------------------------------------------------------------------
	// Only required for tracking systems, otherwise can be deleted or commented out
	/*
	//global trackers = alloc(num_trackers);
	global meta.tracker = null;
	meta.tracker.name = 'tracker';
	meta.tracker.can_fail = true;
	meta.tracker.can_repair = true;
	meta.tracker.number = num_trackers;
	meta.tracker.warranty.has_warranty = false;
	meta.tracker.failure[0].distribution = 'exponential';
	meta.tracker.failure[0].parameters = [0.002]; //mean per year in days
	meta.tracker.failure[0].times = null;
	meta.tracker.failure[0].labor_time = 0;
	meta.tracker.failure[0].cost = 2000; //present day tracker cost, will be inflated
	meta.tracker.repair[0].distribution = 'lognormal';
	meta.tracker.repair[0].parameters = [30, 10]; //mean, std, in days
	meta.tracker.repair[0].times = null;
	meta.tracker.degradation.can_degrade = false;*/
	



//********************************************************************************************************************************************************************************
// SYSTEM CONFIGURATION AND ACTIVE CASE ERROR CHECKING
//********************************************************************************************************************************************************************************

	// At least one thing must be set up to fail
	if (!meta.module.can_fail && !meta.string.can_fail && !meta.combiner.can_fail && !meta.inverter.can_fail && !meta.disconnect.can_fail && !meta.transformer.can_fail && !meta.grid.can_fail) //CHANGE THIS TO LOOP THROUGH META
	if ((is_tracking_system && !meta.tracker.can_fail) || !is_tracking_system)
	{
		msgbox('Error: you must enable at least one component to fail.');
		exit;
	}
	
	// There must be an integer number of strings per combiner
	if (num_strings_per_combiner * num_combiners != num_strings) 
	{
		msgbox('Error: there must be an integer number of strings per combiner.');
		exit;
	}
	// There must be an integer number of inverters per transformer
	if (num_inverters_per_transformer * num_transformers != num_inverters) 
	{
		msgbox('Error: there must be an integer number of inverters per transformer.');
		exit;
	}
	
	// Number of combiners, transformers, trackers must be positive
	if (num_combiners <= 0)
	{
		msgbox('Error: there must be a positive number of combiners.');
		exit;
	}
	if (num_transformers <= 0)
	{
		msgbox('Error: there must be a positive number of transformers.');
		exit;
	}
	if (is_tracking_system && num_trackers <= 0)
	{
		msgbox('Error: there must be a positive number of trackers.');
		exit;
	}
	

	// Financial models third party, LCOE calculator, and None don't have lifetime mode (note that ALL financial models calculate LCOE, not just the LCOE calculator!)
	fin = cfg[1];
	if (fin == 'Third Party' || fin == 'LCOE Calculator' || fin == 'None')
	{
		msgbox('Error: This script cannot be run from financial model: ' + fin + '. Exiting simulation.');
		exit;
	}
	// Must be run in lifetime mode
	is_lifetime_mode = get('pv_lifetime_simulation');
	if (!is_lifetime_mode)
	{
		make_lifetime_mode = yesno('PV simulations must be run in lifetime mode with this script. Change your case to lifetime mode now?');
		if (!make_lifetime_mode)
		{
			msgbox('Error: Please modify your case to use lifetime mode. Exiting simulation');
			exit;
		}
		set('pv_lifetime_simulation', 1);
	}
	// Lifetime daily DC and AC loss structures must be empty to run.
	/*
	if (get('en_dc_lifetime_losses') || get('en_ac_lifetime_losses'))
	{
		proceed = yesno('This script will overwrite any user-entered lifetime daily losses, and they will be lost. Proceed?');
		if (!proceed)
		{
			msgbox('Please modify the case not to use user-entered lifetime daily losses. Exiting simulation.');
			exit;
		}
	}*/
	// Multiple subarrays can't have tracker failures
	if (has_multiple_subarrays && is_tracking_system && meta.tracker.can_fail)
	{
		msgbox('Error: Tracker failures may only be modeled for a system consisting of a single subarray. Exiting simulation.');
		exit;
	}
	// Tracking systems can't be 2-axis or azimuth-axis
	if (is_tracking_system)
	{
		//only need to check subarray 1, since at this point tracking systems with multiple subarrays will have been terminated.
		if (get('subarray1_track_mode') == 2 || get('subarray1_track_mode') == 3)
		{
			msgbox('Error: This script is not configured to run with 2-axis tracking or azimuth-axis tracking systems. Exiting simulation.');
			exit;
		}
	}
	// Limitations of empirical P-value calculation
	//Or, do we extrapolate the last data point if there are too few realizations?
	//Or, do we give a choice between assuming a normal distribution, and empirical calculation?
	max_p_value = (1 - 1 / num_realizations) * 100;
	if ( p_value > max_p_value )
	{
		msgbox('Error: The maximum p-value that can be calculated with ' + num_realizations + 'is ' + max_p_value + '. Please either lower your desired p-value or increase the number of realizations.');
		exit;
	}
	
//********************************************************************************************************************************************************************************
// PRE-CALCULATE THE TRACKER LOSSES FOR A TRACKING SYSTEM WHERE FAILURES ARE ENABLED, SINCE THIS WILL BE CONSTANT BETWEEN SIMULATIONS
//********************************************************************************************************************************************************************************
if (is_tracking_system)
{
	daily_tracker_coeffs = alloc(365);
	if (meta.tracker.can_fail)
	{
		
		if (get('subarray1_tilt') != 0)
		{
			msgbox('This script can only model tracker failures for 0 degree tilt trackers. Exiting simulation.');
			exit;
		}
		
		// calculate hourly performance with tracker for one year
		user_analysis_period = get('analysis_period');
		set('analysis_period', 1);
		set('en_ac_lifetime_losses', 0);
		set('en_dc_lifetime_losses', 0);
		if (!simulate('', 0))
		{
			msgbox('Error simulating first-year tracker performance');
			set('analysis_period', user_analysis_period);
			exit;
		}
		timeseries_with_tracker = get('dc_net');
		
		// calculate hourly performance without trackers for one year
		user_tracking_mode = get('subarray1_track_mode');
		user_azimuth = get('subarray1_azimuth');
		user_tilt = get('subarray1_tilt');
		set('subarray1_track_mode', 0); //set to fixed tilt
		if (user_azimuth > 360 || user_azimuth < 0)
		{
			msgbox('Azimuth must be between 0 and 360. Please adjust the azimuth and try again.');
			exit;
		}
		//assume worst case tracker gets stuck to north. If axis is north-south, assume gets stuck to west.
		if (use_worst_case_tracker)
		{
			worst_case_az = user_azimuth;
			if (user_azimuth < 180)
				worst_case_az -= 90;
			else
				worst_case_az += 90;
			if (worst_case_az < 0)
				worst_case_az += 360;
			if (worst_case_az >= 360)
				worst_case_az -=360;
			set('subarray1_azimuth', worst_case_az);
			set('subarray1_tilt', get('subarray1_rotlim'));
		}
		//assume average case is that tracker gets stuck flat
		else
			set('subarray1_tilt', 0); //doesn't matter what az is if it's flat
		if (!simulate('', 0))
		{
			msgbox('Error simulating first-year tracker failure performance');
			set('analysis_period', user_analysis_period);
			set('subarray1_track_mode', user_tracking_mode); 
			set('subarray1_azimuth', user_azimuth);
			set('subarray1_tilt', user_tilt);
			exit;
		}
		timeseries_without_tracker = get('dc_net');
		
		//calculate daily loss statistics
		timestep = (#timeseries_with_tracker / 8760);
		index = 0;
		for (d=0; d<365; d++)
		{
			sum_without_tracker = 0;
			sum_with_tracker = 0;
			for (h=0; h<24; h++)
				for (ts=0; ts<timestep; ts++)
				{
					sum_without_tracker += timeseries_without_tracker[index];
					sum_with_tracker += timeseries_with_tracker[index];
					index++;
				}
			//NOTE: On some cloudy days, daily_tracker_coeff might be positive!! See help for details.
			daily_tracker_coeffs[d] = sum_without_tracker / sum_with_tracker;
		}
		
		//reset the inputs to user specified values
		set('analysis_period', user_analysis_period);
		set('subarray1_track_mode', user_tracking_mode); 
		set('subarray1_azimuth', user_azimuth);
		set('subarray1_tilt', user_tilt);
	}
}


//********************************************************************************************************************************************************************************
// RUN THE BASE CASE REALIZATION- NO SYSTEM FAILURES
//********************************************************************************************************************************************************************************
pb = progressbar( {title='Simulation progress', message='Running base case simulation',cancelbutton=true, time=true, max=system_lifetime_yrs * 365});
//disable the lifetime daily losses
set('en_dc_lifetime_losses', 0);
set('en_ac_lifetime_losses', 0);
//do we need to do something with user-entered O&M costs here??????????
//what about degradation  for the base case simulation??????????????
if (!simulate())
{	
	msgbox('Error: base case simulation failed.');
	exit;
}

//output the results that we care about from the base case simulation before we overwrite them, because we're not saving them like we do for the stochastic realizations
global results = null;
lifetime = get('analysis_period');
results.realization[0] = 'Base';
results.lcoe[0] = get('lcoe_real');
base_annual_energy = get('cf_energy_net');
for (j=1; j<=lifetime; j++) //start at 1 because the array returns year 0, where the energy production is always 0, and goes through the full lifetime (so a 5-year system would have 6 entries in the annual energy output)
	results{'annual_energy_' + j}[0] = base_annual_energy[j];


//need the number of daylight hours for each day of the year in order to calculate availability. pull those from the base case.
sunup = get('sunup');
idx = 0;
daylight_hours = alloc (365); //this does not need to be a global variable because it will only be used in non-mutable context (right side of equations)
annual_daylight_hours = 0;
for(d=0; d<365; d++)
{
	daylight_today = 0;
	for(h=0; h<24; h++)
	{
		if (sunup[idx] == 1) //0 sun is down, 1 sun is up, 2 surnise, 3 sunset. For now we have decided NOT to include sunrise/sunset hours.
		{
			daylight_today++;
			annual_daylight_hours++;
		}
		idx++;
	}
	daylight_hours[d] = daylight_today;
}


//********************************************************************************************************************************************************************************
// RUN THE SYSTEM REALIZATIONS
//********************************************************************************************************************************************************************************
for (i=1; i<=num_realizations; i++)
{
	raw_results[i] = run_system_realization(i, show_realization_graphs); //changing the second parameter will show or hide graphs from each iteration
	outln('Completed realization ' + i); //number the realizations starting at 1
}
progressbar(pb);

//outln(raw_results);


//********************************************************************************************************************************************************************************
// CALCULATE STATISTICS AND WRITE RESULTS
//********************************************************************************************************************************************************************************
//num_module_failure_modes = #raw_results[1].module_failures_by_type; //use the results from the first stochastic realization to figure out how many failure modes there are
//num_inverter_failure_modes = #raw_results[1].inverter_failures_by_type;

//base case results- do we need to overwrite base case failure results with N/A or 0? Currently shows up as null.????????????????????????????????????????

//Calculate statistics
results_columns = @results;
for (c=0; c<#results_columns; c++)
{
	if (results_columns[c] == 'realization')
		continue;
	current_row = num_realizations + 1; //start at the end of the individual realization results for each column
	array = results{results_columns[c]};
	array -@ 0; //get rid of first item because it is the base case scenario
	
	//calculate minimum
	array_min = min(array);
	results.realization[current_row] = 'min';
	results{results_columns[c]}[current_row] = array_min;
	current_row++;
	
	//calculate maximum
	array_max = max(array);
	results.realization[current_row] = 'max';
	results{results_columns[c]}[current_row] = array_max;
	current_row++;
	
	//calculate mean
	array_mean = mean(array);
	results.realization[current_row] = 'mean';
	results{results_columns[c]}[current_row] = array_mean;
	current_row++;
	
	//calculate median
	array_median = median(array);
	results.realization[current_row] = 'median';
	results{results_columns[c]}[current_row] = array_median;
	current_row++;
	
	//calculate standard deviation
	array_std = stddev(array);
	results.realization[current_row] = 'std';
	results{results_columns[c]}[current_row] = array_std;
	current_row++;
	
	//calculate desired PXX
	//first, sort the results smallest to largest
	for (i=0; i<num_realizations-1; i++)
	{
		//start at the current spot in the output
		smallest = i;
		for (j=i+1; j<num_realizations; j++) //find the index of the smallest number in the remaining range
			if (array[j] < array[smallest])
				smallest = j; 
		//swap the spots of the current i and the smallest number
		if (smallest != i)
		{
			array_temp = array[i];
			array[i] = array[smallest];
			array[smallest] = array_temp;	
		}			
	}
	//then, calculate the PXX by linearly interpolating between the point below and point above
	//point x0, y0 is the lower CDF value and corresponding result, respectively
	//point x1, y1 is the next highest CDF value and corresponding result, respectively
	//x is the desired CDF (calculated from the p-value)
	//y is the result corresponding to x
	//P90n = mean - (1.282 * stdDev); normal P90, maybe include later???
	x = 1 - p_value / 100; //calculate the CDF corresponding to the given p-value: ex: a p-value of 90 would have a corresponding CDF of 0.1
	idx0 = floor(x * num_realizations + 0.001) - 1; //subtract 1 from the calculated index because arrays are 0-indexed, the +0.001 is to avoid problems with the representation of double precision numbers
	idx1 = idx0 + 1;
	x0 = (idx0 + 1) * 1 / num_realizations;
	y0 = array[idx0];
	x1 = (idx1 + 1) * 1 / num_realizations;
	y1 = array[idx1];
	array_p = y0 + (x-x0) * (y1-y0) / (x1-x0); //see linear interpolation formula from https://en.wikipedia.org/wiki/Linear_interpolation*/
	results.realization[current_row] = 'P' + p_value;
	results{results_columns[c]}[current_row] = array_p;
	current_row++; //in case we add more calculated variables later
	
}

//write the output file- need to do something a little funky to make the columns show up in the right order
component_order = ['module', 'string', 'combiner', 'inverter', 'disconnect', 'transformer', 'grid'];
if (is_tracking_system) component_order[7] = 'tracker';

component_columns = ['total_failures', 'mtbf', 'availability'];

column_order = ['realization', 'lcoe'];
idx = 2;

//component results
for (c=0; c<#component_order; c++) //cth component
{
	//first list failures for each individual failure mode
	num_failure_modes = #meta{component_order[c]}.failure;
	if (num_failure_modes > 1)
		for (i=0; i<num_failure_modes; i++)
		{
			column_order[idx] = component_order[c] + '_failures_by_type_' + i;
			idx++;
		}
	
	//then list the outputs that are present for each component
	for (i=0; i<#component_columns; i++)
	{
		column_order[idx] = component_order[c] + '_' + component_columns[i];
		idx++;
	}
}

//annual energy results
for (j=1; j<=lifetime; j++)
{
	column_order[idx] = 'annual_energy_' + j;
	idx++;
}

if (#column_order != #results_columns)
	msgbox('Not all results columns have been specified in the column order for the Results Summary CSV. This will result in the Results Summary columns being out of order.');


//Results Summary
if (!csvwrite(results_folder + '/PVRPM_Summary_Results.csv', results, {cols=column_order}))
{
	msgbox('PVRPM Results Summary file is open. Please close the file and then click OK.');
	csvwrite(results_folder + '/PVRPM_Summary_Results.csv', results, {cols=column_order});
}

//DC Timeseries
csv_dc_power = null;
for (i=1; i<=num_realizations; i++)
{
	x = csvread(results_folder + '/dc_' + i + '.csv', {table=true});
	csv_dc_power{'realization_' + i} = x.hourly_dc_power;
	remove_file(results_folder + '/dc_' + i + '.csv');
}
if (!csvwrite(results_folder + '/Timeseries_DC_Power.csv', csv_dc_power))
{
	msgbox('Timeseries DC Power file is open. Please close the file and then click OK.');
	csvwrite(results_folder + '/Timeseries_DC_Power.csv', csv_dc_power);
}

//AC Timeseries
csv_ac_power = null;
for (i=1; i<=num_realizations; i++)
{
	x = csvread(results_folder + '/ac_' + i + '.csv', {table=true});
	csv_ac_power{'realization_' + i} = x.hourly_ac_power;
	remove_file(results_folder + '/ac_' + i + '.csv');
	
}
if (!csvwrite(results_folder + '/Timeseries_AC_Power.csv', csv_ac_power))
{
	msgbox('Timeseries AC Power file is open. Please close the file and then click OK.');
	csvwrite(results_folder + '/Timeseries_AC_Power.csv', csv_ac_power);
}

//Degradation Timeseries
csv_degradation = null;
for (i=1; i<=num_realizations; i++)
{
	x = csvread(results_folder + '/deg_' + i + '.csv', {table=true});
	csv_degradation{'realization_' + i} = x.daily_degradation;
	remove_file(results_folder + '/deg_' + i + '.csv');
}
if (!csvwrite(results_folder + '/Daily_Degradation.csv', csv_degradation))
{
	msgbox('Degradation file is open. Please close the file and then click OK.');
	csvwrite(results_folder + '/Daily_Degradation.csv', csv_degradation);
}











