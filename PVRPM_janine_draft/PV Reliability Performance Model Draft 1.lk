//*************************************************************************************
//PV Reliability Performance Model -- DRAFT --
//Janine Freeman, NREL
//14 September 2016
//*************************************************************************************

//*************************************************************************************
// INPUTS
//*************************************************************************************

// SYSTEM INPUTS-----------------------------------------------------------------------
	num_modules = get('total_modules'); //9408;
	num_modules_per_string = get('modules_per_string'); //14
	num_strings = get('strings_in_parallel'); //672
	num_inverters = get('inverter_count');
	inverter_size = ?(get('inverter_model')) [get('inv_snl_paco'), get('inv_ds_paco'), get('inv_pd_paco')];
	num_combiners = 2;//48; //need to make an input!!
	num_strings_per_combiner = floor(num_strings / num_combiners);
	if (num_strings_per_combiner * num_combiners != num_strings) //making sure that there are an integer number of strings per combiner
	{
		msgbox('Error: there must be an integer number of strings per combiner.');
		exit;
	}
	num_disconnects = num_inverters; //need to make an input!!
	num_transformers = 1; //need to make an input!!
	num_inverters_per_transformer = floor(num_inverters / num_transformers);
	if (num_inverters_per_transformer * num_transformers != num_inverters) //making sure that there are an integer number of inverters per transformer
	{
		msgbox('Error: there must be an integer number of inverters per transformer.');
		exit;
	}
	num_trackers = ceil(num_strings / 2); //need to make an input!!
	system_lifetime_yrs = get('analysis_period');
	has_multiple_subarrays = ( (get('subarray2_enable') == 1) || (get('subarray3_enable') == 1) || (get('subarray4_enable') == 1) );
	is_tracking_system = false;
	if ((get('subarray1_track_mode') == 1 || get('subarray1_track_mode') == 2 || get('subarray1_track_mode') == 3))
		is_tracking_system = true;
	if (get('subarray2_enable') == 1 && (get('subarray2_track_mode') == 1 || get('subarray2_track_mode') == 2 || get('subarray2_track_mode') == 3))
		is_tracking_system = true;
	if (get('subarray3_enable') == 1 && (get('subarray3_track_mode') == 1 || get('subarray3_track_mode') == 2 || get('subarray3_track_mode') == 3))
		is_tracking_system = true;
	if (get('subarray4_enable') == 1 && (get('subarray4_track_mode') == 1 || get('subarray4_track_mode') == 2 || get('subarray4_track_mode') == 3))
		is_tracking_system = true;

// FINANCIAL INPUTS--------------------------------------------------------------------
	present_day_labor_rate = 100; //dollars per hour
	inflation = 3; //%
	
// TRACKER FAILURE INPUT---------------------------------------------------------------
	use_worst_case_tracker = false;

// INPUT FUNCTION: DEGRADATION----------------------------------------------------------
/*
Equation format must follow:
Inputs: 	percent_per_day = degradation rate in percent per DAY
			t = time (in DAYS) since the module was new or replaced
Return: Current degradation factor in fractional form, i.e. if module is 2% degraded, returns 0.98
*/
function current_degradation_rate(percent_per_day, t)
{
	return 1 / pow((1 + percent_per_day / 100), t);
}	

//*************************************************************************************
// DATA CONTAINERS
//*************************************************************************************

// COMPONENT META DATA CONTAINER----------------------------------------------------------
// contains information about a component type in the system
/*
can_fail = true if component is allowed to fail
number = number of that type of component in the system
warranty
	has_warranty = true if the component has a warranty, otherwise false
	days = number of days that the warranty is for (e.g. a 20 year warranty would be 20 * 365 days)
failure[i]
	distribution = distribution type of failure mode i
	parameters = a table of parameters for failure mode i (e.g. [45, 15] )
	times = a vector of failure times for failure mode i
	labor_time = number of hours of labor it takes to repair this type of failure
	cost = parts cost to repair this type of failure
	***OPTIONAL PARAMETER
	***fraction = If fraction is defined, then failure mode i is a defective failure mode, and "fraction" represents the fraction of this type of component that are defective
repair
	can_repair = true if the component is allowed to be repaired
	distribution = distribution type of repair times
	parameters = parameters of the repair distribution
	times = a vector of repair times
degradation (MODULES ONLY)
	can_degrade = true if the component has degradation
	rate = degradation rate (%/day) *converted from percent per year
*/

// INDIVIDUAL COMPONENT DATA CONTAINER-------------------------------------------------------
// contains current timestep data for a single component in the system
/*
state = operational (1) or failed (0)
defective = flag for whether or not this component has a defect.
	If true, then the component is also eligible for the defective failure mode
time_to_failure = number of days left until the component fails
failure_type = index of the type of failure that time_to_failure represents (failure[i] in component meta)
time_to_repair = number of days from onset of failure until component is repaired
time_left_on_warranty = number of days left on warranty for that item, if applicable
cumulative_failures = total number of failures for that component
cumulative_oow_failures = total number of failures out of warranty for that component if applicable
failures_by_type[i] = total number of failures corresponding to failure mode i for that component
defective_failures = total number of failures due to a defective component
MODULES ONLY:
degradation_factor = 1 - percentage the component has degraded at this time (ex. a 2% degraded component would have a degradation factor of 0.98)
*/

// REPAIR COSTS DATA CONTAINER-------------------------------------------------------
// contains all the costs by day
/*
	modules
	strings
	dc combiners
	inverters
	ac disconnects
	transformers
*/

//SET UP DATA CONTAINERS----------------------------------------------------------------------
	// Modules
	global modules = alloc(num_modules);
	global module_meta = null;	
	module_meta.can_fail = true;
	module_meta.number = num_modules;
	module_meta.warranty.has_warranty = true;
	module_meta.warranty.days = 20 * 365; //years converted to days
	//failure mode 1: normal failures
	module_meta.failure[0].distribution = 'normal';
	module_meta.failure[0].parameters = [4 * 365, 1 * 365]; //mean, std, years converted to days
	module_meta.failure[0].times = null;
	module_meta.failure[0].labor_time = 2; //hours
	module_meta.failure[0].cost = 322; //$
	//failure mode 2: defective failures
	module_meta.failure[1].distribution = 'exponential';
	module_meta.failure[1].parameters = [0.5 / 365]; //failures per year converted to days
	module_meta.failure[1].times = null;
	module_meta.failure[1].labor_time = 2; //hours
	module_meta.failure[1].cost = 322; //$
	module_meta.failure[1].fraction = 20 / 100; //% converted to fraction
	module_meta.repair.can_repair = true;
	module_meta.repair.distribution = 'lognormal';
	module_meta.repair.parameters =  [60, 20]; //mean, std, in days
	module_meta.repair.times = null;
	module_meta.degradation.can_degrade = true;
	module_meta.degradation.rate = 5; //%/year
	
	// Strings
	global strings = alloc(num_strings);
	global string_meta = null;
	string_meta.can_fail = true;
	string_meta.number = num_strings;
	string_meta.warranty.has_warranty = false;
	string_meta.failure[0].distribution = 'exponential';
	string_meta.failure[0].parameters = [(2 / 365)]; //failures per year converted to per day
	string_meta.failure[0].times = null;
	string_meta.failure[0].labor_time = 1; //hours
	string_meta.failure[0].cost = 20; //$
	string_meta.repair.can_repair = true;
	string_meta.repair.distribution = 'lognormal';
	string_meta.repair.parameters = [7, 3]; //mean, std, days
	string_meta.repair.times = null;
	string_meta.degradation.can_degrade = false;
	
	// Combiners
	global combiners = alloc(num_combiners);
	global combiner_meta = null;
	combiner_meta.can_fail = true;
	combiner_meta.number = num_combiners;
	combiner_meta.warranty.has_warranty = false;
	combiner_meta.failure[0].distribution = 'normal';
	combiner_meta.failure[0].parameters = [2 * 365, 0.5 * 365]; //mean, std, years converted to days
	combiner_meta.failure[0].times = null;
	combiner_meta.failure[0].labor_time = 2; //hours
	combiner_meta.failure[0].cost = 976; //$
	combiner_meta.repair.can_repair = true;
	combiner_meta.repair.distribution = 'exponential';
	combiner_meta.repair.parameters = [3]; //mean, days
	combiner_meta.repair.times = null;
	combiner_meta.degradation.can_degrade = false;
	
	// Inverters
	global inverters = alloc(num_inverters);
	global inverter_meta = null;
	inverter_meta.can_fail = true;
	inverter_meta.number = num_inverters;
	inverter_meta.warranty.has_warranty = false; 
	//failure mode 1: component failure
	inverter_meta.failure[0].distribution = 'exponential';
	inverter_meta.failure[0].parameters = [1 / 365]; //failures per year converted to per day
	inverter_meta.failure[0].times = null;
	inverter_meta.failure[0].labor_time = 0;
	inverter_meta.failure[0].cost = 0.2 * 0.35 * inverter_size; //0.2 times catastrophic cost, which is 35 cents/Watt
	//failure mode 2: routine failures
	inverter_meta.failure[1].distribution = 'exponential';
	inverter_meta.failure[1].parameters = [1 / 365]; //failures per year converted to per day
	inverter_meta.failure[1].times = null;
	inverter_meta.failure[1].labor_time = 0;
	inverter_routine_cost = 0;
	if (inverter_size <= 10000)
		inverter_routine_cost = 200;
	else if (inverter_size <= 100000)
		inverter_routine_cost = 500;
	else
		inverter_routine_cost = 1000;
	inverter_meta.failure[1].cost = inverter_routine_cost;
	//failure mode 3: catastrophic failure
	inverter_meta.failure[2].distribution = 'normal';
	inverter_meta.failure[2].parameters = [500, 365.25]; //mean, std, in days
	inverter_meta.failure[2].times = null;
	inverter_meta.failure[2].labor_time = 0;
	inverter_meta.failure[2].cost = 0.35 * get('inv_snl_paco'); //35 cents per watt
	//other
	inverter_meta.repair.can_repair = true;
	inverter_meta.repair.distribution = 'lognormal';
	inverter_meta.repair.parameters = [3, 1.5]; //mean, std, in days
	inverter_meta.repair.times = null;
	inverter_meta.degradation.can_degrade = false;
	//IN GOLDSIM, EACH FAILURE MODE CAN HAVE ITS OWN REPAIR TIME. HERE, CONSTRAINED TO BE THE SAME.!!
	
	// AC Disconnects
	global disconnects = alloc(num_disconnects);
	global disconnect_meta = null;
	disconnect_meta.can_fail = true;
	disconnect_meta.number = num_disconnects;
	disconnect_meta.warranty.has_warranty = false;
	disconnect_meta.failure[0].distribution = 'weibull';
	disconnect_meta.failure[0].parameters = [0.3477, 3 * 365]; //slope (same as shape factor)- unitless, mean- years converted to days
	disconnect_meta.failure[0].times = null;
	disconnect_meta.failure[0].labor_time = 4; //hours
	disconnect_meta.failure[0].cost = 500; //$
	disconnect_meta.repair.can_repair = true;
	disconnect_meta.repair.distribution = 'lognormal';
	disconnect_meta.repair.parameters = [1, 0.5]; //mean, std, in years converted to days
	disconnect_meta.repair.times = null;
	disconnect_meta.degradation.can_degrade = false;
	
	// Transformers
	global transformers = alloc(num_transformers);
	global transformer_meta = null;
	transformer_meta.can_fail = true;
	transformer_meta.number = num_transformers;
	transformer_meta.warranty.has_warranty = false;
	transformer_meta.failure[0].distribution = 'weibull';
	transformer_meta.failure[0].parameters = [0.3477, 1 * 365]; //slope (shape factor)- unitless, mean- days
	transformer_meta.failure[0].times = null;
	transformer_meta.failure[0].labor_time = 10; //hours
	transformer_meta.failure[0].cost = 32868; //$
	transformer_meta.repair.can_repair = true;
	transformer_meta.repair.distribution = 'lognormal';
	transformer_meta.repair.parameters = [0.25, 0.5]; //mean, std, in days
	transformer_meta.repair.times = null;
	transformer_meta.degradation.can_degrade = false;
	
	// Grid
	global grid = alloc(1);
	global grid_meta = null;
	grid_meta.can_fail = true;
	grid_meta.number = 1;
	grid_meta.warranty.has_warranty = false;
	grid_meta.failure[0].distribution = 'weibull';
	grid_meta.failure[0].parameters = [0.75, 100]; //slope (shape factor)- unitless, mean- days
	grid_meta.failure[0].times = null;
	grid_meta.failure[0].labor_time = 0;
	grid_meta.failure[0].cost = 0;
	grid_meta.repair.can_repair = true;
	grid_meta.repair.distribution = 'exponential';
	grid_meta.repair.parameters = [0.5]; //mean in days
	grid_meta.repair.times = null;
	grid_meta.degradation.can_degrade = false;
	
	// Trackers
	if(is_tracking_system)
	{
		global trackers = alloc(num_trackers);
		global tracker_meta = null;
		tracker_meta.can_fail = true;
		tracker_meta.number = num_trackers;
		tracker_meta.warranty.has_warranty = false;
		tracker_meta.failure[0].distribution = 'exponential';
		tracker_meta.failure[0].parameters = [0.002]; //mean per year in days
		tracker_meta.failure[0].times = null;
		tracker_meta.failure[0].labor_time = 0;
		tracker_meta.failure[0].cost = 2000; //present day tracker cost, will be inflated
		tracker_meta.repair.can_repair = true;
		tracker_meta.repair.distribution = 'lognormal';
		tracker_meta.repair.parameters = [30, 10]; //mean, std, in days
		tracker_meta.repair.times = null;
		tracker_meta.degradation.can_degrade = false;
	}
	
	// Costs
	global costs = null;


//*************************************************************************************
// SUPPORTING FUNCTIONS
//*************************************************************************************
/* 	LHS performs Latin Hypercube Sampling given a distribution type, distribution parameters,
	and a number of samples. The name parameter allows a more helpful error message.
	Returns an array of the calculated samples.*/
function LHS(name, distribution_type, parameters, num_samples)
{
	/*LHS library included in SAM requires mean and error factor inputs into lognormal function.
	Lognormal-n function requires mean and std of the UNDERLYING normal distribution.
	However, most users will have mean and std of actual distribution. 
	Therefore, must translate from mean and std to mean and error factor.
	See translation equations at https://dakota.sandia.gov/content/latest-reference-manual, Keywords>Variables>lognormal_uncertain */
	if (distribution_type == 'lognormal')
	{
		mu = parameters[0]; //mean
		sigma = parameters[1]; //std
		zeta = sqrt(log(pow(sigma,2) / pow(mu,2) + 1)); //log is the natural log, log10 is the base-10 log function
		e = 2.71828;
		epsilon = pow(e,(1.645*zeta)); //error factor
		parameters[1] = epsilon; //temporarily overwrite the second parameter
	}
	if (num_samples > 20000)
		num_samples = 20000; //LHS can only run so many samples at a time
	lhs = lhs_create();
	lhs_dist(lhs, 'x', distribution_type, parameters);
	if (!lhs_run(lhs, num_samples))
	{
		msgbox('Latin Hypercube Sampling failed for: ' + name + ': ' + lhs_error(lhs));
		exit;
	}
	result = lhs_vector(lhs, 'x');
	lhs_free(lhs);
	if (distribution_type == 'lognormal') 
		parameters[1] = sigma; //set second parameter back to std before exiting the function
	return result;
}

//*************************************************************************************
// COMPONENT FUNCTIONS
//*************************************************************************************

//INITIALIZATION------------------------------------------------------------------------------
// Used to set up a component for the first time or to renew the values when the component is repaired
// Initializes a single component "component_idx" in the "component_vector"
// "Component_meta" stores the failure and repair information for that type of component
// If initializing a component for the first time, "bool_time_is_zero" is true
// If initializing due to a repair, "bool_time_is_zero" is false

function initialize_component(component_meta, component_vector, component_idx, bool_time_is_zero)
{
	// Component state
	component_vector[component_idx].state = 1; //component is operational
	
	// Component failures and repairs
	num_failure_modes = #component_meta.failure;
	
	if (bool_time_is_zero)
	{
		// cumulative failures and OOW failures initialized to zero at time zero only
		component_vector[component_idx].cumulative_failures = 0;
		component_vector[component_idx].cumulative_oow_failures = 0;
		for (i=0; i < num_failure_modes; i++)
			component_vector[component_idx].failures_by_type[i] = 0;
		// degradation
		if (component_meta.degradation.can_degrade)
			component_vector[component_idx].degradation_factor = 1;
		// warranty
		if (component_meta.warranty.has_warranty)
			component_vector[component_idx].time_left_on_warranty = component_meta.warranty.days;
	}
	
	// Loop through all failure modes to determine failure times
	for (j = 0; j < num_failure_modes; j++)
	{
		//check the vector of failure times for this failure mode
		if (component_meta.failure[j].times == null || #component_meta.failure[j].times <= 0) //null on initialization of very first component, less than zero when you've used up the pre-calculated vector
			component_meta.failure[j].times = LHS('failure mode '+to_string(component_meta.failure[j].distribution)+to_string(component_meta.failure[j].parameters), component_meta.failure[j].distribution, 
				component_meta.failure[j].parameters, (#component_vector * 10));
		//check if this failure mode is a defective mode
		if (component_meta.failure[j].fraction != null) //only defective failure modes have a fraction associated with them
			component_vector[component_idx].defective = rand() < component_meta.failure[j].fraction; //randomly assign a given fraction of components to be defective
		//assign a failure time for this failure mode unless it's a defective failure mode and the component is not defective
		if (component_meta.failure[j].fraction == null || component_vector[component_idx].defective)
		{
			possible_failure_times[j] = component_meta.failure[j].times[0]; //assign a failure time
			component_meta.failure[j].times -@ 0; //remove the failure time that was just used
		}
		else
			possible_failure_times[j] = nan(); //the min function won't return a nan
	}
	// Because all failure modes are hard failures (no partial failures), pick whichever failure mode will occur first
	component_vector[component_idx].time_to_failure = min(possible_failure_times);
	component_vector[component_idx].failure_type = possible_failure_times ?@ component_vector[component_idx].time_to_failure;

	// Time to replacement or repair in case of failure
	if (component_meta.repair.times == null || #component_meta.repair.times <= 0) //null on initialization of very first component, less than zero when you've used up the array
		component_meta.repair.times = LHS('repairs'+to_string(component_meta.repair.distribution)+to_string(component_meta.repair.parameters), component_meta.repair.distribution, 
			component_meta.repair.parameters, (#component_vector * 10));
	component_vector[component_idx].time_to_repair = component_meta.repair.times[0];
	component_meta.repair.times -@ 0; //remove the repair time that was just used
	
	// Time left on warranty
	if (component_meta.warranty.has_warranty)
		if (component_vector[component_idx].time_left_on_warranty <= 0) //new warranty on components replaced OOW
			component_vector[component_idx].time_left_on_warranty = component_meta.warranty.days;
	
	// Reset degradation time when a component is replaced
	if (component_meta.degradation.can_degrade)
		component_vector[component_idx].days_of_degradation = 0;
}

//COMPONENT FAILURE----------------------------------------------------------------------------------------
// Used to change a component's state from operational to failed
// Changes "component_idx" in the array "component" state to failed and increments failures
// Checks current "day" against warranty if bool_warranty is true

function component_failure(component_vector, component_idx, day, bool_warranty)
{
	component_vector[component_idx].state = 0;
	component_vector[component_idx].time_to_failure = 0;
	component_vector[component_idx].cumulative_failures++;
	component_vector[component_idx].failures_by_type[component_vector[component_idx].failure_type]++;
	if (bool_warranty)
		if (component_vector[component_idx].time_left_on_warranty <= 0)
			component_vector[component_idx].cumulative_oow_failures++;
}

//*************************************************************************************
// SYSTEM FUNCTIONS
//*************************************************************************************

//SYSTEM INITIALIZATION---------------------------------------------------------------------------------
function initialize()
{
	// Create module structures
	for (m = 0; m < module_meta.number; m++)
		initialize_component(module_meta, modules, m, true);
		
	// Create string structures
	for (s = 0; s < string_meta.number; s++)
		initialize_component(string_meta, strings, s, true);
		
	// Create combiner structures
	for (c = 0; c < combiner_meta.number; c++)
		initialize_component(combiner_meta, combiners, c, true);
		
	// Create inverter structures
	for (i = 0; i < inverter_meta.number; i++)
		initialize_component(inverter_meta, inverters, i, true);
	
	// Create AC disconnect structures
	for (d = 0; d < disconnect_meta.number; d++)
		initialize_component(disconnect_meta, disconnects, d, true);
	
	// Create transformer structures
	for (t = 0; t < transformer_meta.number; t++)
		initialize_component(transformer_meta, transformers, t, true);
	
	// Create grid structure
	initialize_component(grid_meta, grid, 0, true);
	
	// Create tracker structures
	if (is_tracking_system)
	{
		for (tr = 0; tr < tracker_meta.number; tr++)
			initialize_component(tracker_meta, trackers, tr, true);
	}
}

// DC POWER AVAILABILITY CALCULATION FUNCTION------------------------------------------------------------------------
function whats_my_dc_availability() 
{
	//note that here, "operational modules" means modules whose power is REACHING the inverter, 
	//regardless of whether the module itself is failed or not
	operational_modules = 0;
	
	for (c=0; c < combiner_meta.number; c++)
	{
		if (combiners[c].state == 0)
			continue; //if the combiner out, none of the modules on that combiner reach the inverter
		for (s=0; s < num_strings_per_combiner; s++)
		{
			if (strings[s].state == 0)
				continue; //if string is out, none of the modules on that combiner reach the inverter
			for (m=0; m < num_modules_per_string; m++)
			{
				// what module index are we at? 
				/* 
				number of combiners we've already looped through * total number modules per combiner +
				number of strings on this combiner we've already looped through * modules per string +
				number of modules that we've passed on this string
				*/
				// because c, s, and m are 0-indexed, they represent how many of each component have been completed by this point
				module_index = c * (num_strings_per_combiner * num_modules_per_string) + s * num_modules_per_string + m;
				if (module_index > #modules - 1)
				{
					msgbox('Error, calculated module index > number of modules in the dc availability function');
					exit;
				}
				operational_modules += modules[module_index].state; //1 if operating, 0 if failed
			}
		}
	}
		
	return operational_modules / module_meta.number;
}

// AC POWER AVAILABILITY CALCULATION FUNCTION--------------------------------------------------------------------------
function whats_my_ac_availability()
{
	//grid is down
	if (grid[0].state == 0)
		return 0;
	
	operational_inverters = 0;
	for (t=0; t < transformer_meta.number; t++)
	{
		if (transformers[t].state == 0) 
			continue; //if the transformer is down, none of those inverters can reach grid
		for (i=0; i < num_inverters_per_transformer; i++)
		{
			// because t and i are 0-indexed, they represent how many of each component have been completed by this point
			inverter_index = t * num_inverters_per_transformer + i;
			if (inverter_index > #inverters - 1)
			{
				msgbox('Error, calculated inverter index > number of inverters in the ac availability function');
				exit;
			}
			operational_inverters += (inverters[inverter_index].state && disconnects[inverter_index].state ); //1 if both are operating, 0 if either or both is failed
		}
	}
	return operational_inverters / inverter_meta.number;
}

// FLEETWIDE DEGRADATION CALCULATION------------------------------------------------------------------------
//Degradation is only averaged for operational modules. 
//Otherwise, the power production hit from degradation and from the module failure would be unfairly double-counted in production estimates.
function whats_my_degradation()
{
	fleet_degradation_sum = 0;
	number_of_operational_modules = 0;
	for (m=0; m < module_meta.number; m++)
	{
		if (modules[m].state == 1)
		{ 
			fleet_degradation_sum += modules[m].degradation_factor;
			number_of_operational_modules++;
		}
	}
	return fleet_degradation_sum / number_of_operational_modules;
}

// TRACKER LOSS FACTOR CALCULATION-------------------------------------------------------------------------------
//Input is the day number in the system lifetime
//Returns a factor (0-1) reflecting the percentage of power lost due to malfunctioning trackers
function whats_my_tracker_power_loss_factor(day)
{
	// total number of working trackers
	num_trackers_operational = 0;
	for (tr=0; tr < tracker_meta.number; tr++)
		if (trackers[tr].state == 1)
			num_trackers_operational++;
	fraction_operational = num_trackers_operational / tracker_meta.number;
	tracker_availability[day] = fraction_operational;
	day_of_year = mod(day, 365); //0-indexed, but so are the daily_tracker_coeffs
	if (tracker_meta.can_fail)
	{
		full_factor = daily_tracker_coeffs[day_of_year];
		adjusted_factor = full_factor + fraction_operational* (1 - full_factor);
	}
	else
		adjusted_factor = 1;
	return adjusted_factor;
}

// INCREMENT TIMESTEP FUNCTION------------------------------------------------------------------------------
//increments all components in component_vector of type component_meta on a given day
//returns the value of component_repair_costs, which is how much repairs for this component cost on this day
function step_in_time(component_meta, component_vector, day, component_repair_costs)
{
	//initialize repair costs
	component_repair_costs[day] = 0;
	
	//loop through number of components
	for (i=0; i < component_meta.number; i++)
	{
		//component is operational
		if (component_vector[i].state == 1)
		{
			component_vector[i].time_to_failure--;
			//component has just failed and failure is allowed for this type of component
			if (component_vector[i].time_to_failure <= 0 && component_meta.can_fail == true)
				component_failure(component_vector, i, day, component_meta.warranty.has_warranty);
		}
		
		//component is currently failed
		else
		{
			component_vector[i].time_to_repair--;
			//component is repaired
			if (component_vector[i].time_to_repair <= 0 && component_meta.repair.can_repair) //only repair the item if repairs are enabled
			{
				//add the cost to repair the component
				failure_index = component_vector[i].failure_type; 
				component_repair_cost = component_meta.failure[failure_index].cost + labor_rate * component_meta.failure[failure_index].labor_time;
				if (component_meta.warranty.has_warranty)
				{
					if(component_vector[i].time_left_on_warranty <= 0) //only add repair costs if not replaced under warranty
						component_repair_costs[day] += component_repair_cost;
				}
				else
					component_repair_costs[day] += component_repair_cost;
				//initialize a new module without resetting cumulative failures
				initialize_component(component_meta, component_vector, i, false); 			
			}
		}
		
		//degradation
		if (component_meta.degradation.can_degrade)
		{
			component_vector[i].degradation_factor = current_degradation_rate(component_meta.degradation.rate / 365, component_vector[i].days_of_degradation);
			component_vector[i].days_of_degradation++;
		}
		
		//warranty
		if (component_meta.warranty.has_warranty)
			component_vector[i].time_left_on_warranty--;
	}
}


//**********************************************************************************************************************************************************************
// MAIN SCRIPT
//**********************************************************************************************************************************************************************
	
// CHECK THE ACTIVE CASE----------------------------------------------------------------------------
/*
if ( typeof(macro) == 'unknown' ) {
	msgbox('This script must be run as a macro from within a case.');
	exit;
}*/

cfg = configuration();
fin = cfg[1];
tech = cfg[0];
// Technology must be detailed PV model
if (tech != 'Flat Plate PV')
{
	msgbox('Error: This script is only applicable to the detailed photovoltaic model. Exiting simulation.');
	exit;
}
// Third party, LCOE calculator, and None don't have lifetime mode
if (fin == 'Third Party' || fin == 'LCOE Calculator' || fin == 'None')
{
	msgbox('Error: This script cannot be run from financial model: ' + fin + '. Exiting simulation.');
	exit;
}
// Must be run in lifetime mode
is_lifetime_mode = get('pv_lifetime_simulation');
if (!is_lifetime_mode)
{
	make_lifetime_mode = yesno('PV simulations must be run in lifetime mode with this script. Change your case to lifetime mode now?');
	if (!make_lifetime_mode)
	{
		msgbox('Error: Please modify your case to use lifetime mode. Exiting simulation');
		exit;
	}
	set('pv_lifetime_simulation', 1);
}
// Lifetime daily DC and AC loss structures must be empty to run.
//NEED TO DISABLE THIS IN A SCRIPT THAT LOOPS OVER MANY RUNS!!
/*
if (get('en_dc_lifetime_losses') || get('en_ac_lifetime_losses'))
{
	proceed = yesno('This script will overwrite any user-entered lifetime daily losses, and they will be lost. Proceed?');
	if (!proceed)
	{
		msgbox('Please modify the case not to use user-entered lifetime daily losses. Exiting simulation.');
		exit;
	}
}*/
// Multiple subarrays can't have tracker failures
if (has_multiple_subarrays && is_tracking_system && tracker_meta.can_fail)
{
	msgbox('Error: Tracker failures may only be modeled for a system consisting of a single subarray. Exiting simulation.');
	exit;
}
//Tracking systems can't be 2-axis or azimuth-axis
if (is_tracking_system)
{
	//only need to check subarray 1, since at this point tracking systems with multiple subarrays will have been terminated.
	if (get('subarray1_track_mode') == 2 || get('subarray1_track_mode') == 3)
	{
		msgbox('Error: This script is not configured to run with 2-axis tracking or azimuth-axis tracking systems. Exiting simulation.');
		exit;
	}
}

// Allocate outputs----------------------------------------------------------------------------------
//costs
costs.module = alloc(system_lifetime_yrs * 365);
costs.string = alloc(system_lifetime_yrs * 365);
costs.combiner = alloc(system_lifetime_yrs * 365);
costs.inverter = alloc(system_lifetime_yrs * 365);
costs.disconnect = alloc(system_lifetime_yrs * 365);
costs.transformer = alloc(system_lifetime_yrs * 365);
costs.grid = alloc(system_lifetime_yrs * 365);
if (is_tracking_system)
	costs.tracker = alloc(system_lifetime_yrs * 365);
//time variables
module_degradation_factor = null;
if (is_tracking_system)
{
	tracker_power_loss_factor = null;
	daily_tracker_coeffs = alloc(365);
	global tracker_availability = null;
}
dc_power_availability = ac_power_availability = null;
labor_rate = 0;

//precalculate tracking loss factors for tracking systems--------------------------------------------------------
if (is_tracking_system && tracker_meta.can_fail)
{
	if (get('subarray1_tilt') != 0)
	{
		msgbox('This script can only model tracker failures for 0 degree tilt trackers. Exiting simulation.');
		exit;
	}
	
	// calculate hourly performance with tracker for one year
	user_analysis_period = get('analysis_period');
	set('analysis_period', 1);
	set('en_ac_lifetime_losses', 0);
	set('en_dc_lifetime_losses', 0);
	if (!simulate('', 0))
	{
		msgbox('Error simulating first-year tracker performance');
		set('analysis_period', user_analysis_period);
		exit;
	}
	timeseries_with_tracker = get('dc_net');
	
	// calculate hourly performance without trackers for one year
	user_tracking_mode = get('subarray1_track_mode');
	user_azimuth = get('subarray1_azimuth');
	user_tilt = get('subarray1_tilt');
	set('subarray1_track_mode', 0); //set to fixed tilt
	if (user_azimuth > 360 || user_azimuth < 0)
	{
		msgbox('Azimuth must be between 0 and 360. Please adjust the azimuth and try again.');
		exit;
	}
	//assume worst case tracker gets stuck to north. If axis is north-south, assume gets stuck to west.
	if (use_worst_case_tracker)
	{
		worst_case_az = user_azimuth;
		if (user_azimuth < 180)
			worst_case_az -= 90;
		else
			worst_case_az += 90;
		if (worst_case_az < 0)
			worst_case_az += 360;
		if (worst_case_az >= 360)
			worst_case_az -=360;
		set('subarray1_azimuth', worst_case_az);
		set('subarray1_tilt', get('subarray1_rotlim'));
	}
	//assume average case is that tracker gets stuck flat
	else
		set('subarray1_tilt', 0); //doesn't matter what az is if it's flat
	if (!simulate('', 0))
	{
		msgbox('Error simulating first-year tracker failure performance');
		set('analysis_period', user_analysis_period);
		set('subarray1_track_mode', user_tracking_mode); 
		set('subarray1_azimuth', user_azimuth);
		set('subarray1_tilt', user_tilt);
		exit;
	}
	timeseries_without_tracker = get('dc_net');
	
	//calculate daily loss statistics
	timestep = (#timeseries_with_tracker / 8760);
	index = 0;
	for (d=0; d<365; d++)
	{
		sum_without_tracker = 0;
		sum_with_tracker = 0;
		for (h=0; h<24; h++)
			for (ts=0; ts<timestep; ts++)
			{
				sum_without_tracker += timeseries_without_tracker[index];
				sum_with_tracker += timeseries_with_tracker[index];
				index++;
			}
		//NOTE: On some cloudy days, daily_tracker_coeff might be positive!! See help for details.
		daily_tracker_coeffs[d] = sum_without_tracker / sum_with_tracker;
	}
	
	//reset the inputs to user specified values
	set('analysis_period', user_analysis_period);
	set('subarray1_track_mode', user_tracking_mode); 
	set('subarray1_azimuth', user_azimuth);
	set('subarray1_tilt', user_tilt);
}

//timestep 0
pb = progressbar( {title='Simulation progress', message='Initializing system',cancelbutton=true, time=true, max=system_lifetime_yrs * 365});
initialize();
module_degradation_factor[0] = whats_my_degradation();
dc_power_availability[0] = whats_my_dc_availability();
ac_power_availability[0] = whats_my_ac_availability();
costs.module[0] = costs.string[0] = costs.combiner[0] = 0; //no costs are accrued at time zero because nothing has changed state
costs.inverter[0] = costs.disconnect[0] = costs.transformer[0] = 0;
costs.grid[0] = 0;
if (is_tracking_system)
{
	costs.tracker[0] = 0;
	tracker_power_loss_factor[0] = 1;
	tracker_availability[0] = 1;
}
//outln('0\t' + modules);


//rest of system lifetime

for (day = 1; day < system_lifetime_yrs * 365; day++)
{	
	was_canceled = progressbar(pb, {value=day, message='Running reliability model...'});
	if (was_canceled)
	{
		outln('Simulation canceled by user.');
		progressbar(pb);
		exit;
	}
	//increase the labor rate each year
	if (day == 1 || mod(day, 365) == 0) //need to set the labor rate initially and then again at the beginning of every year
	{
		year = floor(day / 365);
		labor_rate = present_day_labor_rate * pow((1 + inflation / 100), year);
		if (is_tracking_system)
			tracker_meta.failure[0].cost *= pow((1 + inflation / 100), year);
	}
	//step each component through time
	step_in_time(module_meta, modules, day, costs.module);
	step_in_time(string_meta, strings, day, costs.string);
	step_in_time(combiner_meta, combiners, day, costs.combiner);
	step_in_time(inverter_meta, inverters, day, costs.inverter);
	step_in_time(disconnect_meta, disconnects, day, costs.disconnect);
	step_in_time(transformer_meta, transformers, day, costs.transformer);
	step_in_time(grid_meta, grid, day, costs.grid);
	if (is_tracking_system)
		step_in_time(tracker_meta, trackers, day, costs.tracker);
	//count up current timestep states
	if (is_tracking_system)
		tracker_power_loss_factor[day] = whats_my_tracker_power_loss_factor(day);
	module_degradation_factor[day] = whats_my_degradation();
	dc_power_availability[day] = whats_my_dc_availability();
	ac_power_availability[day] = whats_my_ac_availability();
	//outln(day + '\t' + modules);
}
progressbar(pb, {message='Running SAM simulation...'});	
	
//create SAM performance adjustment tables for the availability, degradation, and tracker loss factors
time = alloc(8760 * system_lifetime_yrs);
daily_dc_loss = alloc(365 * system_lifetime_yrs);
daily_ac_loss = alloc(365 * system_lifetime_yrs);
idx = 0;
day_num = alloc(365 * system_lifetime_yrs);
for (day = 0; day < (365 * system_lifetime_yrs); day++)
{
	day_num[day] = day;
	daily_dc_loss[day] = 100 * (1 - (dc_power_availability[day] * module_degradation_factor[day] * ?(is_tracking_system)[1, tracker_power_loss_factor[day]]));
	daily_ac_loss[day] = 100 * (1 - ac_power_availability[day]);
	for (j = 0; j < 24; j++)
	{
		time[idx] = idx;
		idx++;
	}
}

//DC adjustment factors
set('en_dc_lifetime_losses', 1);
set('dc_lifetime_losses', daily_dc_loss);
//AC adjustment factors
set('en_ac_lifetime_losses', 1);
set('ac_lifetime_losses', daily_ac_loss);
//Degradation is included as part of the DC losses, so set it to zero and create a note in the UI
set('dc_degradation', [0]);
//show_page('Lifetime PV');
//pagenote('Degradation is included in the lifetime daily DC losses, so the degradation input has been set to zero.');


//Create O&M inputs based on costs
o_m_yearly_costs = alloc(system_lifetime_yrs);
yr_idx = 0;
cost_components = @costs;
for (day = 0; day < system_lifetime_yrs * 365; day++)
{
	if (mod(day, 365) == 0) //we've reached the beginning of a new year
	{
		yr_idx = day / 365;
		o_m_yearly_costs[yr_idx] = 0;
	}
	for (c=0; c<#cost_components; c++)
		o_m_yearly_costs[yr_idx] += costs{cost_components[c]}[day];
}
set('om_fixed', o_m_yearly_costs);


//run PV performance model- for now running the currently active case
messages = '';
success = simulate(messages, true);
if (!success)
{
	msgbox('Simulation failed.' + messages);
	exit;
}
show_page('Results');


//OUTPUTS-------------------------------------------------------------------------------------------------------------

//failures
total_module_failures = total_string_failures = total_combiner_failures = 0;
total_inverter_failures = total_disconnect_failures = total_transformer_failures = 0;
total_grid_failures = 0;
total_tracker_failures = 0;
//count up cumulative failures
for (j=0; j<#module_meta.failure; j++)
	module_failures_by_type[j] = 0;
for (m=0; m < module_meta.number; m++)
{
	total_module_failures += modules[m].cumulative_failures;
	for (j=0; j<#module_meta.failure; j++)
		module_failures_by_type[j] += modules[m].failures_by_type[j];
}
for (s=0; s < string_meta.number; s++)
	total_string_failures += strings[s].cumulative_failures;
for (c=0; c < combiner_meta.number; c++)
	total_combiner_failures += combiners[c].cumulative_failures;
inverter_failures_by_type = alloc(#inverter_meta.failure);
for (j=0; j<#inverter_meta.failure; j++)
	inverter_failures_by_type[j] = 0;
for (i=0; i < inverter_meta.number; i++)
{
	total_inverter_failures += inverters[i].cumulative_failures;
	for (j=0; j<#inverter_meta.failure; j++)
		inverter_failures_by_type[j] += inverters[i].failures_by_type[j];
}
for (d=0; d < disconnect_meta.number; d++)
	total_disconnect_failures += disconnects[d].cumulative_failures;
for (t=0; t < transformer_meta.number; t++)
	total_transformer_failures += transformers[t].cumulative_failures;
total_grid_failures = grid[0].cumulative_failures;
if (is_tracking_system)
{
	for (tr=0; tr < tracker_meta.number; tr++)
		total_tracker_failures += trackers[tr].cumulative_failures;
}

progressbar(pb);

//outln(dc_power_availability);
outln('Total module failures =' + total_module_failures);
outln('Total module failures by type =' + module_failures_by_type);
outln('Total string failures =' + total_string_failures);
outln('Total combiner failures =' + total_combiner_failures);
outln('Total inverter failures =' + total_inverter_failures);
outln('Inverter failures by type =' + inverter_failures_by_type);
outln('Total disconnect failures =' + total_disconnect_failures);
outln('Total transformer failures =' + total_transformer_failures);
outln('Total grid failures =' + total_grid_failures);
if (is_tracking_system)
	outln('Total tracker failures =' + total_tracker_failures);

//daily performance
if (is_tracking_system)
	dview(5, 24, 'Daily factors', 'DC Power Availability', '', 1.0, dc_power_availability, 'AC Power Availability', '', 1.0, ac_power_availability, 'Module degradation factor', '', 1.0, module_degradation_factor, 'Power Availability Due to Tracker Outages', '', 1.0, tracker_power_loss_factor, 'Tracker Availability', '', 1.0, tracker_availability);
else
	dview(3, 24, 'Daily factors', 'DC Power Availability', '', 1.0, dc_power_availability, 'AC Power Availability', '', 1.0, ac_power_availability, 'Module degradation factor', '', 1.0, module_degradation_factor);

//lifetime power output
hourly_dc_power = get('dc_net');
hourly_ac_power = get('gen');
dview(2, 1, 'Lifetime System Power', 'DC Power', 'kW', 1.0, hourly_dc_power, 'AC Power', 'kW', 1.0, hourly_ac_power);

// TO DO-----------------------------------------------------------------------------------
/*
	NEED TO CREATE A MEGA-SCRIPT TO RUN MULTIPLE SIMULATIONS!! AND CREATE GRAPHS!!
	DC and AC lifetime losses need to be added to loss tree
	Add what the acceptable input ranges are for LHS when errors are encountered? It basically does this already...
	Add component-level availability output graph vs time (using Geoff's equation)
	WHEN AN INVERTER FAILS ROUTINELY, IT NEEDS TO NOT BE COMPLETELY RESET- which ones do reset it?
	Basic failure rates as an output (failures per million hours)
	Make macro UI inputs
	Which inputs are ones people should change, and which will the code set automatically (example tracking)
	O&M costs- set to add to what is in the case
	details in the documentation- what comes from SAM, what goes to SAM
	add an O&M check if the inputs are there
	create outputs of the RPM script- calculated O&M costs that get set 
	LCOE calculator clarification comment- all the other models calculate LCOE as well
	in documentation- if you want to model microinverters, here's how you would set it up
*/