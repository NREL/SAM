//*************************************************************************************
//Module Reliability Model -- DRAFT --
//jmf 8/31/16
//*************************************************************************************

// TO DO-----------------------------------------------------------------------------------
/*
	NEED TO CREATE A MEGA-SCRIPT TO RUN MULTIPLE SIMULATIONS!! AND CREATE GRAPHS!!
	DC derate needs to be added to loss tree
	inverter warranty resets when inverter is replaced
	Add what the acceptable input ranges are for LHS when errors are encountered?
	Add "calculating"/"running" popup
	Add component-level availability output graph vs time (using Geoff's equation)
	Output time series module availability, degradation, etc. to a csv.
	Add check that case must be in lifetime mode
	WARRANTY REPAIRS NEED TO NOT COST ANYTHING
	WHEN AN INVERTER FAILS ROUTINELY, IT NEEDS TO NOT BE COMPLETELY RESET- which ones do reset it?
	I don't like how I'm doing repair cost additions right now. Maybe change it to something else?
	How do trackers work with multiple subarrays? For now only enabled for subarray 1
	Need to escalate tracker costs
	MAKE DEFECTIVE FAILURES A REGULAR FAILURE TYPE
*/


// CHECK THE ACTIVE CASE----------------------------------------------------------------------------
/*
if ( typeof(macro) == 'unknown' ) {
	msgbox('This script must be run as a macro from within a case.');
	exit;
}

cfg = configuration();
fin = cfg[1];
tech = cfg[0];

if (tech != 'Flat Plate PV')
{
	msgbox('Error: This script is only applicable to the detailed photovoltaic model.');
	exit;
}

if (fin == 'Third Party' || fin == 'LCOE Calculator' || fin == 'None')
{
	msgbox('Error: This script cannot be run from financial model: ' + fin);
	exit;
}
*/


//*************************************************************************************
// INPUTS
//*************************************************************************************

// SYSTEM INPUTS-----------------------------------------------------------------------
	num_modules = get('total_modules'); //9408;
	num_modules_per_string = get('modules_per_string'); //14
	num_strings = get('strings_in_parallel'); //672
	num_inverters = get('inverter_count');
	inverter_size = ?(get('inverter_model')) [get('inv_snl_paco'), get('inv_ds_paco'), get('inv_pd_paco')];
	num_combiners = 2;//48; //num_inverters * 2; //48 //NEED TO UPDATE THIS ASSUMPTION- MAKE IT AN INPUT AND ERROR CHECK IT!!!
	num_strings_per_combiner = num_strings / num_combiners; //THIS IS NOT NECESSARILY AN INTEGER, NEED TO ERROR CHECK THIS!!!!!!!!!!!!!!!!
	num_disconnects = num_inverters;
	num_transformers = 1; //2;
	num_inverters_per_transformer = num_inverters / num_transformers; //CHECK THAT THIS IS AN INTEGER!!
	num_trackers = ceil(num_strings / 3); //HOW TO FIGURE THIS ONE OUT?!!
	is_tracking_system = ( (get('subarray1_track_mode') == 1) || (get('subarray1_track_mode') == 2) || (get('subarray1_track_mode') == 3) );
	system_lifetime_yrs = get('analysis_period');

// FINANCIAL INPUTS--------------------------------------------------------------------
	present_day_labor_rate = 100; //dollars per hour
	inflation = 3; //%
	
// INPUT FUNCTION: DEGRADATION----------------------------------------------------------
/*
Equation format must follow:
Inputs: 	percent_per_day = degradation rate in percent per DAY
			t = time (in DAYS) since the module was new or replaced
Return: Current degradation factor in fractional form, i.e. if module is 2% degraded, returns 0.98
*/
function current_degradation_rate(percent_per_day, t)
{
	return 1 / pow((1 + percent_per_day / 100), t);
}	

//*************************************************************************************
// DATA CONTAINERS
//*************************************************************************************

// COMPONENT META DATA CONTAINER----------------------------------------------------------
// contains information about a component type in the system
/*
can_fail = true if component is allowed to fail
number = number of that type of component in the system
warranty
	has_warranty = true if the component has a warranty, otherwise false
	days = number of days that the warranty is for (e.g. a 20 year warranty would be 20 * 365 days)
failure[i]
	distribution = distribution type of failure mode i
	parameters = a table of parameters for failure mode i (e.g. [45, 15] )
	times = a vector of failure times for failure mode i
	labor_time = number of hours of labor it takes to repair this type of failure
	cost = parts cost to repair this type of failure
defective
	has_defective_failures = true if the component also has defective failures, otherwise false
	fraction = fraction of that type of component that are defective
	distribution = distribution of defective failure mode
	parameters = parameters of defective failure mode
	times = a vector of defective failure times
repair
	can_repair = true if the component is allowed to be repaired
	distribution = distribution type of repair times
	parameters = parameters of the repair distribution
	times = a vector of repair times
degradation (MODULES ONLY)
	can_degrade = true if the component has degradation
	rate = degradation rate (%/day) *converted from percent per year
*/

// INDIVIDUAL COMPONENT DATA CONTAINER-------------------------------------------------------
// contains current timestep data for a single component in the system
/*
state = operational (1) or failed (0)
defective = flag for whether or not this component has a defect.
	If true, then the component is also eligible for the defective failure mode
time_to_failure = number of days left until the component fails
failure_type = index of the type of failure that time_to_failure represents (failure[i] in component meta)
time_to_repair = number of days from onset of failure until component is repaired
cumulative_failures = total number of failures for that component
cumulative_oow_failures = total number of failures out of warranty for that component if applicable
failures_by_type[i] = total number of failures corresponding to failure mode i for that component
defective_failures = total number of failures due to a defective component
MODULES ONLY:
degradation_factor = 1 - percentage the component has degraded at this time (ex. a 2% degraded component would have a degradation factor of 0.98)
*/

// REPAIR COSTS DATA CONTAINER-------------------------------------------------------
// contains all the costs by component and day
/*
modules
strings
dc combiners
inverters
ac disconnects
transformers
*/

//SET UP DATA CONTAINERS----------------------------------------------------------------------
	// Modules
	global modules = alloc(num_modules);
	global module_meta = null;	
	module_meta.can_fail = true;
	module_meta.number = num_modules;
	module_meta.warranty.has_warranty = true;
	module_meta.warranty.days = 20 * 365; //years converted to days
	module_meta.failure[0].distribution = 'normal';
	module_meta.failure[0].parameters = [35 * 365, 8 * 365]; //mean, std, years converted to days
	module_meta.failure[0].times = null;
	module_meta.failure[0].labor_time = 2; //hours
	module_meta.failure[0].cost = 322; //$
	module_meta.defective.has_defective_failures = true;
	module_meta.defective.fraction = 20 / 100;
	module_meta.defective.distribution = 'exponential';
	module_meta.defective.parameters = [0.5 / 365]; //failures per year converted to days
	module_meta.defective.times = null;
	module_meta.repair.can_repair = true;
	module_meta.repair.distribution = 'lognormal';
	module_meta.repair.parameters =  [45, 15]; //mean, std, in days
	module_meta.repair.times = null;
	module_meta.degradation.can_degrade = true;
	module_meta.degradation.rate = 1; //%/year
	
	// Strings
	global strings = alloc(num_strings);
	global string_meta = null;
	string_meta.can_fail = true;
	string_meta.number = num_strings;
	string_meta.warranty.has_warranty = false;
	string_meta.failure[0].distribution = 'exponential';
	string_meta.failure[0].parameters = [(0.1 / 365)]; //failures per year converted to per day
	string_meta.failure[0].times = null;
	string_meta.failure[0].labor_time = 1; //hours
	string_meta.failure[0].cost = 20; //$
	string_meta.defective.has_defective_failures = false;
	string_meta.repair.can_repair = true;
	string_meta.repair.distribution = 'normal';
	string_meta.repair.parameters = [10, 5]; //mean, std, in days
	string_meta.repair.times = null;
	string_meta.degradation.can_degrade = false;
	
	// Combiners
	global combiners = alloc(num_combiners);
	global combiner_meta = null;
	combiner_meta.can_fail = true;
	combiner_meta.number = num_combiners;
	combiner_meta.warranty.has_warranty = false;
	combiner_meta.failure[0].distribution = 'lognormal';
	combiner_meta.failure[0].parameters = [153.3, 14.235]; //mean, std, in days
	combiner_meta.failure[0].times = null;
	combiner_meta.failure[0].labor_time = 2; //hours
	combiner_meta.failure[0].cost = 976; //$
	combiner_meta.defective.has_defective_failures = false;
	combiner_meta.repair.can_repair = true;
	combiner_meta.repair.distribution = 'exponential';
	combiner_meta.repair.parameters = [5]; //mean, in days
	combiner_meta.repair.times = null;
	combiner_meta.degradation.can_degrade = false;
	
	// Inverters
	global inverters = alloc(num_inverters);
	global inverter_meta = null;
	inverter_meta.can_fail = true;
	inverter_meta.number = num_inverters;
	inverter_meta.warranty.has_warranty = false; //THIS IS ALMOST DEFINITELY GOING TO BE TRUE WHEN WE MODIFY THE INPUTS, BUT NOTHING IN PSEUDOCODE
	//failure mode 1: component failure
	inverter_meta.failure[0].distribution = 'exponential';
	inverter_meta.failure[0].parameters = [0.2 / 365]; //failures per year converted to per day
	inverter_meta.failure[0].times = null;
	inverter_meta.failure[0].labor_time = 0;
	inverter_meta.failure[0].cost = 0.2 * 0.35 * inverter_size; //0.2 times catastrophic cost, which is 35 cents/Watt
	//failure mode 2: routine failures
	inverter_meta.failure[1].distribution = 'exponential';
	inverter_meta.failure[1].parameters = [1 / 365]; //failures per year converted to per day
	inverter_meta.failure[1].times = null;
	inverter_meta.failure[1].labor_time = 0;
	inverter_routine_cost = 0;
	if (inverter_size <= 10000)
		inverter_routine_cost = 200;
	else if (inverter_size <= 100000)
		inverter_routine_cost = 500;
	else
		inverter_routine_cost = 1000;
	inverter_meta.failure[1].cost = inverter_routine_cost;
	//failure mode 3: catastrophic failure
	inverter_meta.failure[2].distribution = 'normal';
	inverter_meta.failure[2].parameters = [10 * 365, 1 * 365]; //mean, std, in years converted to days
	inverter_meta.failure[2].times = null;
	inverter_meta.failure[2].labor_time = 0;
	inverter_meta.failure[2].cost = 0.35 * get('inv_snl_paco'); //35 cents per watt
	//other
	inverter_meta.defective.has_defective_failures = false;
	inverter_meta.repair.can_repair = true;
	inverter_meta.repair.distribution = 'lognormal';
	inverter_meta.repair.parameters = [3, 1.5]; //mean, std, in days
	inverter_meta.repair.times = null;
	inverter_meta.degradation.can_degrade = false;
	//IN GOLDSIM, EACH FAILURE MODE CAN HAVE ITS OWN REPAIR TIME. HERE, CONSTRAINED TO BE THE SAME.!!
	
	// AC Disconnects
	global disconnects = alloc(num_disconnects);
	global disconnect_meta = null;
	disconnect_meta.can_fail = true;
	disconnect_meta.number = num_disconnects;
	disconnect_meta.warranty.has_warranty = false;
	disconnect_meta.failure[0].distribution = 'weibull';
	disconnect_meta.failure[0].parameters = [0.3477, 2.82 * 365]; //slope (same as shape factor)- unitless, mean- years converted to days
	disconnect_meta.failure[0].times = null;
	disconnect_meta.failure[0].labor_time = 4; //hours
	disconnect_meta.failure[0].cost = 500; //$
	disconnect_meta.defective.has_defective_failures = false;
	disconnect_meta.repair.can_repair = true;
	disconnect_meta.repair.distribution = 'lognormal';
	disconnect_meta.repair.parameters = [1.75, 1.62]; //mean, std, in days
	disconnect_meta.repair.times = null;
	disconnect_meta.degradation.can_degrade = false;
	
	// Transformers
	global transformers = alloc(num_transformers);
	global transformer_meta = null;
	transformer_meta.can_fail = true;
	transformer_meta.number = num_transformers;
	transformer_meta.warranty.has_warranty = false;
	transformer_meta.failure[0].distribution = 'weibull';
	transformer_meta.failure[0].parameters = [0.3477, 0.845 * 365]; //slope (shape factor)- unitless, mean- yrs converted to days
	transformer_meta.failure[0].times = null;
	transformer_meta.failure[0].labor_time = 10; //hours
	transformer_meta.failure[0].cost = 32868; //$
	transformer_meta.defective.has_defective_failures = false;
	transformer_meta.repair.can_repair = true;
	transformer_meta.repair.distribution = 'lognormal-n';
	transformer_meta.repair.parameters = [0.22, 0.25]; //mean, std, in days
	transformer_meta.repair.times = null;
	transformer_meta.degradation.can_degrade = false;
	
	// Grid
	global grid = 1;
	global grid_meta = null;
	grid_meta.can_fail = true;
	grid_meta.number = 1;
	grid_meta.warranty.has_warranty = false;
	grid_meta.failure[0].distribution = 'weibull';
	grid_meta.failure[0].parameters = [0.75, 0.42 * 365]; //slope (shape factor)- unitless, mean- years converted to days
	grid_meta.failure[0].times = null;
	grid_meta.failure[0].labor_time = 0;
	grid_meta.failure[0].cost = 0;
	grid_meta.defective.has_defective_failures = false;
	grid_meta.repair.can_repair = true;
	grid_meta.repair.distribution = 'exponential';
	grid_meta.repair.parameters = [0.155]; //mean in days
	grid_meta.repair.times = null;
	grid_meta.degradation.can_degrade = false;
	
	// Trackers
	if(is_tracking_system)
	{
		global trackers = alloc(num_trackers);
		global tracker_meta = null;
		tracker_meta.can_fail = false;
		tracker_meta.number = num_trackers;
		tracker_meta.warranty.has_warranty = false;
		tracker_meta.failure[0].distribution = 'exponential';
		tracker_meta.failure[0].parameters = [0.083 / 365]; //mean per year converted to per day
		tracker_meta.failure[0].times = null;
		tracker_meta.failure[0].labor_time = 0;
		tracker_meta.failure[0].cost = 2000;
		tracker_meta.defective.has_defective_failures = false;
		tracker_meta.repair.can_repair = true;
		tracker_meta.repair.distribution = 'lognormal-n';
		tracker_meta.repair.parameters = [30, 10]; //mean, std, in days
		tracker_meta.repair.times = null;
		tracker_meta.degradation.can_degrade = false;
	}
	
	// Costs
	global costs = null;
	

//*************************************************************************************
// SUPPORTING FUNCTIONS
//*************************************************************************************
/* 	LHS performs Latin Hypercube Sampling given a distribution type, distribution parameters,
	and a number of samples. The name parameter allows a more helpful error message.
	Returns an array of the calculated samples.*/
function LHS(name, distribution_type, parameters, num_samples)
{
	lhs = lhs_create();
	lhs_dist(lhs, 'x', distribution_type, parameters);
	if (!lhs_run(lhs, num_samples))
	{
		msgbox('Latin Hypercube Sampling failed for: ' + name + ': ' + lhs_error(lhs));
		exit;
	}
	result = lhs_vector(lhs, 'x');
	lhs_free(lhs);
	return result;
}

//*************************************************************************************
// COMPONENT FUNCTIONS
//*************************************************************************************

//INITIALIZATION------------------------------------------------------------------------------
// Used to set up a component for the first time or to renew the values when the component is repaired
// Initializes a single component "component_idx" in the "component_vector"
// "Component_meta" stores the failure and repair information for that type of component
// If initializing a component for the first time, "bool_time_is_zero" is true
// If initializing due to a repair, "bool_time_is_zero" is false

function initialize_component(component_meta, component_vector, component_idx, bool_time_is_zero)
{
	// Component state
	component_vector[component_idx].state = 1; //component is operational
	
	// Component failures and repairs
	num_failure_modes = #component_meta.failure;
	
	if (bool_time_is_zero)
	{
		// cumulative failures and OOW failures initialized to zero at time zero only
		component_vector[component_idx].cumulative_failures = 0;
		component_vector[component_idx].cumulative_oow_failures = 0;
		if (component_meta.defective.has_defective_failures)
			component_vector[component_idx].defective_failures = 0;
		for (i=0; i < num_failure_modes; i++)
			component_vector[component_idx].failures_by_type[i] = 0;
		// degradation
		if (component_meta.degradation.can_degrade)
			component_vector[component_idx].degradation_factor = 1;
	}
	
	// Loop through all failure modes to determine failure times
	for (j = 0; j < num_failure_modes; j++)
	{
		if (component_meta.failure[j].times == null || #component_meta.failure[j].times <= 0) //null on initialization of very first component, less than zero when you've used up the pre-calculated vector
			component_meta.failure[j].times = LHS(to_string(component_meta.failure[j].times), component_meta.failure[j].distribution, component_meta.failure[j].parameters, (#component_vector * 10));
		possible_failure_times[j] = component_meta.failure[j].times[0]; //assign a failure time
		component_meta.failure[j].times -@ 0; //remove the failure time that was just used
	}
	// Because all failure modes are hard failures (no partial failures), pick whichever failure mode will occur first
	component_vector[component_idx].time_to_failure = min(possible_failure_times);
	component_vector[component_idx].failure_type = possible_failure_times ?@ component_vector[component_idx].time_to_failure;
	
	// Defective component
	if (component_meta.defective.has_defective_failures)
	{
		component_vector[component_idx].defective = rand() < component_meta.defective.fraction; //randomly assign a given fraction of components to be defective
		// If the component is defective, check the defective failure time against the previously assigned failure time
		if (component_vector[component_idx].defective)
		{	
			if (component_meta.defective.times == null || #component_meta.defective.times <= 0) //null on initialization of very first component, less than zero when you've used up the pre-calculated vector
				component_meta.defective.times = LHS(to_string(component_meta.defective.times), component_meta.defective.distribution, component_meta.defective.parameters, (#component_vector * 10));
			defective_failure_time = component_meta.defective.times[0]; //assign a failure time
			component_meta.defective.times -@ 0; //remove the failure time that was just used
			if (defective_failure_time < component_vector[component_idx].time_to_failure) //defective failure occurs before normal failure
			{
				component_vector[component_idx].time_to_failure = defective_failure_time;
				component_vector[component_idx].failure_type = 'defective';
			}
		}
	}

	// Time to replacement or repair in case of failure
	if (component_meta.repair.times == null || #component_meta.repair.times <= 0) //null on initialization of very first component, less than zero when you've used up the array
		component_meta.repair.times = LHS(to_string(component_meta.repair.times), component_meta.repair.distribution, component_meta.repair.parameters, (#component_vector * 10));
	component_vector[component_idx].time_to_repair = component_meta.repair.times[0];
	component_meta.repair.times -@ 0; //remove the repair time that was just used
	
	// Reset degradation time when a component is replaced
	if (component_meta.degradation.can_degrade)
		component_vector[component_idx].days_of_degradation = 0;
}

//COMPONENT FAILURE----------------------------------------------------------------------------------------
// Used to change a component's state from operational to failed
// Changes "component_idx" in the array "component" state to failed and increments failures
// Checks current "day" against warranty if bool_warranty is true

function component_failure(component_vector, component_idx, day, bool_warranty, warranty_length_days)
{
	component_vector[component_idx].state = 0;
	component_vector[component_idx].time_to_failure = 0;
	component_vector[component_idx].cumulative_failures++;
	if (component_vector[component_idx].failure_type == 'defective')
		component_vector[component_idx].defective_failures++;
	else
		component_vector[component_idx].failures_by_type[component_vector[component_idx].failure_type]++;
	if (bool_warranty && day > warranty_length_days)
		component_vector[component_idx].cumulative_oow_failures++;
}

//*************************************************************************************
// SYSTEM FUNCTIONS
//*************************************************************************************

//SYSTEM INITIALIZATION---------------------------------------------------------------------------------
function initialize()
{
	// Create module structures
	for (m = 0; m < module_meta.number; m++)
		initialize_component(module_meta, modules, m, true);
		
	// Create string structures
	for (s = 0; s < string_meta.number; s++)
		initialize_component(string_meta, strings, s, true);
		
	// Create combiner structures
	for (c = 0; c < combiner_meta.number; c++)
		initialize_component(combiner_meta, combiners, c, true);
		
	// Create inverter structures
	for (i = 0; i < inverter_meta.number; i++)
		initialize_component(inverter_meta, inverters, i, true);
	
	// Create AC disconnect structures
	for (d = 0; d < disconnect_meta.number; d++)
		initialize_component(disconnect_meta, disconnects, d, true);
	
	// Create transformer structures
	for (t = 0; t < transformer_meta.number; t++)
		initialize_component(transformer_meta, transformers, t, true);
	
	// Create grid structure
	initialize_component(grid_meta, grid, 0, true);
	
	// Create tracker structures
	if (is_tracking_system)
	{
		for (tr = 0; tr < tracker_meta.number; tr++)
			initialize_component(tracker_meta, trackers, tr, true);
	}
}

// DC DERATE CALCULATION FUNCTION------------------------------------------------------------------------
function whats_my_dc_derate() 
{
	//note that here, "operational modules" means modules whose power is REACHING the inverter, 
	//regardless of whether the module itself is failed or not
	operational_modules = 0;
	
	for (c=0; c < combiner_meta.number; c++)
	{
		if (combiners[c].state == 0)
			continue; //if the combiner out, none of the modules on that combiner reach the inverter
		for (s=0; s < num_strings_per_combiner; s++)
		{
			if (strings[s].state == 0)
				continue; //if string is out, none of the modules on that combiner reach the inverter
			for (m=0; m < num_modules_per_string; m++)
			{
				// what module index are we at? 
				/* 
				number of combiners we've already looped through * total number modules per combiner +
				number of strings on this combiner we've already looped through * modules per string +
				number of modules that we've passed on this string
				*/
				// because c, s, and m are 0-indexed, they represent how many of each component have been completed by this point
				module_index = c * (num_strings_per_combiner * num_modules_per_string) + s * num_modules_per_string + m;
				if (module_index > #modules - 1)
				{
					msgbox('Error, calculated module index > number of modules in the dc derate function');
					exit;
				}
				operational_modules += modules[module_index].state; //1 if operating, 0 if failed
			}
		}
	}
		
	return operational_modules / module_meta.number;
}

// AC DERATE CALCULATION FUNCTION--------------------------------------------------------------------------
function whats_my_ac_derate()
{
	//grid is down
	if (grid[0].state == 0)
		return 0;
	
	operational_inverters = 0;
	for (t=0; t < transformer_meta.number; t++)
	{
		if (transformers[t].state == 0) 
			continue; //if the transformer is down, none of those inverters can reach grid
		for (i=0; i < num_inverters_per_transformer; i++)
		{
			// because t and i are 0-indexed, they represent how many of each component have been completed by this point
			inverter_index = t * num_inverters_per_transformer + i;
			if (inverter_index > #inverters - 1)
			{
				msgbox('Error, calculated inverter index > number of inverters in the ac derate function');
				exit;
			}
			operational_inverters += (inverters[inverter_index].state && disconnects[inverter_index].state ); //1 if both are operating, 0 if either or both is failed
		}
	}
	return operational_inverters / inverter_meta.number;
}

// FLEETWIDE DEGRADATION CALCULATION------------------------------------------------------------------------
//Degradation is only averaged for operational modules. 
//Otherwise, the power production hit from degradation and from the module failure would be unfairly double-counted in production estimates.
function whats_my_degradation()
{
	fleet_degradation_sum = 0;
	number_of_operational_modules = 0;
	for (m=0; m < module_meta.number; m++)
	{
		if (modules[m].state == 1)
		{ 
			fleet_degradation_sum += modules[m].degradation_factor;
			number_of_operational_modules++;
		}
	}
	return fleet_degradation_sum / number_of_operational_modules;
}


// INCREMENT TIMESTEP FUNCTION------------------------------------------------------------------------------
//increments all components in component_vector of type component_meta on a given day
//returns the value of component_repair_costs, which is how much repairs for this component cost on this day
function step_in_time(component_meta, component_vector, day, component_repair_costs)
{
	//initialize repair costs
	component_repair_costs[day] = 0;
	
	//loop through number of components
	for (i=0; i < component_meta.number; i++)
	{
		//component is operational
		if (component_vector[i].state == 1)
		{
			component_vector[i].time_to_failure--;
			//component has just failed and failure is allowed for this type of component
			if (component_vector[i].time_to_failure <= 0 && component_meta.can_fail == true)
				component_failure(component_vector, i, day, component_meta.warranty.has_warranty, component_meta.warranty.days);
		}
		
		//component is currently failed
		else
		{
			component_vector[i].time_to_repair--;
			//component is repaired
			if (component_vector[i].time_to_repair <= 0 && component_meta.repair.can_repair) //only repair the item if repairs are enabled
			{
				//add the cost to repair the component
				failure_index = 0;
				if (component_vector[i].failure_type != 'defective') //defective costs the same as failure mode 0
					failure_index = component_vector[i].failure_type; 
				component_repair_cost = component_meta.failure[failure_index].cost + labor_rate * component_meta.failure[failure_index].labor_time;
				component_repair_costs[day] += component_repair_cost;
				//initialize a new module without resetting cumulative failures
				initialize_component(component_meta, component_vector, i, false); 			
			}
		}
		
		//degradation
		if (component_meta.degradation.can_degrade)
		{
			component_vector[i].degradation_factor = current_degradation_rate(component_meta.degradation.rate / 365, component_vector[i].days_of_degradation);
			component_vector[i].days_of_degradation++;
		}
	}
}


//*************************************************************************************
// MAIN SCRIPT
//*************************************************************************************

// Allocate outputs
//costs
costs.module = alloc(system_lifetime_yrs * 365);
costs.string = alloc(system_lifetime_yrs * 365);
costs.combiner = alloc(system_lifetime_yrs * 365);
costs.inverter = alloc(system_lifetime_yrs * 365);
costs.disconnect = alloc(system_lifetime_yrs * 365);
costs.transformer = alloc(system_lifetime_yrs * 365);
costs.grid = alloc(system_lifetime_yrs * 365);
if (is_tracking_system)
	costs.tracker = alloc(system_lifetime_yrs * 365);
//time variables
module_degradation = null;
dc_availability = ac_availability = null;
labor_rate = 0;

//timestep 0
initialize();
module_degradation[0] = whats_my_degradation();
dc_availability[0] = whats_my_dc_derate();
ac_availability[0] = whats_my_ac_derate();
costs.module[0] = costs.string[0] = costs.combiner[0] = 0; //no costs are accrued at time zero because nothing has changed state
costs.inverter[0] = costs.disconnect[0] = costs.transformer[0] = 0;
costs.grid[0] = 0;
if (is_tracking_system)
	costs.tracker[0] = 0;
//outln('0\t' + modules);


//rest of system lifetime
for (day = 1; day < system_lifetime_yrs * 365; day++)
{	
	//increase the labor rate each year
	if (day == 1 || mod(day, 365) == 0) //need to set the labor rate initially and then again at the beginning of every year
	{
		year = floor(day / 365);
		labor_rate = present_day_labor_rate * pow((1 + inflation / 100), year);
	}
	//step each component through time
	step_in_time(module_meta, modules, day, costs.module);
	step_in_time(string_meta, strings, day, costs.string);
	step_in_time(combiner_meta, combiners, day, costs.combiner);
	step_in_time(inverter_meta, inverters, day, costs.inverter);
	step_in_time(disconnect_meta, disconnects, day, costs.disconnect);
	step_in_time(transformer_meta, transformers, day, costs.transformer);
	step_in_time(grid_meta, grid, day, costs.grid);
	if (is_tracking_system)
		step_in_time(tracker_meta, trackers, day, costs.tracker);
	//count up current timestep states
	if (is_tracking_system)
		tilt_angle[day] = whats_my_average_tracking_angle();
	module_degradation[day] = whats_my_degradation();
	dc_availability[day] = whats_my_dc_derate();
	ac_availability[day] = whats_my_ac_derate();
	//outln(day + '\t' + modules);
}	
	
//create SAM performance adjustment tables for the availability derates
time = alloc(8760 * system_lifetime_yrs);
daily_dc_loss = alloc(365 * system_lifetime_yrs);
daily_ac_loss = alloc(365 * system_lifetime_yrs);
idx = 0;
day_num = alloc(365 * system_lifetime_yrs);
for (day = 0; day < (365 * system_lifetime_yrs); day++)
{
	day_num[day] = day;
	daily_dc_loss[day] = 100 * (1 - (dc_availability[day] * module_degradation[day]));
	daily_ac_loss[day] = 100 * (1 - ac_availability[day]);
	for (j = 0; j < 24; j++)
	{
		time[idx] = idx;
		idx++;
	}
}

//Tracker adjustments


//DC adjustment factors
set('en_dc_lifetime_losses', 1);
set('dc_lifetime_losses', daily_dc_loss);
//AC adjustment factors
set('en_ac_lifetime_losses', 1);
set('ac_lifetime_losses', daily_ac_loss);
//Degradation is included as part of the DC losses, so set it to zero and create a note in the UI
set('dc_degradation', [0]);
//show_page('Lifetime PV');
//pagenote('Degradation is included in the lifetime daily DC losses, so the degradation input has been set to zero.');


//Create O&M inputs based on costs
o_m_yearly_costs = alloc(system_lifetime_yrs);
yr_idx = 0;
cost_components = @costs;
for (day = 0; day < system_lifetime_yrs * 365; day++)
{
	if (mod(day, 365) == 0) //we've reached the beginning of a new year
	{
		yr_idx = day / 365;
		o_m_yearly_costs[yr_idx] = 0;
	}
	for (c=0; c<#cost_components; c++)
		o_m_yearly_costs[yr_idx] += costs{cost_components[c]}[day];	
}
set('om_fixed', o_m_yearly_costs);


//run PV performance model- for now running the currently active case
messages = '';
success = simulate(messages, true);
if (!success)
	msgbox('Simulation failed.' + messages);
show_page('Results');


//OUTPUTS-------------------------------------------------------------------------------------------------------------

//failures
total_module_failures = total_string_failures = total_combiner_failures = 0;
total_inverter_failures = total_disconnect_failures = total_transformer_failures = 0;
total_grid_failures = 0;
total_tracker_failures = 0;
//count up cumulative failures
for (m=0; m < module_meta.number; m++)
	total_module_failures += modules[m].cumulative_failures;
for (s=0; s < string_meta.number; s++)
	total_string_failures += strings[s].cumulative_failures;
for (c=0; c < combiner_meta.number; c++)
	total_combiner_failures += combiners[c].cumulative_failures;
inverter_failures_by_type = alloc(#inverter_meta.failure);
for (j=0; j<#inverter_meta.failure; j++)
	inverter_failures_by_type[j] = 0;
for (i=0; i < inverter_meta.number; i++)
{
	total_inverter_failures += inverters[i].cumulative_failures;
	for (j=0; j<#inverter_meta.failure; j++)
		inverter_failures_by_type[j] += inverters[i].failures_by_type[j];
}
for (d=0; d < disconnect_meta.number; d++)
	total_disconnect_failures += disconnects[d].cumulative_failures;
for (t=0; t < transformer_meta.number; t++)
	total_transformer_failures += transformers[t].cumulative_failures;
total_grid_failures = grid[0].cumulative_failures;
if (is_tracking_system)
{
	for (tr=0; tr < tracker_meta.number; tr++)
		total_tracker_failures += trackers[tr].cumulative_failures;
}

//outln(dc_availability);
outln('Total module failures =' + total_module_failures);
outln('Total string failures =' + total_string_failures);
outln('Total combiner failures =' + total_combiner_failures);
outln('Total inverter failures =' + total_inverter_failures);
outln('Inverter failures by type =' + inverter_failures_by_type);
outln('Total disconnect failures =' + total_disconnect_failures);
outln('Total transformer failures =' + total_transformer_failures);
outln('Total grid failures =' + total_grid_failures);

//daily failures
dview(2, 24, 'Daily availability', 'DC Power Losses', '', 1.0, dc_availability, 'AC Power Losses', '', 1.0, ac_availability);

//lifetime power output
hourly_dc_power = get('dc_net');
hourly_ac_power = get('gen');
dview(2, 1, 'Lifetime System Power', 'DC Power', 'kW', 1.0, hourly_dc_power, 'AC Power', 'kW', 1.0, hourly_ac_power);

/*
newplot();
plot(day_num, module_degradation, {type = 'line'});
plotopt({title = 'Fleetwide Module Degradation vs Time'});
axis('x1', {label = 'Hour'});
axis('y1', {label = 'Module Degradation'});
*/