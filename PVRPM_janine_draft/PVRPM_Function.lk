
//*************************************************************************************
//PV Reliability Performance Model Version 2.0
//Supporting Functions and Model Implementation -- BETA -- 
//Janine Freeman, NREL
//09 June 2017
//*************************************************************************************

// WISHLIST-----------------------------------------------------------------------------------
/*
	METHODOLOGY:
	routine inverter failures should not completely reset inverters- but how to know which ones do reset it?
	multi-thread the stochastic piece when parallel LK functions become available
	stepped warranties? degradation triggering warranty?
	generalize degradation to be able to apply to any component?
	how to calculate DC and AC availability more generally (so that components can easily be added)?
	Worst case tracker algorithm isn't realistic for east-west axis trackers (they rarely end up actually facing north). How do we account for this?
		
	OUTPUTS:	
	Add component-level availability output graph vs time (using Geoff's equation)
	Basic failure rates as an output (failures per million hours)
	add number of failures per component per year- in a csv
	labor vs equipment costs per year for each component
	average degradation factor per year (roll up from CSV)
	how many operable pieces of equipment at the end of each year
	lower priority- add MTTR (mean time to repair)
	component downtime
	component contribution to energy loss
	confidence intervals applying to cumulative energy sums and failures only??
	fix time to failure calculations
	cumulative energy output
	
	USABILITY:
	Make macro UI inputs
	in documentation- if you want to model microinverters, here's how you would set it up
	can we create new SAM cases for various realizations? -> make an option to do it (first five realizations)
		along with this, uncheck daily dc and ac lifetime loss checkboxes in the original case
	after patch- add second parameter to excel call so that the window doesn't show up
	
*/



//**********************************************************************************************************************************************************************
// SUPPORTING FUNCTIONS
//**********************************************************************************************************************************************************************


// --------------------------------------------------------------------------------------------------------------------------------------
/* 	LHS performs Latin Hypercube Sampling given a distribution type, distribution parameters,
	and a number of samples. The name parameter allows a more helpful error message.
	Returns an array of the calculated samples.*/
	
function LHS(name, distribution_type, parameters, num_samples)
{
	/*LHS library included in SAM requires mean and error factor inputs into lognormal function.
	Lognormal-n function requires mean and std of the UNDERLYING normal distribution.
	However, most users will have mean and std of actual distribution. 
	Therefore, must translate from mean and std to mean and error factor.
	See translation equations at https://dakota.sandia.gov/content/latest-reference-manual, Keywords>Variables>lognormal_uncertain */
	if (distribution_type == 'lognormal')
	{
		mu = parameters[0]; //mean
		sigma = parameters[1]; //std
		zeta = sqrt(log(pow(sigma,2) / pow(mu,2) + 1)); //log is the natural log, log10 is the base-10 log function
		e = 2.71828;
		epsilon = pow(e,(1.645*zeta)); //error factor
		parameters[1] = epsilon; //temporarily overwrite the second parameter
	}
	if (num_samples > 20000)
		num_samples = 20000; //LHS can only run so many samples at a time
	lhs = lhs_create();
	lhs_dist(lhs, 'x', distribution_type, parameters);
	if (!lhs_run(lhs, num_samples))
	{
		msgbox('Latin Hypercube Sampling failed for: ' + name + ': ' + lhs_error(lhs));
		exit;
	}
	result = lhs_vector(lhs, 'x');
	lhs_free(lhs);
	if (distribution_type == 'lognormal') 
		parameters[1] = sigma; //set second parameter back to std before exiting the function
	return result;
}


// --------------------------------------------------------------------------------------------------------------------------------------
/* DC Energy returns an array of annual DC energy (kWh) based on an input array of timeseries DC power (kW) for the system lifetime (likely the 'dc_net' output from SAM).*/
function dc_energy_from_timeseries(timeseries_dc_power, system_lifetime_yrs)
{
	dc_energy = alloc(system_lifetime_yrs); 
	timestep = #timeseries_dc_power / system_lifetime_yrs / 8760; //divide by number of years, then number of hours per year, then we know how many steps are in an hour
	idx = 0;
	for (yr=0; yr<system_lifetime_yrs; yr++)
	{
		dc_energy[yr] = 0; //we want this in energy, kWh
		for (i=0;i<8760;i++)
			for(j=0; j<timestep; j++)
			{
				dc_energy[yr] += timeseries_dc_power[idx] / timestep; //need to divide by timestep to convert from kW to kWh. For hourly timesteps, this is dividing by 1, but for subhourly, we need this piece.
				idx++;
			}
	}
	return dc_energy;
}


// --------------------------------------------------------------------------------------------------------------------------------------
/* Cumulative energy returns an array of the cumulative energy production in kWh from an array of annual energy production in kWh*/
function cumulative_energy(annual_energy)
{
	cumul_energy = alloc(#annual_energy);
	cumul_energy[0] = annual_energy[0]; //first year energy is the same for both arrays
	for (i=1; i<#annual_energy; i++)
		cumul_energy[i] = annual_energy[i] + cumul_energy[i-1]; //add the current year's energy to the previous year's cumulative energy
	return cumul_energy;
}


// --------------------------------------------------------------------------------------------------------------------------------------
/* Case Checking contains preliminary case checking and assigns the inputs from the active SAM case.*/

function check_case()
{
	if (active_case() == '')
	{
		msgbox('Please select a SAM case.');
		exit;
	}
	
	if (num_realizations <= 1)
	{
		msgbox('You must specify more than one realization.');
		exit;
	}
	
	// Technology must be detailed PV model
	global cfg = configuration();
	tech = cfg[0];
	if (tech != 'Flat Plate PV')
	{
		msgbox('Error: This script is only applicable to the detailed photovoltaic model. Exiting simulation.');
		exit;
	}
	
	global num_modules = get('total_modules');
	global num_modules_per_string = get('modules_per_string');
	global num_strings = get('strings_in_parallel');
	global num_inverters = get('inverter_count');
	global inverter_size = ?(get('inverter_model')) [get('inv_snl_paco'), get('inv_ds_paco'), get('inv_pd_paco')];
	global num_disconnects = num_inverters; //assume 1 AC disconnect per inverter
	global num_strings_per_combiner = floor(num_strings / num_combiners);
	global num_inverters_per_transformer = floor(num_inverters / num_transformers);
	
	global system_lifetime_yrs = get('analysis_period');
	global has_multiple_subarrays = ( (get('subarray2_enable') == 1) || (get('subarray3_enable') == 1) || (get('subarray4_enable') == 1) );
	global is_tracking_system = false;
	if ((get('subarray1_track_mode') == 1 || get('subarray1_track_mode') == 2 || get('subarray1_track_mode') == 3))
		is_tracking_system = true;
	if (get('subarray2_enable') == 1 && (get('subarray2_track_mode') == 1 || get('subarray2_track_mode') == 2 || get('subarray2_track_mode') == 3))
		is_tracking_system = true;
	if (get('subarray3_enable') == 1 && (get('subarray3_track_mode') == 1 || get('subarray3_track_mode') == 2 || get('subarray3_track_mode') == 3))
		is_tracking_system = true;
	if (get('subarray4_enable') == 1 && (get('subarray4_track_mode') == 1 || get('subarray4_track_mode') == 2 || get('subarray4_track_mode') == 3))
		is_tracking_system = true;
}


// --------------------------------------------------------------------------------------------------------------------------------------
/*Configuration check contains most of the error-checking to make sure that the system is set up correctly 
to enable the PVRPM script to run successfully. */

function configuration_check()
{
	// There must be and can only be a "tracker" entry in meta if it is a tracking system
	meta_has_tracker = (meta.tracker != null);
	if (is_tracking_system && !meta_has_tracker)
	{
		msgbox('Error: You must specify a tracker meta entry for tracking systems.');
		exit;
	}
	if (!is_tracking_system && meta_has_tracker)
	{
		msgbox('Error: Please comment out or delete the tracker meta entry for fixed tilt systems.');
		exit;
	}
	
	// All expected components must be present
	if (meta.module == null || meta.string == null || meta.combiner == null || meta.inverter == null || meta.disconnect == null || meta.transformer == null || meta.grid == null)
	{
		msgbox('Error: All of the following components must be specified: module, string, combiner, inverter, disconnect, transformer, and grid.');
		exit;
	}
	
	// Get the components for error-checking below
	components = @meta;
	
	// Check that all the input fields are available
	for (c=0; c<#components; c++)
	{
		//First four meta components: name, can_fail, can_repair, and warranty.has_warranty
		all_available = true;
		if (meta{components[c]}.name == null || meta{components[c]}.can_fail == null || meta{components[c]}.can_repair == null || meta{components[c]}.warranty == null)
			all_available = false;
		elseif (meta{components[c]}.warranty.has_warranty == null)
			all_available = false;
		if (!all_available)
		{
			msgbox('Error: ' + components[c] + ': missing meta data. Each component type requires name, can_fail, can_repair, and warranty.has_warranty.');
			exit;
		}
		//If warranty is specified, you must provide the length of the warranty
		if (meta{components[c]}.warranty.has_warranty)
			if (meta{components[c]}.warranty.days == null)
			{
				msgbox('Error: ' + components[c] + ': a warranty was specified but the length of time for the warranty was not specified. Please specify meta.' + components[c] + '.warranty.days in the main script.');
				exit;
			}
		//Failure parameters
		if (meta{components[c]}.can_fail)
		{
			if (meta{components[c]}.failure == null)
			{
				msgbox('Error: ' + components[c] + ': failure modes must be specified for components that can fail.');
				exit;
			}
			num_failure_modes = #meta{components[c]}.failure;
			for (i=0; i<num_failure_modes; i++)
			{
				if (meta{components[c]}.failure[i] == null)
				{
					msgbox('Error: ' + components[c] + ': failure modes must be numbered sequentially starting at 0.');
					exit;
				}
				if (meta{components[c]}.failure[i].distribution == null || meta{components[c]}.failure[i].parameters == null || meta{components[c]}.failure[i].labor_time == null || meta{components[c]}.failure[i].cost == null)
				{
					msgbox('Error: ' + components[c] + ': failure mode ' + i + ' requires four inputs: distribution, parameters, labor_time, and cost.');
					exit;
				}
			}
		}
		//Repair parameters
		if (meta{components[c]}.can_repair)
		{
			if (meta{components[c]}.repair == null)
			{
				msgbox('Error: ' + components[c] + ': repair modes must be specified for components that can be repaired.');
				exit;
			}
			num_repair_modes = #meta{components[c]}.repair;
			for (i=0; i<num_repair_modes; i++)
			{
				if (meta{components[c]}.repair[i] == null)
				{
					msgbox('Error: ' + components[c] + ': repair modes must be numbered sequentially starting at 0.');
					exit;
				}
				if (meta{components[c]}.repair[i].distribution == null || meta{components[c]}.repair[i].parameters == null)
				{
					msgbox('Error: ' + components[c] + ': repair mode ' + i + ' requires two inputs: distribution and parameters.');
					exit;
				}
			}
		}
		//Number of repair modes must either be 1, or equal to the number of failure modes
		if (meta{components[c]}.can_fail && meta{components[c]}.can_repair)
		{
			num_repair_modes = #meta{components[c]}.repair;
			if (num_repair_modes != 1)
			{
				num_failure_modes = #meta{components[c]}.failure;
				if (num_repair_modes != num_failure_modes)
				{
					msgbox('Error: ' + components[c] + ': The number of repair modes must either be 1 or be equal to the number of failure modes.');
					exit;
				}
			}			
		}		
	}
	
	// Module Degradation
	degradation_ok = false;
	if (meta.module.degradation != null)
	{
		if (meta.module.degradation.can_degrade != null)
			if (meta.module.degradation.can_degrade && meta.module.degradation.rate != null)
				degradation_ok = true;
			elseif (meta.module.degradation.can_degrade == false)
				degradation_ok = true;
	}
	if (!degradation_ok)
	{
		msgbox('Error: module degradation is set up incorrectly.');
		exit;
	}	

	// At least one thing must be set up to fail
	something_can_fail = false;
	for (c=0; c<#components; c++)
	{
		if (meta{components[c]}.can_fail)
			something_can_fail = true;
	}
	if (!something_can_fail)
	{
		msgbox('Error: you must enable at least one component to fail.');
		exit;
	}
	
	// More variable initializations	
	for (c=0; c<#components; c++)
	{
		//Set up null failure times for components
		num_failure_modes = #meta{components[c]}.failure;
		for (i=0; i<num_failure_modes; i++)
			meta{components[c]}.failure[i].times = null;
		
		//Set up null repair times for components
		num_repair_modes = #meta{components[c]}.repair;
		for (i=0; i<num_repair_modes; i++)
			meta{components[c]}.repair[i].times = null;
			
		//set degradation for the components that aren't currently allowed to degrade
		if (meta{components[c]}.name == 'module')
			continue;
		meta{components[c]}.degradation.can_degrade = false;
			
	}
	
	//Set the numbers of components
	meta.module.number = num_modules;
	meta.string.number = num_strings;
	meta.combiner.number = num_combiners;
	meta.inverter.number = num_inverters;
	meta.disconnect.number = num_disconnects;
	meta.transformer.number = num_transformers;
	meta.grid.number = 1;
	if (is_tracking_system)
		meta.tracker.number = num_trackers;
		
	// There must be an integer number of strings per combiner
	if (num_strings_per_combiner * num_combiners != num_strings) 
	{
		msgbox('Error: there must be an integer number of strings per combiner.');
		exit;
	}
	
	// There must be an integer number of inverters per transformer
	if (num_inverters_per_transformer * num_transformers != num_inverters) 
	{
		msgbox('Error: there must be an integer number of inverters per transformer.');
		exit;
	}
	
	// Number of combiners, transformers, trackers must be positive
	if (num_combiners <= 0)
	{
		msgbox('Error: there must be a positive number of combiners.');
		exit;
	}
	if (num_transformers <= 0)
	{
		msgbox('Error: there must be a positive number of transformers.');
		exit;
	}
	if (is_tracking_system && num_trackers <= 0)
	{
		msgbox('Error: there must be a positive number of trackers.');
		exit;
	}
	
	// Financial models third party, LCOE calculator, and None don't have lifetime mode (note that ALL financial models calculate LCOE, not just the LCOE calculator!)
	fin = cfg[1];
	if (fin == 'Third Party' || fin == 'LCOE Calculator' || fin == 'None')
	{
		msgbox('Error: This script cannot be run from financial model: ' + fin + '. Exiting simulation.');
		exit;
	}
	
	// Must be run in lifetime mode
	is_lifetime_mode = get('pv_lifetime_simulation');
	if (!is_lifetime_mode)
	{
		make_lifetime_mode = yesno('PV simulations must be run in lifetime mode with this script. Change your case to lifetime mode now?');
		if (!make_lifetime_mode)
		{
			msgbox('Error: Please modify your case to use lifetime mode. Exiting simulation');
			exit;
		}
		set('pv_lifetime_simulation', 1);
	}
	
	// Lifetime daily DC and AC loss structures must be empty to run.
	if (get('en_dc_lifetime_losses') || get('en_ac_lifetime_losses'))
	{
		proceed = yesno('This script will overwrite any user-entered lifetime daily losses, and they will be lost. Proceed?');
		if (!proceed)
		{
			msgbox('Please modify the case not to use user-entered lifetime daily losses. Exiting simulation.');
			exit;
		}
	}
	
	// Existing O&M costs must be 0
	global existing_costs = null;
	if (get('om_fixed') != [0])
	{
		overwrite = yesno('There is a non-zero value in the fixed annual O&M costs input. Would you like to overwrite the existing costs with the calculated ones? ' + 
				'Otherwise, the calculated costs will be ADDED to the existing ones.');
		if (!overwrite)
			existing_costs = get('om_fixed');
	}
	
	// Warn user if current degradation is non-zero, because we zero it
	if (get('dc_degradation') != [0])
	{
		msgbox('Warning: Degradation is set by the PVRPM script, you have entered a non-zero degradation to the degradation input. This script will set the degradation input to zero.');
		set('dc_degradation', [0]);
	}
	
	// Multiple subarrays can't have tracker failures
	if (has_multiple_subarrays && is_tracking_system && meta.tracker.can_fail)
	{
		msgbox('Error: Tracker failures may only be modeled for a system consisting of a single subarray. Exiting simulation.');
		exit;
	}
	
	// Tracking systems can't be 2-axis or azimuth-axis
	if (is_tracking_system)
	{
		//only need to check subarray 1, since at this point tracking systems with multiple subarrays will have been terminated.
		if (get('subarray1_track_mode') == 2 || get('subarray1_track_mode') == 3)
		{
			msgbox('Error: This script is not configured to run with 2-axis tracking or azimuth-axis tracking systems. Exiting simulation.');
			exit;
		}
	}
	
	// Limitations of empirical P-value calculation
	//Or, do we extrapolate the last data point if there are too few realizations?
	//Or, do we give a choice between assuming a normal distribution, and empirical calculation?
	max_p_value = (1 - 1 / num_realizations) * 100;
	if ( p_value > max_p_value )
	{
		msgbox('Error: The maximum p-value that can be calculated with ' + num_realizations + 'is ' + max_p_value + '. Please either lower your desired p-value or increase the number of realizations.');
		exit;
	}
}


// --------------------------------------------------------------------------------------------------------------------------------------
/* Precalculate_tracker_losses calculates an array of coefficients (one for every day of the year) that account for the
"benefit" of trackers on that particular day. This is used to determine how much power is lost if a tracker fails. See
the PVRPM User Manual for details. */

function precalculate_tracker_losses()
{
	global daily_tracker_coeffs = alloc(365);
	if (meta.tracker.can_fail)
	{
		
		if (get('subarray1_tilt') != 0)
		{
			msgbox('This script can only model tracker failures for 0 degree tilt trackers. Exiting simulation.');
			exit;
		}
		
		// calculate timeseries performance with tracker for one year
		user_analysis_period = get('analysis_period');
		set('analysis_period', 1);
		set('en_ac_lifetime_losses', 0);
		set('en_dc_lifetime_losses', 0);
		if (!simulate('', 0))
		{
			msgbox('Error simulating first-year tracker performance');
			set('analysis_period', user_analysis_period);
			exit;
		}
		timeseries_with_tracker = get('dc_net'); //power, units are kW
		
		// calculate timeseries performance without trackers for one year
		user_tracking_mode = get('subarray1_track_mode');
		user_azimuth = get('subarray1_azimuth');
		user_tilt = get('subarray1_tilt');
		set('subarray1_track_mode', 0); //set to fixed tilt
		if (user_azimuth > 360 || user_azimuth < 0)
		{
			msgbox('Azimuth must be between 0 and 360. Please adjust the azimuth and try again.');
			exit;
		}
		//assume worst case tracker gets stuck to north. If axis is north-south, assume gets stuck to west.
		if (use_worst_case_tracker)
		{
			worst_case_az = user_azimuth;
			if (user_azimuth < 180)
				worst_case_az -= 90;
			else
				worst_case_az += 90;
			if (worst_case_az < 0)
				worst_case_az += 360;
			if (worst_case_az >= 360)
				worst_case_az -=360;
			set('subarray1_azimuth', worst_case_az);
			set('subarray1_tilt', get('subarray1_rotlim'));
		}
		//assume average case is that tracker gets stuck flat
		else
			set('subarray1_tilt', 0); //doesn't matter what az is if it's flat
		if (!simulate('', 0))
		{
			msgbox('Error simulating first-year tracker failure performance');
			set('analysis_period', user_analysis_period);
			set('subarray1_track_mode', user_tracking_mode); 
			set('subarray1_azimuth', user_azimuth);
			set('subarray1_tilt', user_tilt);
			exit;
		}
		timeseries_without_tracker = get('dc_net'); //power, units are kW
		
		//calculate daily loss statistics
		timestep = (#timeseries_with_tracker / 8760);
		index = 0;
		for (d=0; d<365; d++)
		{
			sum_without_tracker = 0; //energy, units are kWh
			sum_with_tracker = 0; //energy, units are kWh
			for (h=0; h<24; h++)
				for (ts=0; ts<timestep; ts++)
				{
					sum_without_tracker += timeseries_without_tracker[index] / timestep; //need to divide by timestep to convert kW to kWh. For hourly data, dividing by 1, but it matters for subhourly data.
					sum_with_tracker += timeseries_with_tracker[index] / timestep; //need to divide by timestep to convert kW to kWh. For hourly data, dividing by 1, but it matters for subhourly data.
					index++;
				}
			//NOTE: On some cloudy days, daily_tracker_coeff might be positive!! See help for details.
			daily_tracker_coeffs[d] = sum_without_tracker / sum_with_tracker;
		}
		
		//reset the inputs to user specified values
		set('analysis_period', user_analysis_period);
		set('subarray1_track_mode', user_tracking_mode); 
		set('subarray1_azimuth', user_azimuth);
		set('subarray1_tilt', user_tilt);
	}
}


// --------------------------------------------------------------------------------------------------------------------------------------
/* The initialize_component function is used to set up a component for the first time or to renew 
the values when the component is repaired. It initializes a single component "component_idx" in 
the "component_vector". "Component_meta" stores the failure and repair information for that type 
of component. If initializing a component for the first time, "bool_time_is_zero" is true; if 
initializing due to a repair, "bool_time_is_zero" is false */

function initialize_component(component_meta, component_vector, component_idx, bool_time_is_zero)
{
	// Component state
	component_vector[component_idx].state = 1; //component is operational
	
	// Number of failure modes (needed to create failures by type)
	num_failure_modes = #component_meta.failure;
	
	// Degradation gets set (reset) to zero when a component is replaced
	if (component_meta.degradation.can_degrade)
		component_vector[component_idx].days_of_degradation = 0;
	
	if (bool_time_is_zero)
	{
		// cumulative failures and OOW failures initialized to zero at time zero only
		component_vector[component_idx].cumulative_failures = 0;
		component_vector[component_idx].cumulative_oow_failures = 0;
		for (i=0; i < num_failure_modes; i++)
			component_vector[component_idx].failures_by_type[i] = 0;
		// degradation
		if (component_meta.degradation.can_degrade)
			component_vector[component_idx].degradation_factor = 1;
		// warranty
		if (component_meta.warranty.has_warranty)
			component_vector[component_idx].time_left_on_warranty = component_meta.warranty.days;
		// availability calculations
		component_vector[component_idx].avail_downtime = 0;		
	}
	
	// If the component isn't allowed to fail, then setting failure and replacement times isn't necessary
	if (!component_meta.can_fail)
		return;
	
	// Loop through all failure modes to determine failure times
	for (j = 0; j < num_failure_modes; j++)
	{
		//check the vector of failure times for this failure mode
		if (component_meta.failure[j].times == null || #component_meta.failure[j].times <= 0) //null on initialization of very first component, less than zero when you've used up the pre-calculated vector
			component_meta.failure[j].times = LHS(component_meta.name + 'failure mode '+ j, component_meta.failure[j].distribution, component_meta.failure[j].parameters, (#component_vector * 10));
		//check if this failure mode is a defective mode
		if (component_meta.failure[j].fraction != null) //only defective failure modes have a fraction associated with them
			component_vector[component_idx].defective = rand() < component_meta.failure[j].fraction; //randomly assign a given fraction of components to be defective
		//assign a failure time for this failure mode unless it's a defective failure mode and the component is not defective
		if (component_meta.failure[j].fraction == null || component_vector[component_idx].defective)
		{
			possible_failure_times[j] = component_meta.failure[j].times[0]; //assign a failure time
			component_meta.failure[j].times -@ 0; //remove the failure time that was just used
		}
		else
			possible_failure_times[j] = nan(); //the min function won't return a nan
	}
	// Because all failure modes are hard failures (no partial failures), pick whichever failure mode will occur first
	component_vector[component_idx].time_to_failure = min(possible_failure_times);
	component_vector[component_idx].failure_type = possible_failure_times ?@ component_vector[component_idx].time_to_failure;

	// Time to replacement or repair in case of failure
	// first, figure out which type of repair we're using for this failure
	repair_idx = 0; //if only one repair distribution is listed, then each failure mode uses the same repair distribution with index 0
	if(#component_meta.repair != 1) //if more than one repair mode is listed, each failure mode has its own repair distribution
		repair_idx = component_vector[component_idx].failure_type; 
	if (component_meta.repair[repair_idx].times == null || #component_meta.repair[repair_idx].times <= 0) //null on initialization of very first component, less than zero when you've used up the array
		component_meta.repair[repair_idx].times = LHS(component_meta.name + 'repair mode '+ repair_idx, component_meta.repair[repair_idx].distribution, component_meta.repair[repair_idx].parameters, (#component_vector * 10));
	component_vector[component_idx].time_to_repair = component_meta.repair[repair_idx].times[0];
	component_meta.repair[repair_idx].times -@ 0; //remove the repair time that was just used
	
	// Time left on warranty
	if (component_meta.warranty.has_warranty)
		if (component_vector[component_idx].time_left_on_warranty <= 0) //new warranty on components replaced OOW
			component_vector[component_idx].time_left_on_warranty = component_meta.warranty.days;
}


// --------------------------------------------------------------------------------------------------------------------------------------
/* The component failure function is used to change a component's state from operational to failed.
It changes "component_idx" in the array "component" state to failed and increments failures. It also
checks current "day" against warranty if bool_warranty is true. */

function component_failure(component_vector, component_idx, day, bool_warranty)
{
	component_vector[component_idx].state = 0;
	component_vector[component_idx].time_to_failure = 0;
	component_vector[component_idx].cumulative_failures++;
	component_vector[component_idx].failures_by_type[component_vector[component_idx].failure_type]++;
	if (bool_warranty)
		if (component_vector[component_idx].time_left_on_warranty <= 0)
			component_vector[component_idx].cumulative_oow_failures++;
}


// --------------------------------------------------------------------------------------------------------------------------------------
/* The system initialization function initializes all components in the system. */

function initialize()
{
	components = @meta;
	for (c=0; c<#components; c++)
		for (i = 0; i < meta{components[c]}.number; i++)
			initialize_component(meta{components[c]}, meta{components[c]}.array, i, true);
}


// --------------------------------------------------------------------------------------------------------------------------------------
/* This function calculates the "availability" of the DC power due to DC component outages,
including modules, strings, and combiners. */

function whats_my_dc_availability() 
{
	//note that here, "operational modules" means modules whose power is REACHING the inverter, 
	//regardless of whether the module itself is failed or not
	operational_modules = 0;
	
	for (c=0; c < meta.combiner.number; c++)
	{
		if (meta.combiner.array[c].state == 0)
			continue; //if the combiner out, none of the modules on that combiner reach the inverter
		for (s=0; s < num_strings_per_combiner; s++)
		{
			if (meta.string.array[s].state == 0)
				continue; //if string is out, none of the modules on that combiner reach the inverter
			for (m=0; m < num_modules_per_string; m++)
			{
				// what module index are we at? 
				/* 
				number of combiners we've already looped through * total number modules per combiner +
				number of strings on this combiner we've already looped through * modules per string +
				number of modules that we've passed on this string
				*/
				// because c, s, and m are 0-indexed, they represent how many of each component have been completed by this point
				module_index = c * (num_strings_per_combiner * num_modules_per_string) + s * num_modules_per_string + m;
				if (module_index > #meta.module.array - 1)
				{
					msgbox('Error, calculated module index > number of modules in the dc availability function');
					exit;
				}
				operational_modules += meta.module.array[module_index].state; //1 if operating, 0 if failed
			}
		}
	}
		
	return operational_modules / meta.module.number;
}

// --------------------------------------------------------------------------------------------------------------------------------------
/* Like the DC availability function, this function calculates the "availability" of the AC power 
due to DC component outages, including inverters, disconnects, transformers, and the grid. */

function whats_my_ac_availability()
{
	//grid is down
	if (meta.grid.array[0].state == 0)
		return 0;
	
	operational_inverters = 0;
	for (t=0; t < meta.transformer.number; t++)
	{
		if (meta.transformer.array[t].state == 0) 
			continue; //if the transformer is down, none of those inverters can reach grid
		for (i=0; i < num_inverters_per_transformer; i++)
		{
			// because t and i are 0-indexed, they represent how many of each component have been completed by this point
			inverter_index = t * num_inverters_per_transformer + i;
			if (inverter_index > #meta.inverter.array - 1)
			{
				msgbox('Error, calculated inverter index > number of inverters in the ac availability function');
				exit;
			}
			operational_inverters += (meta.inverter.array[inverter_index].state && meta.disconnect.array[inverter_index].state ); //1 if both are operating, 0 if either or both is failed
		}
	}
	return operational_inverters / meta.inverter.number;
}


// --------------------------------------------------------------------------------------------------------------------------------------
/* This function calculates the current fleetwide degradation. Degradation is only averaged 
for operational modules; otherwise, the power production hit from degradation and from the 
module failure would be unfairly double-counted in production estimates. */

function whats_my_degradation()
{
	if (!meta.module.degradation.can_degrade)
		return 1;
	fleet_degradation_sum = 0;
	number_of_operational_modules = 0;
	for (m=0; m < meta.module.number; m++)
	{
		if (meta.module.array[m].state == 1)
		{ 
			fleet_degradation_sum += meta.module.array[m].degradation_factor;
			number_of_operational_modules++;
		}
	}
	return fleet_degradation_sum / number_of_operational_modules;
}


// --------------------------------------------------------------------------------------------------------------------------------------
/* This function calculates the current loss factor due to failed trackers. Input is the day number 
in the system lifetime. Returns a factor (0-1) reflecting the percentage of power lost due to 
malfunctioning trackers. */

function whats_my_tracker_power_loss_factor(day)
{
	// total number of working trackers
	num_trackers_operational = 0;
	for (tr=0; tr < meta.tracker.number; tr++)
		if (meta.tracker.array[tr].state == 1)
			num_trackers_operational++;
	fraction_operational = num_trackers_operational / meta.tracker.number;
	tracker_availability[day] = fraction_operational;
	day_of_year = mod(day, 365); //0-indexed, but so are the daily_tracker_coeffs
	adjusted_factor = 1;
	if (meta.tracker.can_fail)
	{
		full_factor = daily_tracker_coeffs[day_of_year];
		adjusted_factor = full_factor + fraction_operational* (1 - full_factor);
	}

	return adjusted_factor;
}


// --------------------------------------------------------------------------------------------------------------------------------------
/* The timestep incrementing function increments all components in component_vector of 
type component_meta on a given day and returns the value of component_repair_costs, 
which is how much repairs for this component cost on this day. */

function step_in_time(component_meta, component_vector, day, component_repair_costs)
{
	//initialize repair costs
	component_repair_costs[day] = 0;
	
	//only loop through the component vector if the component can either fail or degrade to save computation time
	if (component_meta.can_fail || component_meta.degradation.can_degrade)
	{
		for (i=0; i < component_meta.number; i++)
		{
		
			if (component_meta.can_fail)
			{
				component_meta.uptime++;
				//component is operational
				if (component_vector[i].state == 1)
				{
					component_vector[i].time_to_failure--;
					//component has just failed and failure is allowed for this type of component
					if (component_vector[i].time_to_failure <= 0 && component_meta.can_fail == true)
						component_failure(component_vector, i, day, component_meta.warranty.has_warranty);
				}
				
				//component is currently failed
				else
				{
					component_vector[i].time_to_repair--;
					//component is repaired
					if (component_vector[i].time_to_repair <= 0 && component_meta.can_repair) //only repair the item if repairs are enabled
					{
						//add the cost to repair the component
						failure_index = component_vector[i].failure_type; 
						component_repair_cost = component_meta.failure[failure_index].cost + labor_rate * component_meta.failure[failure_index].labor_time;
						if (component_meta.warranty.has_warranty)
						{
							if(component_vector[i].time_left_on_warranty <= 0) //only add repair costs if not replaced under warranty
								component_repair_costs[day] += component_repair_cost;
						}
						else
							component_repair_costs[day] += component_repair_cost;
						//initialize a new module without resetting cumulative failures
						initialize_component(component_meta, component_vector, i, false); 		
					}
				}
				
				//warranty
				if (component_meta.warranty.has_warranty)
					component_vector[i].time_left_on_warranty--;
					
				//availability
				if (component_vector[i].state == 0)
				{
					if (component_meta.name == 'grid')
						component_vector[i].avail_downtime += 24; //availability is calculated in hours. for the grid only, the availability is based on the full 24-hour day.
					else
					{
						doy = mod(day, 365); //need to know what day of year it is to get daylight hours
						component_vector[i].avail_downtime += daylight_hours[doy]; //for all other components, availability is calculated based on daylight hours only.
					}
				}
			}

			//degradation can still happen even if component can't fail
			if (component_meta.degradation.can_degrade)
			{
				component_vector[i].degradation_factor = current_degradation_rate(component_meta.degradation.rate / 365, component_vector[i].days_of_degradation);
				component_vector[i].days_of_degradation++;
			}
		} //end of for loop
	} //end of if statement
	
}



//**********************************************************************************************************************************************************************
// SYSTEM REALIZATION FUNCTION
//**********************************************************************************************************************************************************************
/* This function runs a single iteration of the stochastic model. */

function run_system_realization(realization, show_outputs)
{

	//*************************************************************************************
	// INDIVIDUAL COMPONENT DATA CONTAINER
	//*************************************************************************************
	// contains current timestep data for a single component in the system
	/*
	state = operational (1) or failed (0)
	defective = flag for whether or not this component has a defect.
		If true, then the component is also eligible for the defective failure mode
	time_to_failure = number of days left until the component fails
	failure_type = index of the type of failure that time_to_failure represents (failure[i] in component meta)
	time_to_repair = number of days from onset of failure until component is repaired
	time_left_on_warranty = number of days left on warranty for that item, if applicable
	cumulative_failures = total number of failures for that component
	cumulative_oow_failures = total number of failures out of warranty for that component if applicable
	failures_by_type[i] = total number of failures corresponding to failure mode i for that component
	defective_failures = total number of failures due to a defective component
	MODULES ONLY:
	degradation_factor = 1 - percentage the component has degraded at this time (ex. a 2% degraded component would have a degradation factor of 0.98)
	*/

	// Create a new case if the user has specified to do so
	//if (create_realization_cases && realization <=3) *******************************
	
		

	// Set up component data containers-------------------------------------------------------------------

	global costs = null;
		
	components = @meta;
	for (c=0; c<#components; c++)
	{
		meta{components[c]}.array = alloc(meta{components[c]}.number);
		if (meta{components[c]}.can_fail)
		{
			costs{components[c]} = alloc(system_lifetime_yrs * 365);
			meta{components[c]}.uptime = 0;
		}
	}
		
	// Allocate outputs----------------------------------------------------------------------------------

	//time variables
	module_degradation_factor = null;
	if (is_tracking_system)
	{
		tracker_power_loss_factor = null;
		global tracker_availability = null;
	}
	dc_power_availability = ac_power_availability = null;
	labor_rate = 0;

	// Calculate timestep zero---------------------------------------------------------------------------
	
	initialize();
	module_degradation_factor[0] = whats_my_degradation();
	dc_power_availability[0] = whats_my_dc_availability();
	ac_power_availability[0] = whats_my_ac_availability();
	cost_components = @costs;
	for (c=0; c<#cost_components; c++)
		costs{cost_components[c]}[0] = 0; //no costs are accrued at time zero because nothing has changed state

	if (is_tracking_system)
	{
		tracker_power_loss_factor[0] = 1;
		tracker_availability[0] = 1;
		original_tracker_cost = meta.tracker.failure[0].cost;
	}

	// Calculate the rest of the system lifetime----------------------------------------------------------
	
	for (day = 1; day < system_lifetime_yrs * 365; day++)
	{	
		was_canceled = progressbar(pb, {value=day, message='Running reliability model realization ' + realization + '...'});
		if (was_canceled)
		{
			outln('Simulation canceled by user.');
			progressbar(pb);
			exit;
		}
		
		//increase the labor rate each year
		if (day == 1 || mod(day, 365) == 0) //need to set the labor rate initially and then again at the beginning of every year
		{
			year = floor(day / 365);
			labor_rate = present_day_labor_rate * pow((1 + inflation / 100), year);
			if (is_tracking_system)
				meta.tracker.failure[0].cost *= pow((1 + inflation / 100), year);
		}
		
		//step each component through time		
		components = @meta;
		for (c=0; c<#components; c++)
			if (meta{components[c]}.can_fail) 
				step_in_time(meta{components[c]}, meta{components[c]}.array, day, costs{components[c]});	
		
		//count up current timestep states
		if (is_tracking_system)
			tracker_power_loss_factor[day] = whats_my_tracker_power_loss_factor(day);
		module_degradation_factor[day] = whats_my_degradation();
		dc_power_availability[day] = whats_my_dc_availability();
		ac_power_availability[day] = whats_my_ac_availability();
	}
	progressbar(pb, {message='Running SAM simulation ' + realization + '...'});	
	
	// Create SAM performance adjustment tables for availability, degradation, and tracker losses--------		

	daily_dc_loss = alloc(365 * system_lifetime_yrs);
	daily_ac_loss = alloc(365 * system_lifetime_yrs);
	for (day = 0; day < (365 * system_lifetime_yrs); day++)
	{
		daily_dc_loss[day] = 100 * (1 - (dc_power_availability[day] * module_degradation_factor[day] * ?(is_tracking_system)[1, tracker_power_loss_factor[day]]));
		daily_ac_loss[day] = 100 * (1 - ac_power_availability[day]);
	}

	//DC adjustment factors
	set('en_dc_lifetime_losses', 1);
	set('dc_lifetime_losses', daily_dc_loss);
	//AC adjustment factors
	set('en_ac_lifetime_losses', 1);
	set('ac_lifetime_losses', daily_ac_loss);

	// Create O&M inputs based on costs------------------------------------------------------------------
	
	o_m_yearly_costs = alloc(system_lifetime_yrs);
	yr_idx = 0;
	cost_components = @costs;
	for (day = 0; day < system_lifetime_yrs * 365; day++)
	{
		if (mod(day, 365) == 0) //we've reached the beginning of a new year
		{
			yr_idx = day / 365;
			o_m_yearly_costs[yr_idx] = 0;
			yearly_costs.year[yr_idx] = yr_idx + 1; //need to add one for the label because the arrays are 0-indexed
			for (c=0; c<#cost_components;c++)
				yearly_costs{cost_components[c]}[yr_idx] = 0;
		}
		for (c=0; c<#cost_components; c++)
		{
			o_m_yearly_costs[yr_idx] += costs{cost_components[c]}[day];
			yearly_costs{cost_components[c]}[yr_idx] += costs{cost_components[c]}[day];
		}
	}
	outln('Calculated yearly O&M costs = ' + o_m_yearly_costs);
	//be sure to add any existing O&M costs
	if (existing_costs != null)
	{
		for(k=0; k<system_lifetime_yrs; k++)
			o_m_yearly_costs[k] += existing_costs[k];
		outln('Calculated yearly O&M costs including user-specified costs = ' + o_m_yearly_costs);
	}
	set('om_fixed', o_m_yearly_costs);
	yearly_costs.total = o_m_yearly_costs;

	// Run PV performance model for the currently active case---------------------------------------------

	messages = '';
	success = simulate(messages, true);
	if (!success)
	{
		msgbox('Simulation failed.' + messages);
		exit;
	}
	show_page('Results');


	// OUTPUTS------------------------------------------------------------------------------------------------------------
	results.row[realization] = 'Realization_' + realization;

	//calculate results
	for (c=0; c<#components; c++)
	{
		//initialize counts
		results{components[c] + '_total_failures'}[realization] = 0;
		num_failure_modes = #meta{components[c]}.failure;
		if (num_failure_modes > 1)
			for (j=0; j<num_failure_modes; j++)
				results{components[c] + '_failures_by_type_' + j}[realization] = 0;
		results{components[c] + '_availability'}[realization] = 0;
		
		//failures and availability, count up by component
		if (meta{components[c]}.can_fail)
			for (i=0; i<meta{components[c]}.number; i++)
			{
				//total failures
				results{components[c] + '_total_failures'}[realization] += meta{components[c]}.array[i].cumulative_failures;
				//failures by type
				if (num_failure_modes > 1)
					for (j=0; j<num_failure_modes; j++)
						results{components[c] + '_failures_by_type_' + j}[realization] += meta{components[c]}.array[i].failures_by_type[j];
				//availability
				invdl_avail = 1 - (meta{components[c]}.array[i].avail_downtime / (lifetime * annual_daylight_hours));
				results{components[c] + '_availability'}[realization] += invdl_avail;
			}
		
		//mean time between failure
		if (meta{components[c]}.can_fail)
		{
			if (results{components[c] + '_total_failures'}[realization] != 0)
				results{components[c] + '_mtbf'}[realization] = meta{components[c]}.uptime / results{components[c] + '_total_failures'}[realization];
			else
				results{components[c] + '_mtbf'}[realization] = meta{components[c]}.uptime;
		}
			
		//availability
		results{components[c] + '_availability'}[realization] /= meta{components[c]}.number; //we can use a straight average here because the code is constrained to regular systems
	}

	//write the timeseries results for this realization to the global csv files
	dc.timeseries_dc_power = get('dc_net');
	ac.timeseries_ac_power = get('gen');
	deg.daily_degradation = module_degradation_factor;
	csvwrite(results_folder + '/dc_' + realization + '.csv', dc);
	csvwrite(results_folder + '/ac_' + realization + '.csv', ac);
	csvwrite(results_folder + '/deg_' + realization + '.csv', deg);	
	yearly_costs_order = ['year', 'module', 'string', 'combiner', 'inverter', 'disconnect', 'transformer', 'grid', 'tracker', 'total'];
	csvwrite(results_folder + '/costs_' + realization + '.csv', yearly_costs, {cols = yearly_costs_order});
	
	//reset tracking system cost to the original cost for the next realization
	if (is_tracking_system)
		meta.tracker.failure[0].cost = original_tracker_cost;
		
	for (c=0; c<#components; c++)
	outln('Total ' + components[c] + ' failures = ' + results{components[c]+ '_total_failures'}[realization]);
	
	if (show_outputs)
	{
		//daily performance
		if (is_tracking_system)
			dview(5, 24, 'Daily factors', 'DC Equipment Operational', '', 1.0, dc_power_availability, 'AC Equipment Operational', '', 1.0, ac_power_availability, 'Module degradation factor', '', 1.0, module_degradation_factor, 'Power Availability Due to Tracker Outages', '', 1.0, tracker_power_loss_factor, 'Tracker Availability', '', 1.0, tracker_availability);
		else
			dview(3, 24, 'Daily factors', 'DC Equipment Operational', '', 1.0, dc_power_availability, 'AC Equipment Operational', '', 1.0, ac_power_availability, 'Module degradation factor', '', 1.0, module_degradation_factor);

		//lifetime power output
		dview(2, 1, 'Lifetime System Power', 'DC Power', 'kW', 1.0, dc.timeseries_dc_power, 'AC Power', 'kW', 1.0, ac.timeseries_ac_power);
	}
	
	results.lcoe[realization] = get('lcoe_real');
	annual_energy = get('cf_energy_net');
	annual_energy -@ 0; //remove the first element of the cf_energy_net value because it is 0, representing year 0
	cumulative_ac_energy = cumulative_energy(annual_energy);
	for (i=1; i<=#annual_energy; i++)
	{
		results{'annual_ac_energy_' + i}[realization] = annual_energy[i-1]; //we want year names to be 1-indexed, but the arrays holding the data are 0-indexed
		results{'cumulative_ac_energy_' + i}[realization] = cumulative_ac_energy[i-1];
		outln(results);
	}
	
	dc_energy = dc_energy_from_timeseries(dc.timeseries_dc_power, system_lifetime_yrs);
	for (i=0; i<#dc_energy; i++)
	{
		string = 'dc_energy_' + (i+1);
		results{string}[realization] = dc_energy[i];
	}
	
	//overwrite component data containers for memory management
	meta.module.array = null;
	meta.string.array = null;
	meta.combiner.array = null;
	meta.inverter.array = null;
	meta.disconnect.array = null;
	meta.transformer.array = null;
	meta.grid.array = null;
	trackers = null;
	costs = null;
	
	//return results;
}


//********************************************************************************************************************************************************************************
// MAIN FUNCTION TO EXECUTE THE PVRPM ALGORITHM
//********************************************************************************************************************************************************************************

function pvrpm_exec()
{
	// Run the base case simulation- no system failures-------------------------------------------------------------------------------------------------------
	pb = progressbar( {title='Simulation progress', message='Running base case simulation',cancelbutton=true, time=true, max=system_lifetime_yrs * 365});
	
	//disable the lifetime daily losses
	set('en_dc_lifetime_losses', 0);
	set('en_ac_lifetime_losses', 0);
	
	//set zero O&M costs if they're being overwritten
	if (existing_costs == null)
		set('om_fixed', [0]);
	
	//need to set nominal degradation for the base case scenario
	degrad = alloc(system_lifetime_yrs * 365);
	for (day=0; day < system_lifetime_yrs * 365; day++)
		degrad[day] = (1 - current_degradation_rate(meta.module.degradation.rate / 365, day)) * 100;
	set('en_dc_lifetime_losses', 1);
	set('dc_lifetime_losses', degrad);
	
	//simulate the base case scenario
	if (!simulate())
	{	
		msgbox('Error: base case simulation failed.');
		exit;
	}

	//output the results that we care about from the base case simulation before we overwrite them
	global results = null;
	lifetime = get('analysis_period');
	results.row[0] = 'Base Case';
	results.lcoe[0] = get('lcoe_real');
	//ac energy
	base_annual_energy = get('cf_energy_net');
	base_annual_energy -@ 0; //remove the first element from cf_energy_net because it is always 0, representing year 0
	cumulative_ac_energy = cumulative_energy(base_annual_energy);
	for (j=1; j<=lifetime; j++) //start at 1 so that we can number the years starting at 1
	{
		results{'annual_ac_energy_' + j}[0] = base_annual_energy[j-1]; // we want the labels to be 1-indexed, but the data is 0-indexed
		results{'cumulative_ac_energy_' + j}[0] = cumulative_ac_energy[j-1]; 
	}
	
	//dc energy
	timeseries_dc_power = get('dc_net');
	dc_energy = dc_energy_from_timeseries(timeseries_dc_power, system_lifetime_yrs);
	for (i=0; i<#dc_energy; i++)
	{
		string = 'dc_energy_' + (i+1);
		results{string}[0] = dc_energy[i];
	}

	//need the number of daylight hours for each day of the year in order to calculate availability. pull those from the base case.
	sunup = get('sunup');
	idx = 0;
	daylight_hours = alloc (365); //this does not need to be a global variable because it will only be used in non-mutable context (right side of equations)
	annual_daylight_hours = 0;
	for(d=0; d<365; d++)
	{
		daylight_today = 0;
		for(h=0; h<24; h++)
		{
			if (sunup[idx] == 1) //0 sun is down, 1 sun is up, 2 surnise, 3 sunset. For now we have decided NOT to include sunrise/sunset hours.
			{
				daylight_today++;
				annual_daylight_hours++;
			}
			idx++;
		}
		daylight_hours[d] = daylight_today;
	}


	//********************************************************************************************************************************************************************************
	// RUN THE SYSTEM REALIZATIONS
	//********************************************************************************************************************************************************************************
	for (i=1; i<=num_realizations; i++)
	{
		run_system_realization(i, show_realization_graphs); //changing the second parameter will show or hide graphs from each iteration
		outln('Completed realization ' + i); //number the realizations starting at 1
	}


	//********************************************************************************************************************************************************************************
	// CALCULATE STATISTICS AND WRITE RESULTS
	//********************************************************************************************************************************************************************************

	//Calculate statistics
	progressbar(pb, {message='Calculating statistics...'});	
	results_columns = @results;
	xl = xl_create(xl_path); //open the Excel file used for confidence interval calculations (below)- open outside of the loop for speed considerations
	for (c=0; c<#results_columns; c++)
	{
		if (results_columns[c] == 'row')
			continue;
		current_row = num_realizations + 1; //start at the end of the individual realization results for each column
		array = results{results_columns[c]};
		array -@ 0; //get rid of first item because it is the base case scenario
		
		//calculate minimum
		array_min = min(array);
		results.row[current_row] = 'min';
		results{results_columns[c]}[current_row] = array_min;
		current_row++;
		
		//calculate maximum
		array_max = max(array);
		results.row[current_row] = 'max';
		results{results_columns[c]}[current_row] = array_max;
		current_row++;
		
		//calculate mean
		array_mean = mean(array);
		results.row[current_row] = 'mean';
		results{results_columns[c]}[current_row] = array_mean;
		current_row++;
		
		//calculate median
		array_median = median(array);
		results.row[current_row] = 'median';
		results{results_columns[c]}[current_row] = array_median;
		current_row++;
		
		//calculate standard deviation
		array_std = stddev(array);
		results.row[current_row] = 'stddev';
		results{results_columns[c]}[current_row] = array_std;
		current_row++;
		
		//calculate the confidence interval using the included excel file
		interval = 1 - conf_interval / 100;
		xl_set(xl, interval, 'desired_interval');
		xl_set(xl, #array, 'num_samples');
		xl_set(xl, array_std, 'stddev');
		conf_int = to_real(xl_get(xl, 'conf_int'));
		results.row[current_row] = to_string(conf_interval) + '% Lower Conf Int of Mean';
		if (array_std == 0)
			results{results_columns[c]}[current_row] = 'N/A';
		else
			results{results_columns[c]}[current_row] = array_mean - conf_int;
		current_row++;
		results.row[current_row] = to_string(conf_interval) + '% Upper Conf Int of Mean';
		if (array_std == 0)
			results{results_columns[c]}[current_row] = 'N/A';
		else
			results{results_columns[c]}[current_row] = array_mean + conf_int;
		current_row++;
		
		//calculate desired PXX
		//first, sort the results smallest to largest
		for (i=0; i<num_realizations-1; i++)
		{
			//start at the current spot in the output
			smallest = i;
			for (j=i+1; j<num_realizations; j++) //find the index of the smallest number in the remaining range
				if (array[j] < array[smallest])
					smallest = j; 
			//swap the spots of the current i and the smallest number
			if (smallest != i)
			{
				array_temp = array[i];
				array[i] = array[smallest];
				array[smallest] = array_temp;	
			}			
		}
		//then, calculate the PXX by linearly interpolating between the point below and point above
		//point x0, y0 is the lower CDF value and corresponding result, respectively
		//point x1, y1 is the next highest CDF value and corresponding result, respectively
		//x is the desired CDF (calculated from the p-value)
		//y is the result corresponding to x
		//P90n = mean - (1.282 * stdDev); normal P90, maybe include later???
		x = 1 - p_value / 100; //calculate the CDF corresponding to the given p-value: ex: a p-value of 90 would have a corresponding CDF of 0.1
		idx0 = floor(x * num_realizations + 0.001) - 1; //subtract 1 from the calculated index because arrays are 0-indexed, the +0.001 is to avoid problems with the representation of double precision numbers
		idx1 = idx0 + 1;
		x0 = (idx0 + 1) * 1 / num_realizations;
		y0 = array[idx0];
		x1 = (idx1 + 1) * 1 / num_realizations;
		y1 = array[idx1];
		array_p = y0 + (x-x0) * (y1-y0) / (x1-x0); //see linear interpolation formula from https://en.wikipedia.org/wiki/Linear_interpolation*/
		results.row[current_row] = 'P' + p_value;
		results{results_columns[c]}[current_row] = array_p;
		current_row++; //in case we add more calculated variables later
		
	}
	xl_close(xl); //close the confidence interval Excel file now that we're done with it
	xl_free(xl);

	//write the output file- need to do something a little funky to make the columns show up in the right order
	component_order = ['module', 'string', 'combiner', 'inverter', 'disconnect', 'transformer', 'grid'];
	if (is_tracking_system) component_order[7] = 'tracker';

	component_columns = ['total_failures', 'mtbf', 'availability'];

	column_order = ['row', 'lcoe'];
	idx = 2;

	//component results
	for (c=0; c<#component_order; c++) //cth component
	{
		//first list failures for each individual failure mode
		num_failure_modes = #meta{component_order[c]}.failure;
		if (num_failure_modes > 1)
			for (i=0; i<num_failure_modes; i++)
			{
				column_order[idx] = component_order[c] + '_failures_by_type_' + i;
				idx++;
			}
		
		//then list the outputs that are present for each component
		for (i=0; i<#component_columns; i++)
		{
			column_order[idx] = component_order[c] + '_' + component_columns[i];
			idx++;
		}
	}

	//annual AC energy results
	for (j=1; j<=lifetime; j++)
	{
		column_order[idx] = 'annual_ac_energy_' + j;
		idx++;
	}
	
	//cumulative annual AC energy results
	for (j=1; j<=lifetime; j++)
	{
		column_order[idx] = 'cumulative_ac_energy_' + j;
		idx++;
	}
	
	//dc annual energy results
	for (j=1; j<=lifetime; j++)
	{
		column_order[idx] = 'dc_energy_' + j;
		idx++;
	}

	if (#column_order != #results_columns)
		msgbox('Not all results columns have been specified in the column order for the Results Summary CSV. This will result in the Results Summary columns being out of order.');


	//Results Summary
	if (!csvwrite(results_folder + '/PVRPM_Summary_Results.csv', results, {cols=column_order}))
	{
		msgbox('PVRPM Results Summary file is open. Please close the file and then click OK.');
		csvwrite(results_folder + '/PVRPM_Summary_Results.csv', results, {cols=column_order});
	}

	//DC Timeseries
	csv_dc_power = null;
	for (i=1; i<=num_realizations; i++)
	{
		x = csvread(results_folder + '/dc_' + i + '.csv', {table=true});
		csv_dc_power{'realization_' + i} = x.timeseries_dc_power;
		remove_file(results_folder + '/dc_' + i + '.csv');
	}
	if (!csvwrite(results_folder + '/Timeseries_DC_Power.csv', csv_dc_power))
	{
		msgbox('Timeseries DC Power file is open. Please close the file and then click OK.');
		csvwrite(results_folder + '/Timeseries_DC_Power.csv', csv_dc_power);
	}

	//AC Timeseries
	csv_ac_power = null;
	for (i=1; i<=num_realizations; i++)
	{
		x = csvread(results_folder + '/ac_' + i + '.csv', {table=true});
		csv_ac_power{'realization_' + i} = x.timeseries_ac_power;
		remove_file(results_folder + '/ac_' + i + '.csv');
		
	}
	if (!csvwrite(results_folder + '/Timeseries_AC_Power.csv', csv_ac_power))
	{
		msgbox('Timeseries AC Power file is open. Please close the file and then click OK.');
		csvwrite(results_folder + '/Timeseries_AC_Power.csv', csv_ac_power);
	}

	//Degradation Timeseries
	csv_degradation = null;
	for (i=1; i<=num_realizations; i++)
	{
		x = csvread(results_folder + '/deg_' + i + '.csv', {table=true});
		csv_degradation{'realization_' + i} = x.daily_degradation;
		remove_file(results_folder + '/deg_' + i + '.csv');
	}
	if (!csvwrite(results_folder + '/Daily_Degradation.csv', csv_degradation))
	{
		msgbox('Degradation file is open. Please close the file and then click OK.');
		csvwrite(results_folder + '/Daily_Degradation.csv', csv_degradation);
	}
	
	//Costs CSVs
	fOut = open(results_folder + '/Yearly_Costs_By_Component.csv', 'w');
	for (i=1; i<=num_realizations; i++)
	{
		write_line(fOut, 'Realization ' + i);
		fIn = open(results_folder + '/costs_' + i + '.csv', 'r');
		x = '';
		while (read_line(fIn, x))
			write_line(fOut, x);
		close(fIn);
		remove_file(results_folder + '/costs_' + i + '.csv');
		write_line(fOut, '');
	}
	close(fOut);
	
	progressbar(pb);

}
