//*************************************************************************************
//Module Reliability Model -- DRAFT --
//jmf 5/8/16
//*************************************************************************************

// TO DO-----------------------------------------------------------------------------------
/*
	Terminology: replacement versus repair
	Module failures: Replacement versus repair? How to tell? How affecting warranty? How affecting next failure time? etc.
	Don't allow negative time setting for failure times
	Error checking on arrays 
	Set active case and error check
	Get system lifetime from financial case, OR set it if no financials (or LCOE?)
	HOW DOES DC DERATE WORK- YEAR 1 VERSUS OTHER YEARS? Right now this will crash if run for >1 year, I think...
	DC Derate needs to be expanded to include lifetime mode in SSC as well
	DC derate needs to be added to loss tree
	Currently running daily, do we need to change that? If so, how?
	TRANSLATE TO HOURLY---------------------
*/

// SYSTEM INPUTS-----------------------------------------------------------------------
//WHY DO THESE WORK IF THEY'RE NOT GLOBAL?? BECAUSE THEY'RE ASSIGNED UP HERE AND NOT IN THE FUNCTION? SO WHY DO I HAVE TO ASSIGN GLOBAL THINGS UP HERE? HELP!!!!!!!!!
	num_modules = get('total_modules'); //9408;
	num_modules_per_string = get('modules_per_string'); //14
	num_strings = get('strings_in_parallel'); //672
	num_combiners = get('inverter_count'); //8
	num_strings_per_combiner = num_strings / num_combiners; //THIS IS NOT NECESSARILY AN INTEGER, NEED TO ERROR CHECK THIS!!!!!!!!!!!!!!!!
	system_lifetime_yrs = 1;

// MODULE RELIABILITY INPUTS-----------------------------------------------------------
	// failure mode 1: defective component
	module_defective_distribution = 'exponential';
	module_percentage_defective_percent = 20;
	module_defective_failures_per_yr = 0.5;
	// failure mode 2: failure
	module_failure_distribution = 'normal';
	module_failure_mean_yrs = 35;
	module_failure_std_yrs = 8;
	// repair time
	module_repair_distribution = 'lognormal';
	module_repair_mean_days = 45; //says 60 in pseudo code but is currently 45 in Goldsim
	module_repair_std_days = 15; //says 20 in pseudo code but is currently 15 in Goldsim
	// warranty period
	module_warranty_yrs = 20;
	
// STRING RELIABILITY INPUTS------------------------------------------------------------
	// failure mode 1
	string_failure_distribution = 'exponential';
	string_failures_per_yr = 0.1;
	// repair time
	string_repair_distribution = 'lognormal';
	string_repair_mean_days = 10; //HAD TO CHANGE THESE DUE TO LIMITATIONS IN THE NUMBERS THE LHS CODE WILL ACCEPT!!!!!!!!!!!!!!!!!!
	string_repair_std_days = 5; //SAME AS ABOVE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
// COMBINER RELIABILITY INPUTS----------------------------------------------------------
	// failure mode 1
	combiner_failure_distribution = 'lognormal';
	combiner_failure_mean_yrs = 5.4;
	combiner_failure_std_yrs = 1.9;
	// repair time
	combiner_repair_distribution = 'exponential';
	combiner_repair_mean_days = 5;
	
//GLOBAL STRUCTURES---------------------------------------------------------------------------
//Arrays to hold component information, failure times, and replacement times
	// Modules
	global modules = alloc(num_modules);
	global module_replacement_times = null;
	global module_failure_times = null;
	global module_defective_failure_times = null;
	// Strings
	global strings = alloc(num_strings);
	global string_failure_times = null;
	global string_repair_times = null;
	// Combiner Boxes
	global combiners = alloc(num_combiners);
	global combiner_failure_times = null;
	global combiner_repair_times = null;

//Conversions of inputs to days
	// Modules
	global module_warranty_days = module_warranty_yrs * 365;
	global module_failure_mean_days = module_failure_mean_yrs * 365;
	global module_failure_std_days = module_failure_std_yrs * 365;
	global module_defective_failures_per_day = module_defective_failures_per_yr / 365;
	// Strings
	global string_failures_per_day = string_failures_per_yr / 365;
	// Combiners
	global combiner_failure_mean_days = combiner_failure_mean_yrs * 365;
	global combiner_failure_std_days = combiner_failure_std_yrs * 365;
	
//DATA CONTAINERS------------------------------------------------------------------------------
//Data is only stored for the current timestep.

// MODULE INFORMATION
/*
state = operational (1) or failed (0)
defective = flag for whether or not this module has a defect.
	If true, then the module is also eligible for the defective failure mode
time_to_replacement = number of days from onset of failure until it is replaced
time_to_failure = number of days left until that module fails
cumulative_failures = total number of failures for that module
cumul_oow_failures = total number of failures out of warranty for that module
*/

// STRING INFORMATION
/*
state = operational (1) or failed (0)
time_to_failure = number of days left until the string fails
time_to_repair = number of days from onset of failure until it is repaired
cumulative_failures = total number of failures for that string
*/

// DC COMBINER INFORMATION
/*
state = operational (1) or failed (0)
time_to_failure = number of days left until the combiner fails
time_to_repair = number of days from onset of failure until it is repaired
cumulative_failures = total number of failures for that combiner
*/

//*************************************************************************************
// SUPPORTING FUNCTIONS
//*************************************************************************************
/* 	LHS performs Latin Hypercube Sampling given a distribution type, distribution parameters,
	and a number of samples. The name parameter allows a more helpful error message.
	Returns an array of the calculated samples.*/
function LHS(name, distribution_type, parameters, num_samples)
{
	lhs = lhs_create();
	lhs_dist(lhs, 'x', distribution_type, parameters);
	if (!lhs_run(lhs, num_samples))
	{
		msgbox('Latin Hypercube Sampling failed for: ' + name + ': ' + lhs_error(lhs));
		exit;
	}
	result = lhs_vector(lhs, 'x');
	lhs_free(lhs);
	return result;
}

//*************************************************************************************
// INITIALIZATION AND FAILURE FUNCTIONS
//*************************************************************************************
//MODULE INITIALIZATION------------------------------------------------------------------------------
// Initializes a single module "m" in the modules list
// If initializing for the first time, "time_is_zero" is true so that cumulative failures is set to zero
// To be used at the beginning or when a module is replaced
function initialize_module(m, time_is_zero)
{
	// Module state
	modules[m].state = 1; //module is operational
	
	// Module failures
	// cumulative failures and OOW failures initialized to zero at time zero only
	if (time_is_zero)
	{
		modules[m].cumulative_failures = 0;
		modules[m].cumul_oow_failures = 0;
	}
	
	// Module failure mode 2: normal failure
	// Start with this failure mode because it exists for ALL modules
	modules[m].time_to_failure = module_failure_times[0]; //assign failure time
	module_failure_times -@ 0; //remove the failure time that was just used
	if (#module_failure_times <=0)
			module_failure_times = LHS('module_failure', module_failure_distribution, [module_failure_mean_days, module_failure_std_days], num_modules*10);

	
	// Module failure mode 1: defective modules
	modules[m].defective = rand() < (module_percentage_defective_percent / 100); //randomly assign a given % of modules to be defective
	// If the module is defective, check the defective failure time against the normal failure time
	if (modules[m].defective)
	{	
		defective_time = module_defective_failure_times[0]; //defective failure time for that module
		module_defective_failure_times -@ 0; //remove the defective failure time that was just used
		if (#module_defective_failure_times <=0)
			module_defective_failure_times = LHS('module_defective_failure', module_defective_distribution, [module_defective_failures_per_day], num_modules*10);
		if (defective_time < modules[m].time_to_failure) //defective failure occurs before normal failure
			modules[m].time_to_failure = defective_time;
	}
	
	// Module time to replacement in case of failure
	modules[m].time_to_replacement = module_replacement_times[0];
	module_replacement_times -@ 0; //remove the replacement time that was just used
	if (#module_replacement_times <=0)
		module_replacement_times = LHS('module_replacement_times', module_repair_distribution, [module_repair_mean_days, module_repair_std_days], num_modules*20);
}

function initialize_string(s, time_is_zero)
{
	// String state
	strings[s].state = 1; //string is operational
	
	// String failures
	//cumulative failures initialized to zero at time zero only
	if (time_is_zero)
		strings[s].cumulative_failures = 0;
		
	// String failure mode 1
	strings[s].time_to_failure = string_failure_times[0]; //assign failure time
	string_failure_times -@ 0; //remove the failure time that was just used
	if (#string_failure_times <=0)
		string_failure_times = LHS('string_failure', string_failure_distribution, [string_failures_per_day], num_strings*10);
		
	// String time to replacement in case of failure
	strings[s].time_to_repair = string_repair_times[0];
	string_repair_times -@ 0; //remove the replacement time that was just used
	if (#string_repair_times <=0)
		string_repair_times = LHS('string_repair_times', string_repair_distribution, [string_repair_mean_days, string_repair_std_days], num_strings*20);
}

function initialize_combiner(c, time_is_zero)
{
	// combiner state
	combiners[c].state = 1; //combiner is operational
	
	// combiner failures
	//cumulative failures initialized to zero at time zero only
	if (time_is_zero)
		combiners[c].cumulative_failures = 0;
		
	// combiner failure mode 1
	combiners[c].time_to_failure = combiner_failure_times[0]; //assign failure time
	combiner_failure_times -@ 0; //remove the failure time that was just used
	if (#combiner_failure_times <=0)
		combiner_failure_times = LHS('combiner_failure', combiner_failure_distribution, [combiner_failure_mean_days, combiner_failure_std_days], num_combiners*10);
		
	// combiner time to replacement in case of failure
	combiners[c].time_to_repair = combiner_repair_times[0];
	combiner_repair_times -@ 0; //remove the replacement time that was just used
	if (#combiner_repair_times <=0)
		combiner_repair_times = LHS('combiner_repair_times', combiner_repair_distribution, [combiner_repair_mean_days], num_combiners*20);
}

//MODULE FAILURE----------------------------------------------------------------------------------------
// Changes module "m" state to failed, current "day" checked against warranty
function module_failure(m, day)
{
	modules[m].state = 0;
	modules[m].time_to_failure = 0;
	modules[m].cumulative_failures++;
	if (day > module_warranty_days)
		modules[m].cumul_oow_failures++;
}

function string_failure(s)
{
	strings[s].state = 0;
	strings[s].time_to_failure = 0;
	strings[s].cumulative_failures++;
}

function combiner_failure(c)
{
	combiners[c].state = 0;
	combiners[c].time_to_failure = 0;
	combiners[c].cumulative_failures++;
}

//SYSTEM INITIALIZATION---------------------------------------------------------------------------------
function initialize()
{
	// Module failure mode 1: defective component
	module_defective_failure_times = LHS('module_defective_failure', module_defective_distribution, [module_defective_failures_per_day], num_modules*10);
	
	// Module failure mode 2: failure
	module_failure_times = LHS('module_failure', module_failure_distribution, [module_failure_mean_days, module_failure_std_days], num_modules*10);
	
	// Module replacement times
	module_replacement_times = LHS('module_replacement_times', module_repair_distribution, [module_repair_mean_days, module_repair_std_days], num_modules*20);
	
	// String failure mode 1
	string_failure_times = LHS('string_failure', string_failure_distribution, [string_failures_per_day], num_strings*10);
	
	// String repair times
	string_repair_times = LHS('string_repair_times', string_repair_distribution, [string_repair_mean_days, string_repair_std_days], num_strings*20);
	
	// Combiner failure mode 1
	combiner_failure_times = LHS('combiner_failure', combiner_failure_distribution, [combiner_failure_mean_days, combiner_failure_std_days], num_combiners*10);
	
	// Combiner repair times
	combiner_repair_times = LHS('combiner_repair_times', combiner_repair_distribution, [combiner_repair_mean_days], num_combiners*20);
	
	// Create module structures
	for (m = 0; m < num_modules; m++)
		initialize_module(m, true);
		
	// Create string structures
	for (s = 0; s < num_strings; s++)
		initialize_string(s, true);
		
	// Create combiner structures
	for (c = 0; c < num_combiners; c++)
		initialize_combiner(c, true);
}

//*************************************************************************************
// DC DERATE CALCULATION FUNCTION
//*************************************************************************************
function whats_my_dc_derate() 
{
	//note that here, "operational modules" means modules whose power is REACHING the inverter, 
	//regardless of whether the module itself is failed or not
	operational_modules = 0;
	
	for (c=0; c < num_combiners; c++)
	{
		if (combiners[c].state == 0)
			continue; //if the combiner out, none of the modules on that combiner reach the inverter
		for (s=0; s < num_strings_per_combiner; s++)
		{
			if (strings[s].state == 0)
				continue; //if string is out, none of the modules on that combiner reach the inverter
			for (m=0; m < num_modules_per_string; m++)
			{
				// what module index are we at? 
				/* 
				number of combiners we've already looped through * total number modules per combiner +
				number of strings on this combiner we've already looped through * modules per string +
				number of modules that we've passed on this string
				*/
				// because c, s, and m are 0-indexed, they represent how many of each component have been completed by this point
				module_index = c * (num_strings_per_combiner * num_modules_per_string) + s * num_modules_per_string + m;
				if (module_index > num_modules)
				{
					msgbox('Error, calculated module index > number of modules in the dc derate function');
					exit;
				}
				operational_modules += modules[module_index].state; //1 if operating, 0 if failed
			}
		}
	}
		
	return operational_modules / num_modules;
}

//*************************************************************************************
// INCREMENT TIMESTEP FUNCTION
//*************************************************************************************
function step_in_time(day)
{
	// Modules------------------------------------------------------------------
	for (m=0; m < num_modules; m++)
	{
		//module is operational
		if (modules[m].state == 1)
		{
			modules[m].time_to_failure--;
			//module has just failed
			if (modules[m].time_to_failure <= 0)
				module_failure(m, day);
		}
		
		//module is currently failed
		else
		{
			modules[m].time_to_replacement--;
			//module is replaced
			if (modules[m].time_to_replacement <= 0)
				initialize_module(m, false); //initialize a new module without resetting cumulative failures
		}		
	}
	
	// Strings------------------------------------------------------------------
	for (s=0; s < num_strings; s++)
	{
		//string is operational
		if (strings[s].state == 1)
		{	
			strings[s].time_to_failure--;
			//string has just failed
			if (strings[s].time_to_failure <= 0)
				string_failure(s);
		}
		//string is currently failed
		else
		{
			strings[s].time_to_repair--;
			//string is replaced
			if (strings[s].time_to_repair <= 0)
				initialize_string(s, false); //initialize the string without resetting cumulative failures
		}
	}
	
	// Combiners------------------------------------------------------------------
	for (c=0; c < num_combiners; c++)
	{
		//combiner is operational
		if (combiners[c].state == 1)
		{	
			combiners[c].time_to_failure--;
			//combiner has just failed
			if (combiners[c].time_to_failure <= 0)
				combiner_failure(c);
		}
		//combiner is currently failed
		else
		{
			combiners[c].time_to_repair--;
			//combiner is replaced
			if (combiners[c].time_to_repair <= 0)
				initialize_combiner(c, false); //initialize the combiner without resetting cumulative failures
		}
	}
}


//*************************************************************************************
// MAIN SCRIPT
//*************************************************************************************

//allocations for now

dc_availability = null;
total_module_failures = 0;
total_string_failures = 0;
total_combiner_failures = 0;

//timestep 0
initialize();
dc_availability[0] = whats_my_dc_derate() * 100;
//outln('0\t' + modules);

//rest of system lifetime
for (day = 1; day < system_lifetime_yrs * 365; day++)
{
	step_in_time(day);
	dc_availability[day] = whats_my_dc_derate() * 100;
	//outln(day + '\t' + modules);
}

//count up cumulative failures
for (m=0; m < num_modules; m++)
	total_module_failures += modules[m].cumulative_failures;
for (s=0; s < num_strings; s++)
	total_string_failures += strings[s].cumulative_failures;
for (c=0; c < num_combiners; c++)
	total_combiner_failures += combiners[c].cumulative_failures;
	
//create SAM performance adjustment table for the dc availability derate
hourly_loss = alloc(8760);
idx = 0;
day_num = alloc(365);
for (day = 0; day < 365; day++)
{
	day_num[day] = day;
	for (j = 0; j < 24; j++)
	{
		hourly_loss[idx] = 100 - dc_availability[day];
		idx++;
	}
}
//outln(hourly_loss);
adjust.constant = 0;
adjust.en_hourly = 1;
adjust.hourly = hourly_loss;
adjust.en_periods = 0;
set('dc_adjust', adjust);

//run PV performance model- for now running the currently active case
messages = '';
success = simulate(messages, true);
if (!success)
	msgbox('Simulation failed.' + messages);
	
show_page('Results');

//Test outputs
//outln(dc_availability);
outln('Total module failures =' + total_module_failures);
outln('Total string failures =' + total_string_failures);
outln('Total combiner failures =' + total_combiner_failures);

newplot();
plot(day_num, dc_availability, {'type'='line'});
plotopt({'title'='DC Availability'});
axis('x1', {'label'='Day'});
axis('y1', {'label'='% Operational'});






































