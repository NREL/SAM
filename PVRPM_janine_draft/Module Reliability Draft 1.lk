//*************************************************************************************
//Module Reliability Model -- DRAFT --
//jmf 6/16/16
//*************************************************************************************

// TO DO-----------------------------------------------------------------------------------
/*
	Don't allow negative time setting for failure times
	Error checking on arrays 
	Set active case and error check
	Get system lifetime from financial case, OR set it if no financials (or LCOE?)
	HOW DOES DC DERATE WORK- YEAR 1 VERSUS OTHER YEARS? Right now this will crash if run for >1 year, I think...
	DC Derate needs to be expanded to include lifetime mode in SSC as well
	DC derate needs to be added to loss tree
	Currently running daily, do we need to change that? If so, how?
	TRANSLATE TO HOURLY---------------------
	replace "array" with "vector" to avoid confusion
	replace "num_etc" with component.number
	add keeping track of failure modes by type
	Right now, we can only handle regularly set up systems (same mod/string, string/inv, etc for the whole system)
*/

//*************************************************************************************
// INPUTS
//*************************************************************************************

// SYSTEM INPUTS-----------------------------------------------------------------------
//WHY DO THESE WORK IF THEY'RE NOT GLOBAL?? BECAUSE THEY'RE ASSIGNED UP HERE AND NOT IN THE FUNCTION? SO WHY DO I HAVE TO ASSIGN GLOBAL THINGS UP HERE? HELP!!!!!!!!!
	num_modules = get('total_modules'); //9408;
	num_modules_per_string = get('modules_per_string'); //14
	num_strings = get('strings_in_parallel'); //672
	num_inverters = get('inverter_count');
	num_combiners = get('inverter_count') * 2; //48 //NEED TO UPDATE THIS ASSUMPTION- MAKE IT AN INPUT AND ERROR CHECK IT
	num_strings_per_combiner = num_strings / num_combiners; //THIS IS NOT NECESSARILY AN INTEGER, NEED TO ERROR CHECK THIS!!!!!!!!!!!!!!!!
	system_lifetime_yrs = 1;

// MODULE RELIABILITY INPUTS-----------------------------------------------------------
	// failure mode 1: defective component
	module_defective_distribution = 'exponential';
	module_percentage_defective_percent = 20;
	module_defective_failures_per_yr = 0.5;
	// failure mode 2: failure
	module_failure_distribution = 'normal';
	module_failure_mean_yrs = 35;
	module_failure_std_yrs = 8;
	// repair time
	module_repair_distribution = 'lognormal';
	module_repair_mean_days = 45; //says 60 in pseudo code but is currently 45 in Goldsim
	module_repair_std_days = 15; //1.9713; //says 20 in pseudo code but is currently 15 in Goldsim, using the %kurtosis from the input box in Goldsim because that seems to match the best!!!!!!!
	// warranty period
	module_warranty_yrs = 20;
	
// STRING RELIABILITY INPUTS------------------------------------------------------------
	// failure mode 1
	string_failure_distribution = 'exponential';
	string_failures_per_yr = 0.1;
	// repair time
	string_repair_distribution = 'normal'; //'lognormal';//SHOULD BE LOGNORMAL N BUT THAT DOESN'T SEEM TO AGREE WITH GOLDSIM!!!!!!
	string_repair_mean_days = 10; //HAD TO CHANGE THESE DUE TO LIMITATIONS IN THE NUMBERS THE LHS CODE WILL ACCEPT!!!!!!!!!!!!!!!!!!
	string_repair_std_days = 5; //SAME AS ABOVE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
	
// COMBINER RELIABILITY INPUTS----------------------------------------------------------
	// failure mode 1
	combiner_failure_distribution = 'uniform';
	combiner_failure_min_days = 150; //1131;
	combiner_failure_max_days = 200; //2148;
	// repair time
	combiner_repair_distribution = 'exponential';
	combiner_repair_mean_days = 5;

// INVERTER RELIABILITY INPUTS----------------------------------------------------------
	//failure mode 1: component failure
	inverter_component_failure_distribution = 'exponential';
	inverter_component_failures_per_yr = 0.2;
	//failure mode 2: routine failure
	inverter_routine_failure_distribution = 'exponential';
	inverter_routine_failures_per_yr = 1;
	//failure mode 3: catastrophic failure
	inverter_catastrophic_distribution = 'normal';
	inverter_catastrophic_mean_days = 3652.5;
	inverter_catastrophic_std_days = 365.2;
	// repair time
	inverter_repair_distribution = 'lognormal';
	inverter_repair_mean_days = 1.75;
	inverter_repair_std_days = 1.62;
	


//*************************************************************************************
// DATA CONTAINERS
//*************************************************************************************

// COMPONENT META DATA CONTAINER----------------------------------------------------------
// contains information about a component type in the system
/*
number = number of that type of component in the system
warranty
	bool = true if the component has a warranty, otherwise false
	days = number of days that the warranty is for (e.g. a 20 year warranty would be 20 * 365 days)
failure[i]
	distribution = distribution type of failure mode i
	parameters = a table of parameters for failure mode i (e.g. [45, 15] )
	times = a vector of failure times for failure mode i
defective
	bool = true if the component also has defective failures, otherwise false
	fraction = fraction of that type of component that are defective
	distribution = distribution of defective failure mode
	parameters = parameters of defective failure mode
	times = a vector of defective failure times
repair
	distribution = distribution type of repair times
	parameters = parameters of the repair distribution
	times = a vector of repair times
*/

// INDIVIDUAL COMPONENT DATA CONTAINER-------------------------------------------------------
// contains current timestep data for a single component in the system
/*
state = operational (1) or failed (0)
defective = flag for whether or not this component has a defect.
	If true, then the component is also eligible for the defective failure mode
time_to_failure = number of days left until the component fails
time_to_repair = number of days from onset of failure until component is repaired
cumulative_failures = total number of failures for that component
cumulative_oow_failures = total number of failures out of warranty for that component if applicable
*/

//SET UP DATA CONTAINERS----------------------------------------------------------------------
	// Modules
	global modules = alloc(num_modules);
	global module_meta = null;
	module_meta.number = num_modules;
	module_meta.warranty.bool = true;
	module_meta.warranty.days = module_warranty_yrs * 365;
	module_meta.failure[0].distribution = module_failure_distribution;
	module_meta.failure[0].parameters = [module_failure_mean_yrs * 365, module_failure_std_yrs * 365];
	module_meta.failure[0].times = null;
	module_meta.defective.bool = true;
	module_meta.defective.fraction = module_percentage_defective_percent / 100;
	module_meta.defective.distribution = module_defective_distribution;
	module_meta.defective.parameters = [module_defective_failures_per_yr / 365];
	module_meta.defective.times = null;
	module_meta.repair.distribution = module_repair_distribution;
	module_meta.repair.parameters =  [module_repair_mean_days, module_repair_std_days];
	module_meta.repair.times = null;
	
	// Strings
	global strings = alloc(num_strings);
	global string_meta = null;
	string_meta.number = num_strings;
	string_meta.warranty.bool = false;
	string_meta.warranty.days = 0;
	string_meta.failure[0].distribution = string_failure_distribution;
	string_meta.failure[0].parameters = [(string_failures_per_yr / 365)];
	string_meta.failure[0].times = null;
	string_meta.defective.bool = false;
	string_meta.repair.distribution = string_repair_distribution;
	string_meta.repair.parameters = [string_repair_mean_days, string_repair_std_days];
	string_meta.repair.times = null;
	
	// Combiners
	global combiners = alloc(num_combiners);
	global combiner_meta = null;
	combiner_meta.number = num_combiners;
	combiner_meta.warranty.bool = false;
	combiner_meta.warranty.days = 0;
	combiner_meta.failure[0].distribution = combiner_failure_distribution;
	combiner_meta.failure[0].parameters = [combiner_failure_min_days, combiner_failure_max_days];
	combiner_meta.failure[0].times = null;
	combiner_meta.defective.bool = false;
	combiner_meta.repair.distribution = combiner_repair_distribution;
	combiner_meta.repair.parameters = [combiner_repair_mean_days];
	combiner_meta.repair.times = null;
	
	// Inverters
	global inverters = alloc(num_inverters);
	global inverter_meta = null;
	inverter_meta.number = num_inverters;
	inverter_meta.warranty.bool = false; //THIS IS ALMOST DEFINITELY GOING TO BE TRUE WHEN WE MODIFY THE INPUTS, BUT NOTHING IN PSEUDOCODE
	inverter_meta.warranty.days = 0;
	inverter_meta.failure[0].distribution = inverter_component_failure_distribution;
	inverter_meta.failure[0].parameters = [inverter_component_failures_per_yr / 365];
	inverter_meta.failure[0].times = null;
	inverter_meta.failure[1].distribution = inverter_routine_failure_distribution;
	inverter_meta.failure[1].parameters = [inverter_routine_failures_per_yr / 365];
	inverter_meta.failure[1].times = null;
	inverter_meta.failure[2].distribution = inverter_catastrophic_distribution;
	inverter_meta.failure[2].parameters = [inverter_catastrophic_mean_days, inverter_catastrophic_std_days];
	inverter_meta.failure[2].times = null;
	inverter_meta.defective.bool = false;
	inverter_meta.repair.distribution = inverter_repair_distribution;
	inverter_meta.repair.parameters = [inverter_repair_mean_days, inverter_repair_std_days];
	inverter_meta.repair.times = null;


//*************************************************************************************
// SUPPORTING FUNCTIONS
//*************************************************************************************
/* 	LHS performs Latin Hypercube Sampling given a distribution type, distribution parameters,
	and a number of samples. The name parameter allows a more helpful error message.
	Returns an array of the calculated samples.*/
function LHS(name, distribution_type, parameters, num_samples)
{
	lhs = lhs_create();
	lhs_dist(lhs, 'x', distribution_type, parameters);
	if (!lhs_run(lhs, num_samples))
	{
		msgbox('Latin Hypercube Sampling failed for: ' + name + ': ' + lhs_error(lhs));
		exit;
	}
	result = lhs_vector(lhs, 'x');
	lhs_free(lhs);
	return result;
}

//*************************************************************************************
// COMPONENT FUNCTIONS
//*************************************************************************************

//INITIALIZATION------------------------------------------------------------------------------
// Used to set up a component for the first time or to renew the values when the component is repaired
// Initializes a single component "component_idx" in the "component_array"
// "Component_meta" stores the failure and repair information for that type of component
// If initializing a component for the first time, "bool_time_is_zero" is true
// If initializing due to a repair, "bool_time_is_zero" is false

function initialize_component(component_meta, component_array, component_idx, bool_time_is_zero)
{
	// Component state
	component_array[component_idx].state = 1; //component is operational
	
	// Component failures and repairs
	if (bool_time_is_zero)
	{
		// cumulative failures and OOW failures initialized to zero at time zero only
		//HOW DO I KEEP TRACK OF FAILURES BY FAILURE TYPE??? DO I DO IT WHEN I CALCULATE TIMES??
		component_array[component_idx].cumulative_failures = 0;
		component_array[component_idx].cumulative_oow_failures = 0;
	}
	
	// Loop through all failure modes to determine failure times
	num_failure_modes = #component_meta.failure;
	for (j = 0; j < num_failure_modes; j++)
	{
		if (component_meta.failure[j].times == null || #component_meta.failure[j].times <= 0) //null on initialization of very first component, less than zero when you've used up the pre-calculated vector
			component_meta.failure[j].times = LHS(to_string(component_meta.failure[j].times), component_meta.failure[j].distribution, component_meta.failure[j].parameters, (#component_array * 10));
		possible_failure_times[j] = component_meta.failure[j].times[0]; //assign a failure time
		component_meta.failure[j].times -@ 0; //remove the failure time that was just used
	}
	// Because all failure modes are hard failures (no partial failures), pick whichever failure mode will occur first
	component_array[component_idx].time_to_failure = min(possible_failure_times);
	
	// Defective component
	if (component_meta.defective.bool)
	{
		component_array[component_idx].defective = rand() < component_meta.defective.fraction; //randomly assign a given fraction of components to be defective
		// If the component is defective, check the defective failure time against the previously assigned failure time
		if (component_array[component_idx].defective)
		{	
			if (component_meta.defective.times == null || #component_meta.defective.times <= 0) //null on initialization of very first component, less than zero when you've used up the pre-calculated vector
				component_meta.defective.times = LHS(to_string(component_meta.defective.times), component_meta.defective.distribution, component_meta.defective.parameters, (#component_array * 10));
			defective_failure_time = component_meta.defective.times[0]; //assign a failure time
			component_meta.defective.times -@ 0; //remove the failure time that was just used
			if (defective_failure_time < component_array[component_idx].time_to_failure) //defective failure occurs before normal failure
				component_array[component_idx].time_to_failure = defective_failure_time;
		}
	}
			
	// Time to replacement or repair in case of failure
	if (component_meta.repair.times == null || #component_meta.repair.times <= 0) //null on initialization of very first component, less than zero when you've used up the array
		component_meta.repair.times = LHS(to_string(component_meta.repair.times), component_meta.repair.distribution, component_meta.repair.parameters, (#component_array * 10));
	component_array[component_idx].time_to_repair = component_meta.repair.times[0];
	component_meta.repair.times -@ 0; //remove the repair time that was just used
}

//COMPONENT FAILURE----------------------------------------------------------------------------------------
// Used to change a component's state from operational to failed
// Changes "component_idx" in the array "component" state to failed and increments failures
// Checks current "day" against warranty if bool_warranty is true

function component_failure(component_array, component_idx, day, bool_warranty, warranty_length_days)
{
	component_array[component_idx].state = 0;
	component_array[component_idx].time_to_failure = 0;
	component_array[component_idx].cumulative_failures++;
	if (bool_warranty && day > warranty_length_days)
		component_array[component_idx].cumul_oow_failures++;
}

//*************************************************************************************
// SYSTEM FUNCTIONS
//*************************************************************************************

//SYSTEM INITIALIZATION---------------------------------------------------------------------------------
function initialize()
{
	// Create module structures
	for (m = 0; m < num_modules; m++)
		initialize_component(module_meta, modules, m, true);
		
	// Create string structures
	for (s = 0; s < num_strings; s++)
		initialize_component(string_meta, strings, s, true);
		
	// Create combiner structures
	for (c = 0; c < num_combiners; c++)
		initialize_component(combiner_meta, combiners, c, true);
		
	// Create inverter structures
	for (i = 0; i < num_inverters; i++)
		initialize_component(inverter_meta, inverters, i, true);
}

// DC DERATE CALCULATION FUNCTION------------------------------------------------------------------------
function whats_my_dc_derate() 
{
	//note that here, "operational modules" means modules whose power is REACHING the inverter, 
	//regardless of whether the module itself is failed or not
	operational_modules = 0;
	
	for (c=0; c < num_combiners; c++)
	{
		if (combiners[c].state == 0)
			continue; //if the combiner out, none of the modules on that combiner reach the inverter
		for (s=0; s < num_strings_per_combiner; s++)
		{
			if (strings[s].state == 0)
				continue; //if string is out, none of the modules on that combiner reach the inverter
			for (m=0; m < num_modules_per_string; m++)
			{
				// what module index are we at? 
				/* 
				number of combiners we've already looped through * total number modules per combiner +
				number of strings on this combiner we've already looped through * modules per string +
				number of modules that we've passed on this string
				*/
				// because c, s, and m are 0-indexed, they represent how many of each component have been completed by this point
				module_index = c * (num_strings_per_combiner * num_modules_per_string) + s * num_modules_per_string + m;
				if (module_index > num_modules - 1)
				{
					msgbox('Error, calculated module index > number of modules in the dc derate function');
					exit;
				}
				operational_modules += modules[module_index].state; //1 if operating, 0 if failed
			}
		}
	}
		
	return operational_modules / num_modules;
}

// AC DERATE CALCULATION FUNCTION--------------------------------------------------------------------------
function whats_my_ac_derate()
{
	operational_inverters = 0;
	
	for (i=0; i < num_inverters; i++)
	{
		operational_inverters += inverters[i].state; //1 if operating, 0 if failed
	}
	
	return operational_inverters / num_inverters;
}


// INCREMENT TIMESTEP FUNCTION------------------------------------------------------------------------------
function step_in_time(component_meta, component_array, day)
{
	//loop through number of components
	for (i=0; i < component_meta.number; i++)
	{
		//component is operational
		if (component_array[i].state == 1)
		{
			component_array[i].time_to_failure--;
			//component has just failed
			if (component_array[i].time_to_failure <= 0)
				component_failure(component_array, i, day, component_meta.warranty.bool, component_meta.warranty.days);
		}
		
		//component is currently failed
		else
		{
			component_array[i].time_to_repair--;
			//component is repaired
			if (component_array[i].time_to_repair <= 0)
				initialize_component(component_meta, component_array, i, false); //initialize a new module without resetting cumulative failures
		}		
	}
}


//*************************************************************************************
// MAIN SCRIPT
//*************************************************************************************

//allocations for now

dc_availability = null;
ac_availability = null;
total_module_failures = 0;
total_string_failures = 0;
total_combiner_failures = 0;
total_inverter_failures = 0;

//timestep 0
initialize();
dc_availability[0] = whats_my_dc_derate() * 100;
ac_availability[0] = whats_my_ac_derate() * 100;
//outln('0\t' + modules);

//rest of system lifetime
for (day = 1; day < system_lifetime_yrs * 365; day++)
{
	step_in_time(module_meta, modules, day);
	step_in_time(string_meta, strings, day);
	step_in_time(combiner_meta, combiners, day);
	step_in_time(inverter_meta, inverters, day);
	dc_availability[day] = whats_my_dc_derate() * 100;
	ac_availability[day] = whats_my_ac_derate() * 100;
	//outln(day + '\t' + modules);
}

//count up cumulative failures
for (m=0; m < num_modules; m++)
	total_module_failures += modules[m].cumulative_failures;
for (s=0; s < num_strings; s++)
	total_string_failures += strings[s].cumulative_failures;
for (c=0; c < num_combiners; c++)
	total_combiner_failures += combiners[c].cumulative_failures;
for (i=0; i < num_inverters; i++)
	total_inverter_failures += inverters[i].cumulative_failures;
	
//create SAM performance adjustment table for the dc availability derate
hourly_loss = alloc(8760);
hourly_ac_loss = alloc(8760);
idx = 0;
day_num = alloc(365);
for (day = 0; day < 365; day++)
{
	day_num[day] = day;
	for (j = 0; j < 24; j++)
	{
		hourly_loss[idx] = 100 - dc_availability[day];
		hourly_ac_loss[idx] = 100 - ac_availability[day];
		idx++;
	}
}
//outln(hourly_loss);
adjust.constant = 0;
adjust.en_hourly = 1;
adjust.hourly = hourly_loss;
adjust.en_periods = 0;
set('dc_adjust', adjust);

adjust_ac.constant = 0;
adjust_ac.en_hourly = 1;
adjust_ac.hourly = hourly_ac_loss;
adjust_ac.en_periods = 0;
set('adjust', adjust_ac);

//run PV performance model- for now running the currently active case
messages = '';
success = simulate(messages, true);
if (!success)
	msgbox('Simulation failed.' + messages);
	
show_page('Results');

//Test outputs
//outln(dc_availability);
outln('Total module failures =' + total_module_failures);
outln('Total string failures =' + total_string_failures);
outln('Total combiner failures =' + total_combiner_failures);
outln('Total inverter failures =' + total_inverter_failures);

newplot();
plot(day_num, dc_availability, {'type'='line'});
plotopt({'title'='DC Availability'});
axis('x1', {'label'='Day'});
axis('y1', {'label'='% Operational'});

newplot();
plot(day_num, ac_availability, {'type'='line'});
plotopt({'title'='AC Availability'});
axis('x1', {'label'='Day'});
axis('y1', {'label'='% Operational'});





































