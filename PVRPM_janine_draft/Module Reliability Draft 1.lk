//*************************************************************************************
//Module Reliability Model -- DRAFT --
//jmf 6/16/16
//*************************************************************************************

// TO DO-----------------------------------------------------------------------------------
/*
	Terminology: replacement versus repair
	Module failures: Replacement versus repair? How to tell? How affecting warranty? How affecting next failure time? etc.
	Don't allow negative time setting for failure times
	Error checking on arrays 
	Set active case and error check
	Get system lifetime from financial case, OR set it if no financials (or LCOE?)
	HOW DOES DC DERATE WORK- YEAR 1 VERSUS OTHER YEARS? Right now this will crash if run for >1 year, I think...
	DC Derate needs to be expanded to include lifetime mode in SSC as well
	DC derate needs to be added to loss tree
	Currently running daily, do we need to change that? If so, how?
	TRANSLATE TO HOURLY---------------------
	replace "array" with "vector" to avoid confusion
*/

// SYSTEM INPUTS-----------------------------------------------------------------------
//WHY DO THESE WORK IF THEY'RE NOT GLOBAL?? BECAUSE THEY'RE ASSIGNED UP HERE AND NOT IN THE FUNCTION? SO WHY DO I HAVE TO ASSIGN GLOBAL THINGS UP HERE? HELP!!!!!!!!!
	num_modules = get('total_modules'); //9408;
	num_modules_per_string = get('modules_per_string'); //14
	num_strings = get('strings_in_parallel'); //672
	num_combiners = get('inverter_count'); //48
	num_strings_per_combiner = num_strings / num_combiners; //THIS IS NOT NECESSARILY AN INTEGER, NEED TO ERROR CHECK THIS!!!!!!!!!!!!!!!!
	system_lifetime_yrs = 1;

// MODULE RELIABILITY INPUTS-----------------------------------------------------------
	// failure mode 1: defective component
	module_defective_distribution = 'exponential';
	module_percentage_defective_percent = 20;
	module_defective_failures_per_yr = 0.5;
	// failure mode 2: failure
	module_failure_distribution = 'normal';
	module_failure_mean_yrs = 35;
	module_failure_std_yrs = 8;
	// repair time
	module_repair_distribution = 'normal'; //'lognormal'; //SHOULD BE LOGNORMAL N BUT THAT DOESN'T SEEM TO AGREE WITH GOLDSIM!!!!!!
	module_repair_mean_days = 45; //says 60 in pseudo code but is currently 45 in Goldsim
	module_repair_std_days = 15; //says 20 in pseudo code but is currently 15 in Goldsim
	// warranty period
	module_warranty_yrs = 20;
	
// STRING RELIABILITY INPUTS------------------------------------------------------------
	// failure mode 1
	string_failure_distribution = 'exponential';
	string_failures_per_yr = 0.1;
	// repair time
	string_repair_distribution = 'normal'; //'lognormal';//SHOULD BE LOGNORMAL N BUT THAT DOESN'T SEEM TO AGREE WITH GOLDSIM!!!!!!
	string_repair_mean_days = 10; //HAD TO CHANGE THESE DUE TO LIMITATIONS IN THE NUMBERS THE LHS CODE WILL ACCEPT!!!!!!!!!!!!!!!!!!
	string_repair_std_days = 5; //SAME AS ABOVE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
	
// COMBINER RELIABILITY INPUTS----------------------------------------------------------
	// failure mode 1
	combiner_failure_distribution = 'uniform'; //'lognormal';//SHOULD BE LOGNORMAL N BUT THAT DOESN'T SEEM TO AGREE WITH GOLDSIM!!!!!!
	//combiner_failure_mean_yrs = 5.4;
	//combiner_failure_std_yrs = 1.9;
	combiner_failure_min_days = 20; //1131;
	combiner_failure_max_days = 320; //2148;
	// repair time
	combiner_repair_distribution = 'exponential';
	combiner_repair_mean_days = 5;
	
//GLOBAL STRUCTURES---------------------------------------------------------------------------
//Arrays to hold component information, failure times, and replacement times
	// Modules
	global modules = alloc(num_modules);
	global module_replacement_times = null;
	global module_failure_times = null;
	global module_defective_failure_times = null;
	global module_warranty_days = module_warranty_yrs * 365;
	global module_failure_mean_days = module_failure_mean_yrs * 365;
	global module_failure_std_days = module_failure_std_yrs * 365;
	global module_defective_failures_per_day = module_defective_failures_per_yr / 365;
	
//Input containters--------------------------------------------------------------------------------
	// Strings
	global strings = alloc(num_strings);
	global string_meta = null;
	string_meta.number = num_strings;
	string_meta.warranty = false;
	string_meta.failure_distribution = string_failure_distribution;
	string_meta.failure_parameters = [(string_failures_per_yr / 365)];
	string_meta.repair_distribution = string_repair_distribution;
	string_meta.repair_parameters = [string_repair_mean_days, string_repair_std_days];
	string_meta.failure_times = null;
	string_meta.repair_times = null;
	
	// Combiners
	global combiners = alloc(num_combiners);
	global combiner_meta = null;
	combiner_meta.number = num_combiners;
	combiner_meta.warranty = false;
	combiner_meta.failure_distribution = combiner_failure_distribution;
	combiner_meta.failure_parameters = [combiner_failure_min_days, combiner_failure_max_days];
	combiner_meta.repair_distribution = combiner_repair_distribution;
	combiner_meta.repair_parameters = [combiner_repair_mean_days];
	combiner_meta.failure_times = null;
	combiner_meta.repair_times = null;
	
	
//DATA CONTAINERS------------------------------------------------------------------------------
//Data is only stored for the current timestep.

// MODULE INFORMATION
/*
state = operational (1) or failed (0)
defective = flag for whether or not this module has a defect.
	If true, then the module is also eligible for the defective failure mode
time_to_replacement = number of days from onset of failure until it is replaced
time_to_failure = number of days left until that module fails
cumulative_failures = total number of failures for that module
cumul_oow_failures = total number of failures out of warranty for that module
*/

// OTHER COMPONENT INFORMATION
/*
state = operational (1) or failed (0)
time_to_failure = number of days left until the string fails
time_to_repair = number of days from onset of failure until it is repaired
cumulative_failures = total number of failures for that string
cumulative_oow_failures = total number of failures out of warranty for that component if applicable
*/

//*************************************************************************************
// SUPPORTING FUNCTIONS
//*************************************************************************************
/* 	LHS performs Latin Hypercube Sampling given a distribution type, distribution parameters,
	and a number of samples. The name parameter allows a more helpful error message.
	Returns an array of the calculated samples.*/
function LHS(name, distribution_type, parameters, num_samples)
{
	lhs = lhs_create();
	lhs_dist(lhs, 'x', distribution_type, parameters);
	if (!lhs_run(lhs, num_samples))
	{
		msgbox('Latin Hypercube Sampling failed for: ' + name + ': ' + lhs_error(lhs));
		exit;
	}
	result = lhs_vector(lhs, 'x');
	lhs_free(lhs);
	return result;
}

//*************************************************************************************
// INITIALIZATION AND FAILURE FUNCTIONS
//*************************************************************************************
//MODULE INITIALIZATION------------------------------------------------------------------------------
// Initializes a single module "m" in the modules list
// If initializing for the first time, "time_is_zero" is true so that cumulative failures is set to zero
// To be used at the beginning or when a module is replaced

function initialize_component(component_meta, component_array, component_idx, bool_time_is_zero)
{
	// Component state
	component_array[component_idx].state = 1; //component is operational
	
	// Component failures and repairs
	if (bool_time_is_zero)
	{
		// cumulative failures and OOW failures initialized to zero at time zero only
		component_array[component_idx].cumulative_failures = 0;
		component_array[component_idx].cumulative_oow_failures = 0;
	}
	
	// Main failure type
	if (component_meta.failure_times == null || #component_meta.failure_times <= 0) //null on initialization of very first component, less than zero when you've used up the array
		component_meta.failure_times = LHS(to_string(component_meta.failure_times), component_meta.failure_distribution, component_meta.failure_parameters, (#component_array * 10));
	component_array[component_idx].time_to_failure = component_meta.failure_times[0]; //assign a failure time
	component_meta.failure_times -@ 0; //remove the failure time that was just used
			
	// Time to replacement or repair in case of failure
	if (component_meta.repair_times == null || #component_meta.repair_times <= 0) //null on initialization of very first component, less than zero when you've used up the array
		component_meta.repair_times = LHS(to_string(component_meta.repair_times), component_meta.repair_distribution, component_meta.repair_parameters, (#component_array * 10));
	component_array[component_idx].time_to_repair = component_meta.repair_times[0];
	component_meta.repair_times -@ 0; //remove the repair time that was just used
	
	//SPECIAL CASE: Modules and inverters have more than one failure mode- how do I handle those here?
}

function initialize_module(m, time_is_zero)
{
	// Module state
	modules[m].state = 1; //module is operational
	
	// Module failures
	// cumulative failures and OOW failures initialized to zero at time zero only
	if (time_is_zero)
	{
		modules[m].cumulative_failures = 0;
		modules[m].cumul_oow_failures = 0;
	}
	
	// Module failure mode 2: normal failure
	// Start with this failure mode because it exists for ALL modules
	modules[m].time_to_failure = module_failure_times[0]; //assign failure time
	module_failure_times -@ 0; //remove the failure time that was just used
	if (#module_failure_times <=0)
			module_failure_times = LHS('module_failure', module_failure_distribution, [module_failure_mean_days, module_failure_std_days], num_modules*10);

	
	// Module failure mode 1: defective modules
	modules[m].defective = rand() < (module_percentage_defective_percent / 100); //randomly assign a given % of modules to be defective
	// If the module is defective, check the defective failure time against the normal failure time
	if (modules[m].defective)
	{	
		defective_time = module_defective_failure_times[0]; //defective failure time for that module
		module_defective_failure_times -@ 0; //remove the defective failure time that was just used
		if (#module_defective_failure_times <=0)
			module_defective_failure_times = LHS('module_defective_failure', module_defective_distribution, [module_defective_failures_per_day], num_modules*10);
		if (defective_time < modules[m].time_to_failure) //defective failure occurs before normal failure
			modules[m].time_to_failure = defective_time;
	}
	
	// Module time to replacement in case of failure
	modules[m].time_to_replacement = module_replacement_times[0];
	module_replacement_times -@ 0; //remove the replacement time that was just used
	if (#module_replacement_times <=0)
		module_replacement_times = LHS('module_replacement_times', module_repair_distribution, [module_repair_mean_days, module_repair_std_days], num_modules*20);
}

//COMPONENT FAILURE----------------------------------------------------------------------------------------
// Changes "component_idx" in the array "component" state to failed, increments failures, checks current "day" against warranty if bool_warranty is true

function component_failure(component_array, component_idx, day, bool_warranty, warranty_length_days)
{
	component_array[component_idx].state = 0;
	component_array[component_idx].time_to_failure = 0;
	component_array[component_idx].cumulative_failures++;
	if (bool_warranty && day > warranty_length_days)
		component_array[component_idx].cumul_oow_failures++;
}

//SYSTEM INITIALIZATION---------------------------------------------------------------------------------
function initialize()
{
	// Module failure mode 1: defective component
	module_defective_failure_times = LHS('module_defective_failure', module_defective_distribution, [module_defective_failures_per_day], num_modules*10);
	
	// Module failure mode 2: failure
	module_failure_times = LHS('module_failure', module_failure_distribution, [module_failure_mean_days, module_failure_std_days], num_modules*10);
	
	// Module replacement times
	module_replacement_times = LHS('module_replacement_times', module_repair_distribution, [module_repair_mean_days, module_repair_std_days], num_modules*20);
		
	// Create module structures
	for (m = 0; m < num_modules; m++)
		initialize_module(m, true);
		
	// Create string structures
	for (s = 0; s < num_strings; s++)
		initialize_component(string_meta, strings, s, true);
		
	// Create combiner structures
	for (c = 0; c < num_combiners; c++)
		initialize_component(combiner_meta, combiners, c, true);
}

//*************************************************************************************
// DC DERATE CALCULATION FUNCTION
//*************************************************************************************
function whats_my_dc_derate() 
{
	//note that here, "operational modules" means modules whose power is REACHING the inverter, 
	//regardless of whether the module itself is failed or not
	operational_modules = 0;
	
	for (c=0; c < num_combiners; c++)
	{
		if (combiners[c].state == 0)
			continue; //if the combiner out, none of the modules on that combiner reach the inverter
		for (s=0; s < num_strings_per_combiner; s++)
		{
			if (strings[s].state == 0)
				continue; //if string is out, none of the modules on that combiner reach the inverter
			for (m=0; m < num_modules_per_string; m++)
			{
				// what module index are we at? 
				/* 
				number of combiners we've already looped through * total number modules per combiner +
				number of strings on this combiner we've already looped through * modules per string +
				number of modules that we've passed on this string
				*/
				// because c, s, and m are 0-indexed, they represent how many of each component have been completed by this point
				module_index = c * (num_strings_per_combiner * num_modules_per_string) + s * num_modules_per_string + m;
				if (module_index > num_modules - 1)
				{
					msgbox('Error, calculated module index > number of modules in the dc derate function');
					exit;
				}
				operational_modules += modules[module_index].state; //1 if operating, 0 if failed
			}
		}
	}
		
	return operational_modules / num_modules;
}

//*************************************************************************************
// INCREMENT TIMESTEP FUNCTION
//*************************************************************************************
function step_in_time(day)
{
	// Modules------------------------------------------------------------------
	for (m=0; m < num_modules; m++)
	{
		//module is operational
		if (modules[m].state == 1)
		{
			modules[m].time_to_failure--;
			//module has just failed
			if (modules[m].time_to_failure <= 0)
				component_failure(modules, m, day, true, module_warranty_days);
		}
		
		//module is currently failed
		else
		{
			modules[m].time_to_replacement--;
			//module is replaced
			if (modules[m].time_to_replacement <= 0)
				initialize_module(m, false); //initialize a new module without resetting cumulative failures
		}		
	}
	
	// Strings------------------------------------------------------------------
	for (s=0; s < num_strings; s++)
	{
		//string is operational
		if (strings[s].state == 1)
		{	
			strings[s].time_to_failure--;
			//string has just failed
			if (strings[s].time_to_failure <= 0)
				component_failure (strings, s, day, false, 0);
		}
		//string is currently failed
		else
		{
			strings[s].time_to_repair--;
			//string is replaced
			if (strings[s].time_to_repair <= 0)
				initialize_component(string_meta, strings, s, false); //initialize the string without resetting cumulative failures
		}
	}
	
	// Combiners------------------------------------------------------------------
	for (c=0; c < num_combiners; c++)
	{
		//combiner is operational
		if (combiners[c].state == 1)
		{	
			combiners[c].time_to_failure--;
			//combiner has just failed
			if (combiners[c].time_to_failure <= 0)
				component_failure(combiners, c, day, false, 0);
		}
		//combiner is currently failed
		else
		{
			combiners[c].time_to_repair--;
			//combiner is replaced
			if (combiners[c].time_to_repair <= 0)
				initialize_component(combiner_meta, combiners, c, false); //initialize the combiner without resetting cumulative failures
		}
	}
}


//*************************************************************************************
// MAIN SCRIPT
//*************************************************************************************

//allocations for now

dc_availability = null;
total_module_failures = 0;
total_string_failures = 0;
total_combiner_failures = 0;

//timestep 0
initialize();
dc_availability[0] = whats_my_dc_derate() * 100;
//outln('0\t' + modules);

//rest of system lifetime
for (day = 1; day < system_lifetime_yrs * 365; day++)
{
	step_in_time(day);
	dc_availability[day] = whats_my_dc_derate() * 100;
	//outln(day + '\t' + modules);
}

//count up cumulative failures
for (m=0; m < num_modules; m++)
	total_module_failures += modules[m].cumulative_failures;
for (s=0; s < num_strings; s++)
	total_string_failures += strings[s].cumulative_failures;
for (c=0; c < num_combiners; c++)
	total_combiner_failures += combiners[c].cumulative_failures;
	
//create SAM performance adjustment table for the dc availability derate
hourly_loss = alloc(8760);
idx = 0;
day_num = alloc(365);
for (day = 0; day < 365; day++)
{
	day_num[day] = day;
	for (j = 0; j < 24; j++)
	{
		hourly_loss[idx] = 100 - dc_availability[day];
		idx++;
	}
}
//outln(hourly_loss);
adjust.constant = 0;
adjust.en_hourly = 1;
adjust.hourly = hourly_loss;
adjust.en_periods = 0;
set('dc_adjust', adjust);

//run PV performance model- for now running the currently active case
messages = '';
success = simulate(messages, true);
if (!success)
	msgbox('Simulation failed.' + messages);
	
show_page('Results');

//Test outputs
//outln(dc_availability);
outln('Total module failures =' + total_module_failures);
outln('Total string failures =' + total_string_failures);
outln('Total combiner failures =' + total_combiner_failures);

newplot();
plot(day_num, dc_availability, {'type'='line'});
plotopt({'title'='DC Availability'});
axis('x1', {'label'='Day'});
axis('y1', {'label'='% Operational'});






































