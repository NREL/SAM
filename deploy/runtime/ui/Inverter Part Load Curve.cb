function pd_inverter_replot_efficiency()
{
	data = value("pv.inv.pd.data");
	row=data[0];
	col=data[1];
	
	np = row;
	output_power = alloc(np);
	eff_plot = alloc(np);
	
	ymin=100;
	
	for (i=0;i<np;i++)
	{
		output_power[i] = data[i*col+2];
		eff_plot[i] = data[i*col+2+1];
		if (eff_plot[i] < ymin)
		{
			ymin = eff_plot[i];
		}
	}
	
	
	ymin = ymin - 10;
	if (ymin < 0)
	{
		ymin = 0;
	}
	
	newplot("pv.inv.pd.eff_curve");
	plot("pv.inv.pd.eff_curve", output_power, eff_plot, {"thick"=1, "scale"=true});
	axis("pv.inv.pd.eff_curve", "x1", {"min"=0, "max"=100, "label"="% of Rated Output Power"});
	axis("pv.inv.pd.eff_curve", "y1", {"min"=ymin, "max"=100, "label"="Efficiency (%)"});
}

function pd_inverter_interpolate( x )
{
	data = value("pv.inv.pd.data");
	row=data[0];
	col=data[1];
	
	n = row;
	Partload = alloc(n);
	Efficiency = alloc(n);

	for (i=0;i<n;i++)
	{
		Partload[i] = data[i*col+2];
		Efficiency[i] = data[i*col+2+1];
	}

	nu = n;
	nl = 0;

	// Numerical Recipes in C p.117
	while ( (nu-nl) > 1 )
	{
		ndx = floor((nu + nl) / 2); 
		if ( x >= Partload[ndx] )
		{
			nl = ndx;
		}
		else 
		{
			nu = ndx;
		}
	}
	if ( x == Partload[0] )
	{
		ndx = 0;
	}
	else if ( x == Partload[n-1] )
	{
		ndx = n-1;
	}
	else
	{
		ndx = nl;
	}

	// check in range
	if (ndx >= (n-1))
	{
		ndx = n-2;
	}
	if ( ndx < 0 ) 
	{
		ndx =0;
	}

	// x between Partload[ndx] and Partload[ndx-1]
	if ( ( x > Partload[ndx] ) && ( n > 1 ))
	{
		eff = Efficiency[ndx] + ((Efficiency[ndx+1] - Efficiency[ndx]) / 
									(Partload[ndx+1] - Partload[ndx] )) * (x - Partload[ndx]);
	}
	else
	{
		eff = Efficiency[ndx];
	}
	
	return eff;
}

function pd_inverter_calculate_weighted_efficiencies()
{
	cec_F1 = 0.00;
	cec_F2 = 0.04;
	cec_F3 = 0.05;
	cec_F4 = 0.12;
	cec_F5 = 0.21;
	cec_F6 = 0.53;
	cec_F7 = 0.05;
	eff_cec = cec_F1 * pd_inverter_interpolate(5) 
			+ cec_F2 * pd_inverter_interpolate(10) 
			+ cec_F3 * pd_inverter_interpolate(20) 
			+ cec_F4 * pd_inverter_interpolate(30) 
			+ cec_F5 * pd_inverter_interpolate(50) 
			+ cec_F6 * pd_inverter_interpolate(75) 
			+ cec_F7 * pd_inverter_interpolate(100); 
	value("pv.inv.pd.eff_cec", eff_cec);

	euro_F1 = 0.03;
	euro_F2 = 0.06;
	euro_F3 = 0.13;
	euro_F4 = 0.10;
	euro_F5 = 0.48;
	euro_F6 = 0.00;
	euro_F7 = 0.20;
	eff_euro = euro_F1 * pd_inverter_interpolate(5) 
			+ euro_F2 * pd_inverter_interpolate(10) 
			+ euro_F3 * pd_inverter_interpolate(20) 
			+ euro_F4 * pd_inverter_interpolate(30) 
			+ euro_F5 * pd_inverter_interpolate(50) 
			+ euro_F6 * pd_inverter_interpolate(75) 
			+ euro_F7 * pd_inverter_interpolate(100); 
	value("pv.inv.pd.eff_euro", eff_euro);

}

on_load{"Inverter Part Load Curve"}=define(){
	plotopt("pv.inv.pd.eff_curve", {"title"="","backcolor"=[255,255,255], "popup"=true});
	pd_inverter_replot_efficiency();
	pd_inverter_calculate_weighted_efficiencies();
};	

on_change{"pv.inv.pd.data"} = define() { 
	pd_inverter_replot_efficiency(); 
	pd_inverter_calculate_weighted_efficiencies();
};


	
