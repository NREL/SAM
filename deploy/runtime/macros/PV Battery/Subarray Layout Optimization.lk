/*@

<br><br>
This macro helps the user determine the optimal subarray size, ground coverage ratio (GCR), and module tilt angle over an area of fixed dimensions. The array placement is optimized with respect to 3 main strategies:
<br><br> 
 
<ol>
<li> Maximizing Annual Energy Production (AEP)
<li> Maximizing Net Present Value (NPV) of System 
<li> Maximizing Energy Yield (kWh/kW) of the System
</ol>

<br><br> Once the simulation is completed, you will have the option of automatically updating your current subarray layout based on one of the 3 optimization strategies outlined above. Optimized values that are updated include: strings in parallel, tilt, GCR, and number of modules along bottom of row.


<br><br> 
<b>Warnings and Tips:</b> 
<ul>
	<li> For accurate results, ensure self-shading is enabled under the Shading and Layout page in the active case.
	<li><b> If optimizing a single subarray, the number of inverters recommended for each optimization strategy is only for that particular subarray and not the entire system. </b>
	<li> Ensure number of modules per string in any active subarray is greater than 0.
@*/
 
 
//Macro User Interface Widgets
//@ name=subarray_x;type=combo;label=Subarray to be optimized;value=Subarray 1,Subarray 2,Subarray 3,Subarray 4,All Active Subarrays;sel=0
//@ name=length;type=number;label=Enter the Length of Field or Rooftop (m):;value=35
//@ name=width;type=number;label=Enter the width of Field or Rooftop (m):;value=25
//@ name=setback;type=number;label=Enter the setback (in m) from edges:;value=1 
//@ name=max_gcr;type=number;label=Enter the maximum GCR:;value=1 
//@ name=min_gcr;type=number;label=Enter the minimum GCR(value cannot equal 0):;value=0.1 
//@ name=gcr_steps;type=number;label=Enter the increments you would like to iterate GCR over:;value=0.1
//@ name=max_tilt;type=number;label=Enter the maximum allowable (fixed) tilt angle (in Degrees):;value=90
//@ name=min_tilt;type=number;label=Enter the minimum allowable (fixed) tilt angle (in Degrees):;value=0
//@ name=tilt_steps;type=number;label=Enter the increments for tilt angle (in Degrees):;value=10
//@ name=dcac;type=number;label=Desired DC to AC Ratio:;value=1.20
//@ name=update_results;type=combo;label=Update subarray configuration in active case optimized for;value=Max AEP,Max NPV,Max Energy Yield,Do Not Update;sel=3

// display warning if the macro is run outside of a case
if ( typeof(macro) == 'unknown' ) {
	msgbox('This macro must be run from within a case.');
	exit;
}

///////////////////////////////////**** USER DEFINED INPUTS ****///////////////////////////////////

//User Defined Inputs:
subarray_x = macro.subarray_x;				//Subarray to be optimized 
length = macro.length ; 					//Length of field (m)
width = macro.width;						//Width of fiel (m)
setback = macro.setback;					//Distance from edge of land that is off limits for placement of modules (m)
effective_length = length - setback;		//(Calculated Value) Actual length of the field that is available for placement of modules (m)
effective_width = width - setback;			//(Calculated Value) Actual width of the field that is available for placement of modules	(m)
area = effective_length * effective_width; 	//(Calculated Value) Total effective land area (in m^2)
max_gcr = macro.max_gcr;					//Allow the user to input max GCR
min_gcr = macro.min_gcr;					//Allow the user to input min GCR
gcr_steps = macro.gcr_steps;				//Allow the  user to input the increments of GCR they want to calculate over
max_tilt = macro.max_tilt;					//Allow the user to input max tilt angle
min_tilt = macro.min_tilt;					//Allow the user to input min tilt angel
tilt_steps = macro.tilt_steps;				//Allow the user the input the increments of tilt angle they want to calculate over
dcac = macro.dcac;							//Desired Dc to AC ratio 
update_results = macro.update_results;		//Update subarray layout optimized for 1 of the 3 strategies, or do not update at all

acreage = area*0.0002471;					//m^2 to acres conversion

//If the user wants to iterate over fixed GCR or tilt angle, and sets either of
//the two variables to 0, then change value to 1 to prevent infinite looping.
if(gcr_steps <= 0 ) gcr_steps = max_gcr;
if(tilt_steps <= 0) tilt_steps = max_tilt;

////////////////////////////////////////EXCEPTION HANDLING////////////////////////////////////////////////

//Max number of subarrays allowed in SAM currently:
max_subarrays = 4;			//Change this number if SAM changes max number of subarrays allowed in a simulation


//Check to see financial model selected (which determines name of NPV variable name):
fin_model = configuration();
finConfig = fin_model[1];

if(finConfig == 'Sale Leaseback' || finConfig == 'LCOE Calculator') {
	msgbox('Sorry, this macro does not currently support the ' + finConfig + ' model!');
	exit;
}
elseif(finConfig == 'None') {
	msgbox('Sorry, this macro does not currently support the No Financial model!');
	exit;
}

//Allowing the user to optimize NPV from Developer/investor/host perspective:
elseif(finConfig == 'Leveraged Partnership Flip' || finConfig == 'All Equity Partnership Flip') 
	stakeholder = choose_from_list([ 'Developer' , 'Investor' ] , "Optimize NPV of project from perspective of: " );

elseif(finConfig == 'Host Developer')	
	stakeholder = choose_from_list([ 'Host' , 'Developer' ] , "Optimize NPV of project from perspective of: " );
	
//If single_subarray is false implies that the user chose to optimize 'All Active Subarrays'
single_subarray = false;
if(subarray_x != 'All Active Subarrays') single_subarray = true;

sub_number = real_array(subarray_x);
if(get('subarray'+to_string(sub_number[1])+'_enable') == 0) {
	msgbox("You are trying to optimize Subarray "+to_string(sub_number[1])+", which is currently disabled in the active case.");
	exit;
}
if(get('subarray'+to_string(sub_number[1])+'_modules_per_string') == 0) {
	msgbox("Subarray " + to_string(sub_number[1]) + " has 0 modules per string.");
	exit;
}
	
	
////////////////////////////////////////FUNCTION DECLARATIONS////////////////////////////////////////////////	

//This block contains declarations of all functions used in the rest of this script. 
	
//========================================================================================================================================================================================================================================================================

function time_display(minute, second) {	//This function formats the time displayed 

	if ( minute == 0 && (second / 10) < 1)
		continue_macro = yesno("You are attempting to optimize entire system (all active subarrays). This will take 00:0" + second + " seconds to complete. Proceed?");
	elseif ( minute == 0 && (second / 10) > 1) 
		continue_macro = yesno("You are attempting to optimize entire system (all active subarrays). This will take 00:" + second + " seconds to complete. Proceed?");
	elseif ( minute < 10 && (second / 10) < 1)
		continue_macro = yesno("You are attempting to optimize entire system (all active subarrays). This will take 0" + minute + ":0" + second + " minute(s) to complete. Proceed?");
	elseif ( minute < 10 && (second / 10) > 1)
		continue_macro = yesno("You are attempting to optimize entire system (all active subarrays). This will take 0" + minute + ":" + second + " minute(s) to complete. Proceed?");
	elseif ( minute > 10 && (second / 10) < 1)
		continue_macro = yesno("You are attempting to optimize entire system (all active subarrays). This will take " + minute + ":0" + second + " minute(s) to complete. Proceed?");
	elseif ( minute > 10 && (second / 10) > 1)
		continue_macro = yesno("You are attempting to optimize entire system (all active subarrays). This will take " + minute + ":" + second + " minute(s) to complete. Proceed?");
	
	if (continue_macro == false) {
		outln("\n	Consider reducing iterations of GCR and Tilt angle, or optimize over a single subarray instead for a quicker simulation.");
		exit;
	}

}

//========================================================================================================================================================================================================================================================================

// format numbers comma thousands indicator, 2 decimal places
// note: will display integers with 2 decimals, e.g., display 3 as 3.00
function num_to_str( x , d )
{
	// only format x if it is a number
	if ( typeof(x) == 'number' )
	{
		
		if( ( d == 0) && (mod( round(x) , 10) == 0) )	
			str = round(x);
		else 
			str = sprintf('%.'+to_string(d)+',',x);			// This step converts a number (for d = 0) like 409.857 to 41 instead of 410. This if-else condition is a workaround that bug.

		arr = split(str,'.');
		if ( #arr > 1 )
			num_decs = strlen(to_string(arr[1]));
		else
			num_decs = 0;
		// if number has one or more decimal places less than the desired number	
		if ( #arr > 1 && num_decs < d)
		{
			for (i=0; i<d-num_decs; i++)
				str += '0';
		}
		// if number has no decimal places
		elseif ( #arr == 1 && d > 0 )
		{
			str += '.';
			for (i=0; i<d; i++)
				str += '0';
		}		
	}
	// if x is a string, return it
	elseif ( typeof(x) == 'string' )
		str = x;
	// if x is not a number or string, convert it to a string with no formatting	
	else	
		str = to_string( x );
	return str;
}

//========================================================================================================================================================================================================================================================================

//Function for storing module power

module_info = define () {

		module_model = get('module_model');
		module_power = 0;
		
		if (module_model == 0){
			module_power = get('spe_power');
		}
		elseif (module_model == 1){
			module_power = get('cec_p_mp_ref');
		}
		elseif (module_model == 2){
			module_power = get('6par_pmp');
		}
		elseif (module_model == 3){
			module_power = get('snl_ref_pmp');
		}
		elseif (module_model == 4){
			module_power = get('sd11par_Pmp0');
		}
		return module_power;
};

//========================================================================================================================================================================================================================================================================
//Get Max AC power per inverter in kW
inverter_info = define() {

	inverter_model = get('inverter_model');
	inverter_power = 0;
	
	if (inverter_model == 0) {
		inverter_power = get('inv_snl_paco')/1000;
		}
	elseif (inverter_model == 1) {
		inverter_power = get('inv_ds_paco')/1000;
		}
	elseif (inverter_model == 2) {
		inverter_power = get('inv_pd_paco')/1000;
		}
	elseif (inverter_model == 3) { 
		inverter_power = get('inv_cec_cg_paco')/1000;
		}
	return inverter_power;
};
	
//========================================================================================================================================================================================================================================================================

//function for calculating system size 
system_sizer = define(gcr) {
		
		module_power = module_info();
		
		module_area = get('module_area');
		set('subarray1_gcr', gcr);
		system_size = gcr*(area/module_area)*(module_power/1000) ;
		return system_size;
};


//========================================================================================================================================================================================================================================================================

function npv_getter (fin_config) {

		if(fin_config == 'Residential' || fin_config == 'Commercial' || fin_config == 'Third Party' )	
			return get('npv');
		
		elseif(fin_config == 'Host Developer' && stakeholder == 'Developer') 
			return get('project_return_aftertax_npv');
			
		elseif(fin_config == 'Host Developer' && stakeholder == 'Host') 
			return get('npv');
		
		elseif(fin_config == 'Single Owner')
			return get('project_return_aftertax_npv');
		
		elseif((fin_config == 'Leveraged Partnership Flip' || fin_config == 'All Equity Partnership Flip') && stakeholder == 'Developer') 
			return get('sponsor_aftertax_npv');
		
		elseif((fin_config == 'Leveraged Partnership Flip' || fin_config == 'All Equity Partnership Flip') && stakeholder == 'Investor') 
			return get('tax_investor_aftertax_npv');

}

///////////////////////////////////////////////Return Estimated Time to Complete Macro////////////////////////////////////////////////////////////////////////

//Keeping tab of all subarrays that the user enabled in the active case; and a reminder to re-enable subarray (if the subarray was enabled before the macro) after simulation is complete.

timer = 1;					//variable used in calculation of estimated time macro will take to finish
subarray_flag[0] = 1; 		//where subarray_flag[0] is subarray 1. 
count_sub = 1;

while(count_sub < max_subarrays){
	if(get('subarray'+ to_string(count_sub + 1) +'_enable') == 1) {
		timer += 1;
		subarray_flag[count_sub] = 1;
	}
	else
		subarray_flag[count_sub] = 0;
	count_sub += 1;
}

iter = 0;
while(iter < max_subarrays){	//Create a list of subarrays in SAM.
	subarray_list[iter] = 'Subarray ' + to_string(iter+1);
	iter += 1;
}

system_inverter_count = 0;	//Keeps count of the number of inverters the system needs (only used when user chooses to optimize all active subarrays).
continue_macro = true;	
time_simulation = 0;		

//The option to diplay total time only kicks in when user decides to simulate ALL active arrays:
if(subarray_x != 'All Active Subarrays') 
	outln("\n\tOptimizing Array Layout for given ranges of GCR and Tilt over area of " + num_to_str(acreage, 3) + " acres.");
else {
	//Calculate time taken for 1 simulation. 
	start_timer();
	simulate();
	time_simulation = (elapsed_time()/1000) * ((max_gcr - min_gcr)/gcr_steps) * ((max_tilt - min_tilt) / tilt_steps) * timer * (1/60);		//Formula to estimate total time macro will take to complete if user is optimizing all active subarrays.
	time_simulation_min = floor(time_simulation);
	time_simulation_sec = floor((time_simulation - time_simulation_min) * 60);
	//Function call to display formatted time (For instance, 4 minutes 25 seconds will be displayed as: 04:25 minutes):
	time_display(time_simulation_min, time_simulation_sec);
	
}


////////////////////////**** DETERMINING WHICH SUBARRAY IS TO BE OPTIMIZED AND STORING EXISTING USER INPUT VALUES ****////////////////////////////

subarray_to_optimize = 0;

//This while loop goes through every enabled subarray to find the optimum desgin.

while (subarray_to_optimize < max_subarrays) {			
	
		if( single_subarray != true && timer == 1) single_subarray = true;
		
		if(single_subarray != true) {
			while(subarray_flag[subarray_to_optimize] == 0 && subarray_to_optimize < (max_subarrays - 1)  ) subarray_to_optimize = subarray_to_optimize + 1;	//If Subarray x is disabled in the active case, jump to subarray(x+1) and check if it is disabled. If enabled, jump out of while loop and optimize this subarray.
				
			choice = subarray_to_optimize;
			subarray_x = subarray_list[choice]; //? choice ['Subarray 1', 'Subarray 2',... , 'Subarray <max>' ];
		}
	
		if( subarray_to_optimize == (max_subarrays - 1) && subarray_flag[max_subarrays - 1] == 0) break; 		//End macro at this point if and when final subarray is reached and it is disabled in active simulation.
		
		//If the user is optimizing all active subarrays, ask them to input the allotted area for each subarray:
		if(single_subarray != true) {
			length = in("Enter length (in m) of field or rooftop alloted for " + subarray_x +". [Note: this does not include setback length]");
			width = in("Enter width (in m) of field or rooftop alloted for " + subarray_x +". [Note: this does not include setback length]");
			effective_length = to_real(length) - setback;		//(Calculated Value) Actual length of the field that is available for placement of modules (m)
			effective_width = to_real(width) - setback;			//(Calculated Value) Actual width of the field that is available for placement of modules	(m)
			area = effective_length * effective_width; 	//(Calculated Value) Total effective land area (in m^2)
		}
		
		outln('\t\nOptimizing Subarray ' + (subarray_to_optimize + 1) + ' over an area of ' + area + ' m^2' );
		
		//Store subarray 1's configuration information:
		subarray1_modules_per_string = get('subarray1_modules_per_string');
		subarray1_nstrings = get('subarray1_nstrings');
		subarray1_track_mode = get('subarray1_track_mode');
		subarray1_tilt = get('subarray1_tilt');
		subarray1_azimuth =	get('subarray1_azimuth');
		subarray1_gcr = get('subarray1_gcr');
		subarray1_shade_mode = get('subarray1_shade_mode');
		subarray1_mod_orient = get('subarray1_mod_orient');
		subarray1_nmody = get('subarray1_nmody');
		subarray1_nmodx = get('subarray1_nmodx');
		inverter_count = get('inverter_count');
		
		count = 0;
		while (count < max_subarrays){
			set('subarray' + to_string(count+1) + '_enable', 0);
			count += 1;
		}
		
		
		//iter = 1;
		//while( iter <= max_subarrays){
			sub_number = real_array(subarray_x);
			//Variables that stay constant throughout simulation
			set('subarray1_modules_per_string', get('subarray'+to_string(sub_number[1])+'_modules_per_string'));	
			set('subarray1_track_mode', get('subarray'+to_string(sub_number[1])+'_track_mode'));
			set('subarray1_azimuth', get('subarray'+to_string(sub_number[1])+'_azimuth'));
			set('subarray1_shade_mode', get('subarray'+to_string(sub_number[1])+'_shade_mode'));
			set('subarray1_mod_orient', get('subarray'+to_string(sub_number[1])+'_mod_orient'));
			set('subarray1_nmody', get('subarray'+to_string(sub_number[1])+'_nmody'));

			//disable all other subarrays but subarray #1 which now contains the user defined values of subarray(iter) that is being optimized currently:
			count = 1;
			while(count <= max_subarrays){
				set('subarray'+to_string(count+1)+'_enable', 0);
				count += 1;
			}
			//iter += 1;

		//}


		///////////////////////////////////**** DEFINING PLACEHOLDER VARIABLES ****///////////////////////////////////

		db{"max_energy"} = {"energy" = 0, "gcr" = 0, "tilt" = 0, "system_size" = 0, "npv" = 0, "yield" = 0}; 
		db{"max_npv"} = {"energy" = 0, "gcr" = 0, "tilt" = 0, "system_size" = 0, "npv" = -9999999999, "yield" = 0}; 
		db{"max_yield"} = {"energy" = 0, "gcr" = 0, "tilt" = 0, "system_size" = 0, "npv" = 0, "yield" = 0}; 
		
		db{"maxEnergy_config"} = {"nmodx" = 0, "nrows" = 0, "row_spacing" = 0, "total_modules" = 0};
		db{"npv_config"} = {"nmodx" = 0, "nrows" = 0, "row_spacing" = 0, "total_modules" = 0};
		db{"yield_config"} = {"nmodx" = 0, "nrows" = 0, "row_spacing" = 0, "total_modules" = 0};
		
		nmody =  get('subarray1_nmody');	//Number of modules along side row stays constant throughout, and is set by the user in the active case.
		
		///////////////////////////////////**** ARRAY PLACEMENT ****///////////////////////////////////

		i = 0;	
		for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 
			module_power = module_info();
			system_size[i] = to_int(system_sizer(gcr));
			number_of_modules[i] = to_int(system_size[i]/(module_power/1000));
			i = i + 1;
		}

		//Variable to keep count of number of rows in the loop:
		if (get('subarray1_mod_orient') == 1) {					//if module orientation is landscape, then length of panel is used in calculating length of row
			module_length = get('module_length');				//Length of 1 module
			bottom_length = module_length;						//Initial length of bottom row of modules 
			set('subarray1_nmodx', 1);
		}
		elseif (get('subarray1_mod_orient') == 0) { 			//If module orientation is portrait, then width of panel is used in calculation length of row		
			module_length = get('module_width');				//Length of 1 module
			bottom_length = module_length;						//Initial length of bottom row of modules 
			set('subarray1_nmodx', 1);
		}


		p = 0;
		n = 0;		//number of panels along side bottom of row
		i = 0;

		//Fitting modules along length of field:
		for(gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) {						//For loop to iterate over the entire range of (user input) GCRs, to make sure module placement along length and width of the field is in sync with the respective GCRs. So, for instance, even though the field length could accomodate a longer row of modules, number of modules in each row and alongside row is restricted.	
				
			n = to_int((effective_length/module_length) );									//Set modules along entire effective length
			set('subarray1_nmodx',n);
			
			//At this point modules have been placed along bottom. System sizes have been calculated at respective GCRs.  
			
			//While loop to make sure number of modules along bottom row doesn't exceed system size at that GCR
			while(get('subarray1_nmodx') < n){
				n -= 1;
				set('subarray1_nmodx',n);
			}
			
			//So at this point, we set modules along bottom. Now, find how many strings in parallel you need.
			//outln(get('subarray1_modules_per_string'));
			strings_in_parallel[i] = to_int(number_of_modules[i] /get('subarray1_modules_per_string'));
			set('subarray1_nstrings', strings_in_parallel[i]);
			
			
			//If number of rows is less than 1, then take out modules from the bottom row till the number of rows is atleast 1
			while(get('ui_subarray1_nrows') < 1) {
				n = n - 1;
				set('subarray1_nmodx', n);
				
			}
			
			
			bottom_modules[p] = n;
			set('subarray1_nmodx', bottom_modules[p]);
			
			p = p + 1;
			i = i + 1;
		}


		///////////////////////////////////**** S I M U L A T I O N ****///////////////////////////////////

		i = 0;
		progress_gcr = 0;	//Progress tracker

		//Nested for loop to calculate maximum AEP, maximum NPV, and max energy yield
		//for user input range of GCR and tilt angles
		for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 			//Loop for iterating over a range of GCR

			//Return what percent of the simulation is complete:
			if((max_gcr - min_gcr) != 0) {		//Skip showing progress if user is running simulation over one GCR value only
			progress = to_int((progress_gcr/(max_gcr - min_gcr)) * 100);
			progress_gcr += gcr_steps ;
			outln("\n\t[" + progress + "% complete] Currently simulating over GCR of: " + num_to_str(gcr , 3));
			}
			
			module_power = module_info() / 1000;		//divided by 1000 to get result in kW
			inverter_power = inverter_info();	//in kW
			j = -1;				//counter variable to keep tab of the columns in the loop
			
			//Setting desired system size:
			if(strings_in_parallel[i] == 0) strings_in_parallel[i] = 1;
			set_strings_in_parallel = strings_in_parallel[i];
			inverter_capacity_total = system_size[i] / dcac;
			num_inverters[i] = to_int(inverter_capacity_total / inverter_power);
			if(num_inverters[i] == 0) num_inverters[i] = 1;
			set('inverter_count', num_inverters[i]);
			set('subarray1_nstrings', to_int(set_strings_in_parallel));
			set('subarray1_gcr', gcr);
			set('subarray1_nmodx', bottom_modules[i]);
			num_rows[i] = get('ui_subarray1_nrows');
			
			for (tilt = min_tilt ; tilt <= max_tilt ; tilt = tilt + tilt_steps) {	//Loop for iterating over a range of tilt angles

				j = j + 1; 									//Variable to keep a tab of columns in the loop
				x[j] = min_tilt + (tilt_steps * j); 		//Array to store the tilt angles the user would like to iterate over
				set('subarray1_tilt', tilt);
				simulate();
				annual_energy[i][j] = get('annual_energy');
				
				npv[i][j] = npv_getter(finConfig);
				
				yield[i][j] = get('kwh_per_kw');
				type[i] = gcr;
				
				//Storing the appropriate results (when calculating maximum AEP) in the respective placeholders
				if (annual_energy[i][j] > db{"max_energy"}.energy) {						
					db{"max_energy"}.energy = annual_energy[i][j] ;
					db{"max_energy"}.gcr = gcr;
					db{"max_energy"}.tilt = tilt;
					db{"max_energy"}.system_size = system_size[i];
					db{"max_energy"}.npv = get('npv');
					db{"max_energy"}.yield = yield[i][j];
					db{"maxEnergy_config"}.nmodx = get('subarray1_nmodx');
					db{"maxEnergy_config"}.nrows = get('ui_subarray1_nrows');
					db{"maxEnergy_config"}.row_spacing = get('ui_subarray1_row_spacing');
					db{"maxEnergy_config"}.total_modules = get('total_modules');
					
					string_in_parallel_aep = get('subarray1_nstrings');
					modules_per_string_aep = get('subarray1_modules_per_string');
					inverter_aep = get('inverter_count');
				}
			//	outln(db{"max_npv"}.energy + '	' + npv[i][j]);		
				//Storing the appropriate results when calculating maximum NPV in the respective placeholders
				if (db{"max_npv"}.npv < npv[i][j]) {
					db{"max_npv"}.npv = npv[i][j];
					db{"max_npv"}.gcr = gcr; 
					db{"max_npv"}.tilt = tilt;
					db{"max_npv"}.system_size = system_size[i];
					db{"max_npv"}.energy = annual_energy[i][j];
					db{"max_npv"}.yield = yield[i][j];
					db{"npv_config"}.nmodx = get('subarray1_nmodx');
					db{"npv_config"}.nrows = get('ui_subarray1_nrows');
					db{"npv_config"}.row_spacing = get('ui_subarray1_row_spacing');
					db{"npv_config"}.total_modules = get('total_modules');
					
					string_in_parallel_npv = get('subarray1_nstrings');
					modules_per_string_npv = get('subarray1_modules_per_string');
					inverter_npv = get('inverter_count');
				}
						
						
				//Storing the appropriate results when calculating maximum energy yield of project
				if (db{"max_yield"}.yield < yield[i][j]) {
				
					db{"max_yield"}.yield = yield[i][j];
					db{"max_yield"}.gcr = gcr;
					db{"max_yield"}.tilt = tilt;
					db{"max_yield"}.system_size = system_size[i];
					db{"max_yield"}.energy = annual_energy[i][j];
					db{"max_yield"}.npv = npv[i][j];
					db{"yield_config"}.nmodx = get('subarray1_nmodx');
					db{"yield_config"}.nrows = get('ui_subarray1_nrows');
					db{"yield_config"}.row_spacing = get('ui_subarray1_row_spacing');
					db{"yield_config"}.total_modules = get('total_modules');
					
					string_in_parallel_yield = get('subarray1_nstrings');
					modules_per_string_yield = get('subarray1_modules_per_string');
					inverter_yield = get('inverter_count');
				}
			}
			i = i + 1;		
		}


		///////////////////////**** REPOPULATING EXISTING USER INPUT VALUES AND OPTIMIZED VALUES IN SUBARRAY X IN ACTIVE CASE ****//////////////////////

		//Re-enable those subarrays that were enabled before the macro (but were not the subarray being optimized):
		count = 1;
		while(count < max_subarrays){
			if(subarray_flag[count] == 1) //Starting with subarray 2 since subarray 1 is always enabled
				set('subarray' + to_string(count+1) + '_enable', 1);
			count += 1;
		}
	
		//Now update fields for subarray to be optimized:
		if(subarray_x == 'Subarray 1') {
			if(update_results == 'Max AEP') {
					set('subarray1_nstrings', string_in_parallel_aep);
					set('subarray1_tilt', db{"max_energy"}.tilt);
					set('subarray1_gcr', db{"max_energy"}.gcr);
					set('subarray1_nmodx', db{"maxEnergy_config"}.nmodx);
					set('inverter_count', inverter_aep);
					system_inverter_count = system_inverter_count + get('inverter_count');
				}
			elseif(update_results == 'Max NPV'){
				set('subarray1_nstrings', string_in_parallel_npv );
				set('subarray1_tilt', db{"max_npv"}.tilt);
				set('subarray1_gcr', db{"max_npv"}.gcr);
				set('subarray1_nmodx', db{"npv_config"}.nmodx );
				set('inverter_count', inverter_npv);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
			elseif(update_results == 'Max Energy Yield') {
				set('subarray1_nstrings', string_in_parallel_yield  );
				set('subarray1_tilt', db{"max_yield"}.tilt);
				set('subarray1_gcr', db{"max_yield"}.gcr);
				set('subarray1_nmodx', db{"yield_config"}.nmodx );
				set('inverter_count', inverter_yield);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
			
		}


		if (subarray_x == 'Subarray 2') {
			//Value stays constant throughout simulation
			set('subarray2_modules_per_string', get('subarray1_modules_per_string'));	
			set('subarray2_track_mode', get('subarray1_track_mode'));
			set('subarray2_azimuth', get('subarray1_azimuth'));
			set('subarray2_shade_mode', get('subarray1_shade_mode'));
			set('subarray2_mod_orient', get('subarray1_mod_orient'));
			set('subarray2_nmody', get('subarray1_nmody'));
			
			//Updating optimized values based on user's selection
			if(update_results == 'Max AEP') {
				set('subarray2_nstrings', string_in_parallel_aep);
				set('subarray2_tilt', db{"max_energy"}.tilt);
				set('subarray2_gcr', db{"max_energy"}.gcr);
				set('subarray2_nmodx', db{"maxEnergy_config"}.nmodx);
				set('inverter_count', inverter_aep);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
			elseif(update_results == 'Max NPV'){
				set('subarray2_nstrings', string_in_parallel_npv );
				set('subarray2_tilt', db{"max_npv"}.tilt);
				set('subarray2_gcr', db{"max_npv"}.gcr);
				set('subarray2_nmodx', db{"npv_config"}.nmodx );
				set('inverter_count', inverter_npv);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
			elseif(update_results == 'Max Energy Yield') {
				set('subarray2_nstrings', string_in_parallel_yield  );
				set('subarray2_tilt', db{"max_yield"}.tilt);
				set('subarray2_gcr', db{"max_yield"}.gcr);
				set('subarray2_nmodx', db{"yield_config"}.nmodx );
				set('inverter_count', inverter_yield);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
		}

		if (subarray_x == 'Subarray 3') {
			//Value stays constant throughout simulation
			set('subarray3_modules_per_string', get('subarray1_modules_per_string'));	
			set('subarray3_track_mode', get('subarray1_track_mode'));
			set('subarray3_azimuth', get('subarray1_azimuth'));
			set('subarray3_shade_mode', get('subarray1_shade_mode'));
			set('subarray3_mod_orient', get('subarray1_mod_orient'));
			set('subarray3_nmody', get('subarray1_nmody'));
			
			//Updating optimized values based on user's selection
			if(update_results == 'Max AEP') {
				set('subarray3_nstrings', string_in_parallel_aep);
				set('subarray3_tilt', db{"max_energy"}.tilt);
				set('subarray3_gcr', db{"max_energy"}.gcr);
				set('subarray3_nmodx', db{"maxEnergy_config"}.nmodx);
				set('inverter_count', inverter_aep);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
			elseif(update_results == 'Max NPV'){
				set('subarray3_nstrings', string_in_parallel_npv );
				set('subarray3_tilt', db{"max_npv"}.tilt);
				set('subarray3_gcr', db{"max_npv"}.gcr);
				set('subarray3_nmodx', db{"npv_config"}.nmodx );
				set('inverter_count', inverter_npv);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
			elseif(update_results == 'Max Energy Yield') {
				set('subarray3_nstrings', string_in_parallel_yield  );
				set('subarray3_tilt', db{"max_yield"}.tilt);
				set('subarray3_gcr', db{"max_yield"}.gcr);
				set('subarray3_nmodx', db{"yield_config"}.nmodx );
				set('inverter_count', inverter_yield);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
		}

		if (subarray_x == 'Subarray 4') {
			//Value stays constant throughout simulation
			set('subarray4_modules_per_string', get('subarray1_modules_per_string'));	
			set('subarray4_track_mode', get('subarray1_track_mode'));
			set('subarray4_azimuth', get('subarray1_azimuth'));
			set('subarray4_shade_mode', get('subarray1_shade_mode'));
			set('subarray4_mod_orient', get('subarray1_mod_orient'));
			set('subarray4_nmody', get('subarray1_nmody'));
			
			//Updating optimized values based on user's selection
			if(update_results == 'Max AEP') {
				set('subarray4_nstrings', string_in_parallel_aep);
				set('subarray4_tilt', db{"max_energy"}.tilt);
				set('subarray4_gcr', db{"max_energy"}.gcr);
				set('subarray4_nmodx', db{"maxEnergy_config"}.nmodx);
				set('inverter_count', inverter_aep);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
			elseif(update_results == 'Max NPV'){
				set('subarray4_nstrings', string_in_parallel_npv );
				set('subarray4_tilt', db{"max_npv"}.tilt);
				set('subarray4_gcr', db{"max_npv"}.gcr);
				set('subarray4_nmodx', db{"npv_config"}.nmodx );
				set('inverter_count', inverter_npv);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
			elseif(update_results == 'Max Energy Yield') {
				set('subarray4_nstrings', string_in_parallel_yield  );
				set('subarray4_tilt', db{"max_yield"}.tilt);
				set('subarray4_gcr', db{"max_yield"}.gcr);
				set('subarray4_nmodx', db{"yield_config"}.nmodx );
				set('inverter_count', inverter_yield);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
		}


		//Reset values of subarray 1 (from before the macro was run):
		if(subarray_x != 'Subarray 1') {
			set('subarray1_modules_per_string',subarray1_modules_per_string);
			set('subarray1_nstrings', subarray1_nstrings);
			set('subarray1_track_mode', subarray1_track_mode);
			set('subarray1_tilt', subarray1_tilt);
			set('subarray1_azimuth', subarray1_azimuth);
			set('subarray1_gcr', subarray1_gcr);
			set('subarray1_shade_mode', subarray1_shade_mode);
			set('subarray1_mod_orient', subarray1_mod_orient);
			set('subarray1_nmody', subarray1_nmody);
			set('subarray1_nmodx', subarray1_nmodx);
			//set('inverter_count', inverter_count);
		}





///////////////////////////////////**** R E S U L T S ****///////////////////////////////////

str = '<html><body><h1> Summary of Results </h1><p>Reported for case: ' + active_case() + '</p>\n';

if(single_subarray == true) {
	str += '<br>Showing results for: ' + subarray_x;
	str += '<br><table bgcolor = #FFFF00><b>Note:</b> Optimal number of inverters reported are only for this particular subarray and not the entire system.</table>';
	str += '<p><i>(If you are using this macro to optimize all active subarrays, note down the recommended number of inverters for this subarray. Once you have optimized all active subarray configurations, add all the recommended number of inverters for each subarray to give you the recommended number of inverters for the entire system.)</i></p>';
}
else {
	str += '<br>Showing results for: '+ subarray_x;
	set('inverter_count', system_inverter_count);
}

str += '<p>Given below is the system size at each iteration of GCR for total effective land/roof area of ' + round(area);
str += ' (m^2). If you are only optimizing a single subarray, this table represents the subarray size (kW): </p>';
str += '';
iter = 0;
str += '<table>'; 
str += '<table border = "1">';
str += '<th>GCR </th>';
str += '<th>Size (kW)</th>';

for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 
	str += '<tr>';
	//str += '<th>GCR: ' + num_to_str( gcr , 3) + '</th>';
	str += '<th>' + num_to_str( gcr , 3) + '</th>';
	str += '<td align="center">';
	str += '	' + system_size[iter] ;
	str += '</td>';
	iter = iter + 1;
	str += '</tr>'; 
}
str += '</table>';


//Max AEP Results:
str += '<br><h5>Results for Max Annual Energy Production (AEP): </h5>';
str += '<br>GCR: ' + num_to_str(db{"max_energy"}.gcr , 3) ;
str += '<br>Tilt Angle (in Degrees): ' + db{"max_energy"}.tilt ; 
str += '<br>Number of modules along bottom: ' + db{"maxEnergy_config"}.nmodx + ' modules'; 
str += '<br>Number of modules along side of each row (note: this was set by the user in the active case): ' + nmody + ' module(s)';
str += '<br>Number of rows: ' + num_to_str(db{"maxEnergy_config"}.nrows , 1) + ' rows'; 
str += '<br>Row spacing estimate: ' + num_to_str( db{"maxEnergy_config"}.row_spacing, 2 ) + ' m';
str += '<br>Total number of modules: ' + db{"maxEnergy_config"}.total_modules + ' modules\n';
str += '<br>Modules per string in subarray (set by the user in the active case): ' + modules_per_string_aep + ' modules';
str += '<br>Strings in parallel in subarray: ' + string_in_parallel_aep + ' strings';
str += '<br>Number of inverters: ' + inverter_aep;
str += '<br><br>AEP: '+ num_to_str(db{"max_energy"}.energy , 0) + ' kWh';
str += '<br>System Size: '+ num_to_str(db{"max_energy"}.system_size , 0) + ' kW';
str += '<br>Net Present Value (NPV): $ '+ num_to_str(db{"max_energy"}.npv , 0);
str += '<br>Energy Yield: '+ num_to_str(db{"max_energy"}.yield , 1) + ' kWh/kW';





//Table for AEP Results
str += '<br><br><strong> AEP at Specified Combinations of GCR and Tilt Angles (kWH): <br></strong>';

str += '<table>'; 
str += '<table border = "1">';
str += '<th> </th>';
for (tilt = min_tilt  ; tilt <= max_tilt ; tilt = tilt + tilt_steps)
{
	str += '<th>Tilt Angle: ' + tilt + '</th>';
}

i = 0;
for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 
	j = -1;
	str += '<tr>';
	str += '<th>GCR: ' + num_to_str( gcr , 3 ) + '</th>';
	for (tilt = min_tilt ; tilt <= max_tilt ; tilt = tilt + tilt_steps) {
		j = j + 1;
		if (annual_energy[i][j] == db{"max_energy"}.energy) str += '<td bgcolor = #00ff00>';
		elseif (annual_energy[i][j]  < 0) str += '<td bgcolor = #ff0000>';
		else str += '<td>';
		str += ' ' + num_to_str(annual_energy[i][j] , 0) + ' '; 
		str += '</td>';
	}
	i = i + 1;
	str += '</tr>'; 
}

str += '</table>';
str += '<table>'; 
str += '<table>';
str += '<tr>'; 
str += '<td bgcolor = #00ff00>';
str += '<font size="2">Max AEP</font>';
str += '</tr>'; 
str += '</table>';



//Max NPV Results:
str += '<br><h5>Results for Max NPV: </h5>';
str += '<br>GCR: ' + num_to_str(db{"max_npv"}.gcr,3);
str +=  '<br>Tilt Angle (in Degrees): ' +  db{"max_npv"}.tilt;
str += '<br>Number of modules along bottom: ' + db{"npv_config"}.nmodx +' modules'; 
str += '<br>Number of modules along side of each row (note: this was set by the user in the active case): ' + nmody + ' module(s)';
str += '<br>Number of rows: ' + num_to_str(db{"npv_config"}.nrows,1) +' rows '; 
str += '<br>Row spacing estimate: ' + num_to_str(db{"npv_config"}.row_spacing , 2) + 'm';
str += '<br>Total number of modules: ' + db{"npv_config"}.total_modules + ' modules';
str += '<br>Modules per string in subarray (set by the user in the active case): ' + modules_per_string_npv + ' modules';
str += '<br>Strings in parallel in subarray: ' + string_in_parallel_npv + ' strings';
str += '<br>Number of inverters: ' + inverter_npv;
str += '<br><br>AEP: '+ num_to_str(db{"max_npv"}.energy,0) + ' kWh'; 
str += '<br>System Size : '+ num_to_str(db{"max_npv"}.system_size,0) + ' kW';
str += '<br>NPV: $ ' + num_to_str(db{"max_npv"}.npv,0);
str += '<br>Energy Yield: '+ num_to_str(db{"max_npv"}.yield,1) + ' kWh/kW';



//Table for NPV Results:
str += '<br><br><strong> NPV at Specified Combinations of GCR and Tilt Angles (in $): <br></strong>';

str += '<table>'; 
str += '<table border = "1">';
str += '<th> </th>';
for (tilt = min_tilt  ; tilt <= max_tilt ; tilt = tilt + tilt_steps)
{
	str += '<th>Tilt Angle: ' + tilt + '</th>';
}

i = 0;
for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 
	j = -1;
	str += '<tr>';
	str += '<th>GCR: ' + num_to_str( gcr , 3) + '</th>';
	for (tilt = min_tilt ; tilt <= max_tilt ; tilt = tilt + tilt_steps) {
		j = j + 1;
		if (npv[i][j] == db{"max_npv"}.npv) str += '<td bgcolor = #00ff00>';
		elseif (npv[i][j]  < 0) str += '<td bgcolor = #ff0000>';
		else str += '<td>';
		str += '$ ' + num_to_str(npv[i][j] , 0) + ' '; 
		str += '</td>';
	}
	i = i + 1;
	str += '</tr>'; 
}

str += '</table>';
str += '<table>'; 
str += '<table>';
str += '<tr>'; 
str += '<td bgcolor = #00ff00>';
str += '<font size="2">Max NPV</font>';
str += '</tr>'; 
str += '</table>';


//Max Energy Yield Results:
str += '<br><h5>Results for Max Energy Yield: </h5>';
str += '<br>GCR: '+ num_to_str(db{"max_yield"}.gcr , 3);
str += '<br>Tilt Angle (in Degrees): ' + db{"max_yield"}.tilt;
str += '<br>Number of modules along bottom: ' + db{"yield_config"}.nmodx +' modules';
str += '<br>Number of modules along side of each row (note: this was set by the user in the active case): ' + nmody + ' module(s)';
str += '<br>Number of rows: ' + num_to_str(db{"yield_config"}.nrows,1) + ' rows'; 
str += '<br>Row spacing estimate: ' + num_to_str(db{"yield_config"}.row_spacing,2) + ' m';
str += '<br>Total number of modules: ' + db{"yield_config"}.total_modules + ' modules';
str += '<br>Modules per string in subarray (set by the user in the active case): ' + modules_per_string_yield + ' modules';
str += '<br>Strings in parallel in subarray: ' + string_in_parallel_yield + ' strings';
str += '<br>Number of inverters: ' + inverter_yield;
str += '<br><br>AEP: '+ num_to_str(db{"max_yield"}.energy,0) + ' kWh ' ; 
str += '<br>System Size: '+ db{"max_yield"}.system_size + ' kW';
str += '<br>NPV: $ ' + num_to_str(db{"max_yield"}.npv,0) ; 
str += '<br>Energy Yield: '+ num_to_str(db{"max_yield"}.yield,1) + ' kWh/kW';


//Table for Energy Yield Results:
str += '<br><br><strong>Energy Yield at Specified Combinations of GCR and Tilt Angles (kWh/kW): <br></strong>';

str += '<table>'; 
str += '<table border = "1">';
str += '<th> </th>';
for (tilt = min_tilt  ; tilt <= max_tilt ; tilt = tilt + tilt_steps)
{
	str += '<th>Tilt Angle: ' + tilt + '</th>';
}

i = 0;
for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 
	j = -1;
	str += '<tr>';
	str += '<th>GCR: ' + num_to_str( gcr , 3) + '</th>';
	for (tilt = min_tilt ; tilt <= max_tilt ; tilt = tilt + tilt_steps) {
		j = j + 1;
		if (yield[i][j] == db{"max_yield"}.yield) str += '<td bgcolor = #00ff00>';
		elseif (yield[i][j]  < 0) str += '<td bgcolor = #ff0000>';
		else str += '<td>';
		str += ' ' + num_to_str(yield[i][j], 0) + ' '; 
		str += '</td>';
	}
	i = i + 1;
	str += '</tr>'; 
}

str += '</table>';
str += '<table>'; 
str += '<table>';
str += '<tr>'; 
str += '<td bgcolor = #00ff00>';
str += '<font size="2">Max Energy Yield</font>';
str += '</tr>'; 
str += '</table>';





///////////////////////////////////**** P L O T T I N G ****///////////////////////////////////

clr = ['#FF0000',	'#00FFFF',	'#FF00FF',	'#0000A0',	'#9ACD32',	'#800080',	'#FFFF00',	'#00FF00',	'#0000FF',	'#C0C0C0',	'#808080',	
	   '#000000',	'#FFA500',	'#A52A2A',	'#800000',	'#008000',	'#F08080', 	'#90EE90',	'#FFB6C1',	'#FFA07A',	'#20B2AA',	'#87CEFA',	
	   '#778899',	'#778899',	'#FFFFE0',	'#00FF00',	'#32CD32',	'#FAF0E6',	'#FF00FF',	'#800000',	'#66CDAA',	'#0000CD',	'#BA55D3',	
	   '#9370DB',	'#3CB371',	'#7B68EE',	'#00FA9A',	'#48D1CC',	'#C71585',	'#191970',	'#F5FFFA',	'#FFE4E1',	'#FFE4B5',	'#FFDEAD',	
	   '#000080',	'#FDF5E6',	'#808000',	'#6B8E23',	'#FFA500',	'#FF4500',	'#DA70D6',	'#EEE8AA',	'#98FB98',	'#AFEEEE',	'#DB7093',	
	   '#FFEFD5',	'#FFDAB9',	'#CD853F',	'#FFC0CB',	'#DDA0DD',	'#B0E0E6',	'#800080',	'#663399',	'#FF0000',	'#BC8F8F',	'#4169E1',	
	   '#8B4513',	'#FA8072',	'#F4A460',	'#2E8B57',	'#FFF5EE',	'#A0522D',	'#C0C0C0',	'#87CEEB',	'#6A5ACD',	'#708090',	'#708090',	
	   '#FFFAFA',	'#00FF7F',	'#4682B4',	'#D2B48C',	'#008080',	'#D8BFD8',	'#FF6347',	'#40E0D0',	'#EE82EE',	'#F5DEB3', 	'#F5F5F5',	
	   '#FFFF00',	'#ADD8E6'];

//Plotting the AEP as a function of tilt angle (for various GCRs):
newplot();
for ( count = 0; count <= (#annual_energy - 1) ; count = count + 1) {
	plot(x, annual_energy[count],{series = type[count], color = clr[count], size = 3});
	axis('x1', {'label' = "Tilt Angle "});
	axis('y1', {'label' = "Annual Energy Production  (kWh)"});
	plotopt({'legendpos'='right', 'export_graph' = true, 'coarse'=true, 'fine'=true, 'title' = "Annual Energy Production at Various GCR [" + subarray_x + "]"});
}


//Plotting the NPV as a function of tilt angle (for various GCRs):
newplot();
for ( k = 0; k <= (#annual_energy - 1) ; k = k + 1) {
	plot(x, npv[k],{series = type[k], color = clr[k], size = 3});
	axis('x1', {'label' = "Tilt Angle"});
	axis('y1', {'label' = "Net Present Value  ($)"});
	plotopt({'legendpos'='right', 'coarse'=true, 'fine'=true, 'title' = "Net Present Value at Various GCR [" + subarray_x + "]"});
}


//Plotting the energy yield as a function of tilt angle (for various GCRs):
newplot();
for ( l = 0; l <= (#annual_energy - 1) ; l = l + 1) {
	plot(x, yield[l],{series = type[l], color = clr[l], size = 3});   //This is the energy yield of the system
	axis('x1', {'label' = "Tilt Angle "});
	axis('y1', {'label' = "Energy Yield  (kWh/kW)"});
	plotopt({'legendpos'='right', 'coarse'=true, 'fine'=true, 'title' = "Energy Yield at Various GCR [" + subarray_x + "]"});
}


str += '</body></html>';
html_dialog(str, 'Optimal Array Layout', [1000,800]);


subarray_to_optimize++;
if(single_subarray == true) break;			//If user is optimizing only a single subarray, exit the while loop, i.e., end the macro at this point.

}

///////////////////////////////////**** End of Script ****///////////////////////////////////

outln('\n//////***** Simulation Complete *****//////');



////////////Function Declarations//////////////////////



