/*@
<p>This macro generates a report with information to help you size a photovoltaic system and a list of modules that meet your sizing requirements.</p>
<p><strong>Instructions:</strong></p>
<ol>
<li>The <b>Annual DC degradation</b> parameter at right is for the DC/AC Ratio assumptions table (Table 3) in the report. Enter a value to represent the worst-case for an estimate of end-of-life DC/AC ratio.</li>
<li>The minimum, maximum, and adjustment temperatures are for the worst case Voc calculations as described in the Bill Brooks article <a href="https://solarprofessional.com/articles/design-installation/array-voltage-considerations">Array Voltage Considerations</a>, Solar Pro Magazine Issue 3.6 Oct/Nov 2010. The macro displays a table showing Voc at these temperatures along with the minimum and maximum operating Voc values calculated by SAM.
<li>The maximum DC/AC ratio affects the list of recommended modules. The macro will only list modules that result in a DC/AC ration less than or equal to the value you specify.
<li>By default, the macro displays a report in a SAM window. If you want to export the report, choose Yes for <b>Show results in default browser?</b> to save the report as an HTML file and open it in your default browser. You can then use the browser's tools to export it to PDF or another format.
</ol>
<p>&nbsp;</p>

@*/

//@ name=dc_degradation;type=number;label=Annual DC degradation (%);value=0.5
//@ name=t_min;type=number;label=Minimum temperature (C);value=-3
//@ name=t_max;type=number;label=Maximum temperature (C);value=46
//@ name=t_adj;type=number;label=Adjustment temperature (C);value=30
//@ name=dcac_max;type=number;label=Maximum DC/AC ratio;value=1.3
//@ name=show_in_browser;type=combo;label=Show results in default browser?;value=Yes,No;sel=1

// to run as script for troubleshooting, set troubleshoot = false to use sample inputs
// otherwise, display warning if the macro is run outside of a case
troubleshoot = false;
if ( troubleshoot ) // sample inputs
{
	macro.dc_degradation = 0.5;
	macro.t_min = -3;
	macro.t_max = 46;
	macro.t_adj = 30;
	macro.dcac_max = 1.3;
	macro.show_in_browser = 1;
}
elseif ( typeof(macro) == 'unknown' ) {
	msgbox('This macro must be run from within a case.');
	exit;
}

//Max number of subarrays allowed in SAM:
max_subarrays = 4;

////////////////////////////////////////////////////////////////////////////////
// Functions
////////////////////////////////////////////////////////////////////////////////

function deg_f( deg_c ) { return deg_c * 9/5 + 32; }

function deg_c( deg_f ) { return ( deg_f - 32 ) * 5/9; }

// format numbers comma thousands indicator, 2 decimal places
// note: will display integers with 2 decimals, e.g., display 3 as 3.00
function num_to_str( x , d )
{
	// only format x if it is a number
	if ( typeof(x) == 'number' )
	{
		// The sprintf() function in this step converts a number (for d = 0) like 409.857 to 41 instead of 410.
		// This if-else condition is a workaround that bug.
		if( ( d == 0) && (mod( round(x) , 10) <= 0) )	
			{
				x = round(x);
				str = sprintf('%,',x);
			}
		else 
			{ str = sprintf('%.'+to_string(d)+',',x); }

		arr = split(str,'.');
		if ( #arr > 1 )
			{ num_decs = strlen(to_string(arr[1])); }
		else
			{ num_decs = 0; }
		// if number has one or more decimal places less than the desired number	
		if ( #arr > 1 && num_decs < d)
		{
			for (i=0; i<d-num_decs; i++)
				{ str += '0'; }
		}
		// if number has no decimal places
		elseif ( #arr == 1 && d > 0 )
		{
			str += '.';
			for (i=0; i<d; i++)
				{ str += '0'; }
		}
	}
	// if x is a string, return it
	elseif ( typeof(x) == 'string' )
		{ str = x; }
	// if x is not a number or string, convert it to a string with no formatting	
	else	
		{ str = to_string( x ); }
	return str;
}

// given an input array, return an output array with input array's last x rows
function shorten_array( arr_in, x )
{
	if ( #arr_in <= x ) { return arr_in; }
	j = 0;
	arr_out = [];
	i_start = #arr_in - x;
	for (i = 0; i<#arr_in; i++ )
	{
		if ( i >= i_start ) 
		{
			arr_out[j] = arr_in[i];
			j++;
		}
	}
	return arr_out;
}

// generate an html table from an array of data given parameters as table:
// { 'arr' = array of data , 
//   'row_headers' = true/false make row headers bold ,
//   'title' = string for table title displayed centered in bold above table }
// if a table cell value in arr is passed as an 
// array [ value, max limit 1, max limit 2], change background color of cell 
// based on value
function html_table ( T ) // arr, row_headers, title
{
	rows = #T.arr;
	cols = #T.arr[0];
	if ( T.title == '' ) { h = ''; }
	else { 	h = '<p align="center"><font face="Segoe UI"; size="3">' + T.title + '</font></p>'; }
	h += '<table bgcolor="#dddddd" width="100%">\n';
	for ( i=0; i<rows; i++ )
	{
		attr = '';
		if ( mod( i, 2 ) != 0 ) { attr = ' bgcolor="#ffffff"'; } // alternate stripes
		h += '<tr' + attr + '>';
		for ( j=0; j < cols; j++ )
		{
			bgcolor = '';
			data = T.arr[i][j];
			if ( data == '' || data == ' ' ) { data == '&nbsp;'; }
			if ( i == 0 ) { h += '<th>' + data + '</th>'; } // column headings for first row
			elseif ( j == 0 && T.row_headers == true )  { h += '<th align="left">' + data + '</th>'; }
			elseif ( typeof(data) == 'array' && #data == 3 ) // [data,max limit 1,max limit 2]	
			{
				if ( data[0] > data[2] ) { bgcolor = ' bgcolor = #bd0026';} // max limit 2 exceeded
				elseif ( data[0] > data[1] ) { bgcolor = ' bgcolor = #fd8d3c'; } // max limit 1 exceeded
				h += '<td align="right"' + bgcolor + '>' + num_to_str(data[0], 2) + '</td>';
			}
			elseif ( typeof(data) == 'array' && #data == 2 ) // [min,max]
				{ h += '<td align="center">' + num_to_str(data[0], 2) + ' &ndash; ' + num_to_str(data[1], 2) + '</td>'; }
			elseif ( typeof(data) == 'number' ) { h += '<td align="right">' + num_to_str(data, 2) + '</td>'; }
			elseif ( typeof(data) == 'string' )	{ h += '<td align="left">' + data + '</td>'; }
			else { h += '<td>' + data + '</td>'; }
		}		
		h += '</tr>\n';
	}	
	h += '</table>\n';
	return h;
}

// generate a bar graph with vertical lines indicating min and max values given
// parameters as table
// if export_graph is true, return path to .png file with image of graph
// { 'bar_data' = 1D array of values to be displayed as horizontal bars 
//   'line_data' = 1D array of two or three values to be displayed as vertical lines 
//   'y_labels' = 1D array of strings with a label for each bar
//   'bar_label' = string with label for legend describing bar
//   'line_labels' = 1D array of two or three strings for legend describing each vertical line
//   'export_graph' = true/false export graph as png file named from title string }
function bar_graph_with_limit_lines( T )
{
	x_axis_max = max( [max(T.bar_data), max(T.line_data)] );
	// x axis adjustment only works for values in the range of 0 to about 1000
	if ( x_axis_max / 100 > 1 ) { x_axis_max = ( to_int( x_axis_max / 100 ) + 1 ) * 100; }
	else { x_axis_max = ( to_int( x_axis_max / 10 ) + 1 ) * 10; }
	y_axis_max = #T.y_labels + 1; 
	line_width = 3;
	if ( #T.line_data == 2 ) { line_colors = ['#fd8d3c','#f03b20']; } // 2 lines
	else { line_colors = ['#fd8d3c','#f03b20','#bd0026']; }// 3 lines	
	bar_width = 20;
	bar_color = '#457585';
	y1 = [ 0, #T.bar_data+1 ];
	newplot( true );
	for ( i=0; i<#T.bar_data; i++ )
	{
		if ( i == 0 ) { plot( [0,T.bar_data[i]], [0,i+1] , {'type'='hbar', 'baseline' = 0, 'color' = bar_color, 'thick'= bar_width, 'series'=T.bar_label } ); }
		else { plot( [0,T.bar_data[i]], [0,i+1] , {'type'='hbar', 'baseline' = 0, 'color' = bar_color, 'thick'= bar_width } ); }
		labels[i] = [ i+1,T.y_labels[i] ]; // [[1,T.y_labels[0]],[2,T.y_labels[1]],[3,T.y_labels[2]]]
	}
	plot( [ T.line_data[0] , T.line_data[0] ], y1, {'yap'='left', 'color'= line_colors[0], 'thick' = line_width , 'series'=T.line_labels[0] });
	plot( [ T.line_data[1] , T.line_data[1] ], y1, {'yap'='left', 'color'= line_colors[1], 'thick' = line_width , 'series'=T.line_labels[1] });
	if ( #T.line_data == 3 ) { plot( [ T.line_data[2] , T.line_data[2] ], y1, {'yap'='left', 'color'= line_colors[2], 'thick' = line_width , 'series'=T.line_labels[2] }); }
	axis( 'y1', { 'type' = 'label', 'labels' = labels, 'min' = 0, 'max' = y_axis_max } );
	axis( 'x1', {'label'='VDC', 'min' = 0, 'max' = x_axis_max } );
	plotopt( {	'title' = T.title, 'legend' = true, 'scale' = 1, 'font' = 'Segoe UI', 'window' = [10,10,600,300], 'border' = 1, 'fine' = true, 'coarse' = true } );	
	if ( T.export_graph )
	{
		f_path=cwd();
		f_name = replace( T.title , ' ' , '_' );
		f_name = replace( f_name, ':' , '' );
		f_name = replace( f_name, '.' , '' );
		f_name = replace( f_name, '__' , '_' );
		f = f_path + '/' + f_name  + '.png';
		ok = plotout( f , 'png'); // png, pdf, bmp, or jpg. Defaults to png if file type not given.
		if ( ok == false)
		{
			outln('Could not save the plot to ' + f);
			return null;

		}
		else { return f; }
	}
}

// return table of module parameters, except SPE module model return null
function get_module_parameters( )
{
	model = get('module_model');
	T = null;
	T.lib = {};
	lib_dir = left(runtimedir(),strlen(runtimedir())- 8) + 'libraries/';
	
	// if( model == 0) // simple efficiency model
		// T = null; 
		
	if(model == 1) // CEC performance model with module database
	{
		T.name = get('module_name');
		T.voc	= get('cec_v_oc_ref');
		T.bvoc = get('cec_beta_oc') / T.voc * 100;
		T.vmp = get('cec_v_mp_ref');
		T.pmp = get('cec_p_mp_ref');
		T.gpmp = get('cec_gamma_r');
		T.manufacturer = get('lib_manufacturer');
		if ( get('cec_temp_corr_mode') == 0 ) // noct method
		{
			mount = get('cec_standoff'); 
			if ( mount == 6 ) T.mounting = 'ground';
			elseif ( mount == 0 ) T.mounting = 'building-integrated';
			else T.mounting = 'roof';
		}
		else
		{
			mount = get('cec_mounting_config');
			if ( mount == 0 ) T.mounting = 'ground';
			elseif ( moutn == 2 ) T.mounting = 'building-integrated';
			else T.mounting = 'roof';
		}
		T.lib = csvread( lib_dir + 'CEC Modules.csv', { "delim"=',', "skip"=2, "table"=true });
		// cec library column labels for module name, manufacturer, voc, vmp, imp
		T.lib_name = '[0]';
		T.lib_manufacturer = 'lib_manufacturer';
		T.lib_voc = 'cec_v_oc_ref'; 
		T.lib_vmp = 'cec_v_mp_ref'; 
		T.lib_imp = 'cec_i_mp_ref';
	}

	if(model == 2) // CEC performance model with user entered specifications
	{
		T.name = 'User-defined CEC parameters';
		T.voc = get('6par_voc');
		T.bvoc = get('6par_bvoc') / T.voc * 100;
		T.vmp = get('6par_vmp');
		T.pmp = T.vmp * get('6par_imp');	
		T.gpmp = get('6par_gpmp');
		mount = get('6par_standoff'); 
		if ( mount == 6 ) T.mounting = 'ground';
		elseif ( mount == 0 ) T.mounting = 'building-integrated';
		else T.mounting = 'roof';
	}

	if(model == 3) // Sandia PV array performance model with module database												
	{
		T.name = get('snl_module_name');
		T.voc = get('snl_ref_voc');
		T.bvoc = get('snl_bvoco') / T.voc * 100;
		T.vmp = get('snl_ref_vmp');
		T.pmp = get('snl_ref_pmp');
		T.gpmp = get('snl_ref_pmp_temp_0');
		T.lib = csvread( lib_dir + 'Sandia Modules.csv',{ "delim"=',', "skip"=2, "table"=true });
		dt = get('snl_ref_dT'); 
		if ( dt >= 3 ) T.mounting = 'ground';
		else T.mounting = 'roof';
		// sandia library column labels for module name, voc, vmp, imp
		T.lib_name = '[0]';
		T.lib_voc = 'snl_voco'; // column labels for voc, vmp, imp in sandia library
		T.lib_vmp = 'snl_vmpo'; 
		T.lib_imp = 'snl_impo';
	}

	if(model == 4) // IEC 61853 Single diode model
	{
		T.name = 'User-defined IEC parameters';
		T.voc = get('sd11par_Voc0');
		T.bvoc = get('sd11par_betaVoc') / T.voc * 100;
		T.vmp = get('sd11par_Vmp0');
		T.pmp = T.vmp * get('sd11par_imp0');
		T.gpmp = get('sd11par_gammaPmp');
		mount = get('sd11par_standoff'); 
		if ( mount == 6 ) T.mounting = 'ground';
		elseif ( mount == 0 ) T.mounting = 'building-integrated';
		else T.mounting = 'roof';
	}

return T;

}

// return table of inverter parameters
function get_inverter_parameters() 
{

	model = get('inverter_model');
	T = null;
	lib_dir = left(runtimedir(),strlen(runtimedir())- 8) + 'libraries/';

	if(model == 0) // Inverter CEC Database
	{
		T.name = get('inv_snl_inverter_name');
		T.vdcmax 	= get('inv_snl_vdcmax');
		T.vmppt_min 	= get('inv_snl_mppt_low');
		T.vmppt_max 	= get('inv_snl_mppt_hi');
		T.pdco 	= get('inv_snl_pdco');
		T.lib_name = '[0]';
	}

	if(model == 1) // Inverter Datasheet
	{
		T.name = 'User-defined datasheet parameters';
		T.vdcmax = get('inv_ds_vdcmax');
		T.vmppt_min = get('inv_ds_mppt_low');
		T.vmppt_max = get('inv_ds_mppt_hi');
		T.pdco	= get('inv_ds_pdco');
	}
	
	if(model == 2) // Inverter Part Load Curve
	{
		T.name = 'User-defined part-load curve parameters';
		T.vdcmax = get('inv_pd_vdcmax');
		T.vmppt_min = get('inv_pd_mppt_low');
		T.vmppt_max = get('inv_pd_mppt_hi');
		T.pdco = get('inv_pd_pdco');
	}
		
	if(model == 3) // Inverter CEC coefficient generator
	{
		T.name = 'User-defined coefficient parameters';
		T.vdcmax = get('inv_cec_cg_vdcmax');
		T.vmppt_min	= get('inv_cec_cg_mppt_low');
		T.vmppt_max	= get('inv_cec_cg_mppt_hi');
		T.pdco = get('inv_cec_cg_pdco');
	}
	
	return T;
}

////////////////////////////////////////////////////////////////////////////////
// get input variables from SAM input pages and macro interface
////////////////////////////////////////////////////////////////////////////////
outln('Getting input parameters.');
module = get_module_parameters();
inverter = get_inverter_parameters();
if ( module == null  ||  inverter == null )
{
	msgbox('Macro does not work with the Simple Efficiency module model.\nThe macro calculations require the open-circuit voltage temperature coefficient parameter. Choose a different module model to use this macro.');
	exit;
}

// get analysis period if there is a financial model
financial = true;
analysis_period = 1;
if (configuration()[1] == 'None') { financial = false; }
if ( financial ) { analysis_period = get( 'analysis_period' ); }
 
//Get configuration info of all subarrays 
for(i = 0; i < max_subarrays ; i++) 
{
	modules_per_string[i] = get('subarray' + to_string(i + 1) + '_modules_per_string'); // need to calculate string voc, and pmp_string for number of strings suggestion (subarray 1)
	strings_in_parallel[i] = get('subarray' + to_string(i + 1) + '_nstrings'); // calculate suggested number of strings in parallel to reduce power limiting (subarray 1)
}

num_modules = get('total_modules');
num_inverters = get('inverter_count');
nameplate_dc = get('system_capacity');
nameplate_ac = get('total_inverter_capacity');

// run simulation and quit if simulation fails
outln('Running simulation to get operating voltages.');
sim_msg = '';
msg_len = 500;
ok = simulate( sim_msg , true );
if ( strlen( sim_msg ) > msg_len ) { sim_msg = left(sim_msg, msg_len ) + '...'; }
if ( !ok )
{
	msgbox( 'Simulation Failed!\nThere is a problem with your inputs that caused the simulation to fail with the following message:\n\n' + sim_msg + '\n\nPlease correct the problem and try running the macro again.');
	exit;
}
elseif ( sim_msg != '' )
{
	msgbox( 'Simulation completed with messages.\nReview the simulation messages and correct any problems with your inuts:\n\n' + sim_msg + '\n\nMacro results will be based on these simulation results.');
}

////////////////////////////////////////////////////////////////////////////////
// DC-AC ratio scenarios
////////////////////////////////////////////////////////////////////////////////
outln('Setting up scenarios.');
// TO DO: Handle different degradation input options from the Lifetime page
module_degrad = 1 - macro.dc_degradation/100; // annual DC degradation as macro input for now
dcac_min = 1.1; 
dcac_max = macro.dcac_max;

// dc-ac ratio at nameplate
nameplate_dcac = nameplate_dc / nameplate_ac; //nameplate DC capacity over nameplate AC capacity

// derated dc-ac ratio for LID and degradation scenarios 
lid[0] = 1;
lid[1] = 0.985; // 1.5% for mono-Si
lid[2] = 0.98; // 2% for multi-Si
lid[3] = 0.97; // 3% for worst-case

last_yr_dcac = [];
for ( i=0; i<#lid; i++ )
{
	first_yr_dcac[i] = nameplate_dcac * lid[i];
	if ( analysis_period > 1 )
		last_yr_dcac[i] = ( ( nameplate_dc * lid[i] ) * pow( module_degrad, analysis_period ) ) / nameplate_ac; //effective DC capacity at end of system lifetime after LID and panel degradation, over nameplate AC capacity (no inverter degradation)
}

////////////////////////////////////////////////////////////////////////////////
// Power losses due to inverter clipping and power limiting
////////////////////////////////////////////////////////////////////////////////

// acceptable clipping time limits
clipping_time_moderate = 0.05; // fraction of year
clipping_time_severe = 0.10;

// acceptable clipping energy limits
clipping_energy_moderate = 0.20; // fraction of kWh/year
clipping_energy_severe = 0.50;

// power limiting when DC input power exceeds inverter rating
inv_dc_input = get('annual_dc_net');
inv_ac_output = get('annual_ac_gross');
inv_dc_input_ts = get('dc_net');
inv_power_at_capacity_num_ts=0;
for (i=0; i<#inv_dc_input_ts; i++)
{
	if ( inv_dc_input_ts[i] >= inverter.pdco * num_inverters / 1000 )
		{ inv_power_at_capacity_num_ts++; }
}
inv_dc_input_ts = null;		
inv_powerlimitloss_ts = get('inv_cliploss');		//Gets time series data of inverter clipping losses
num_ts = #inv_powerlimitloss_ts;
inv_powerlimitloss_max = max(inv_powerlimitloss_ts);
inv_powerlimitloss = sum(inv_powerlimitloss_ts);
inv_powerlimitloss_num_ts = 0;
for (i=0; i<#inv_powerlimitloss_ts; i++)
{
	if(inv_powerlimitloss_ts[i]>0)
		{ inv_powerlimitloss_num_ts++; }
}
inv_powerlimitloss_ts = null;
inv_powerlimitloss_percent_dc = inv_powerlimitloss / inv_dc_input * 100;
inv_powerlimitloss_percent_ac = inv_powerlimitloss / inv_ac_output * 100;

// first-year inverter mppt voltage clipping
mpptloss_ts = get('dc_invmppt_loss');
mpptloss_max = max(mpptloss_ts);
mpptloss = sum(mpptloss_ts);
mpptloss_num_ts = 0; //how many hours are clipped per year
for (i=0; i<#mpptloss_ts; i++)
{
	if(mpptloss_ts[i]>0)
		{ mpptloss_num_ts++; }
}
mpptloss_ts = null;
mpptloss_percent_dc = mpptloss / inv_dc_input * 100;
mpptloss_percent_ac = mpptloss / inv_ac_output * 100;

////////////////////////////////////////////////////////////////////////////////
// Voltage limits
////////////////////////////////////////////////////////////////////////////////

// operating voltages from simulation results: voc_hi, vdc_hi, and vdc_lo
subarrays = [1, 0, 0, 0]; //subarray1 is always enabled
vdc_hi = [-999, -999, -999, -999]; //initialize arrays for each subarray
vdc_low = [999, 999, 999, 999];
sunup = get('sunup');
t_dry = get('tdry');
t_dry_min = min(t_dry);
t_dry_max = max(t_dry);
t_dry = null;
t_stc = 25;
vlow_boundary = false;		//[T-F] When set to True, it ignores the hours of sunrise and sunset when voltage input to the inverter is rapidly rising/dropping when recording Vdc for vdc_low;
		
for (j=0; j<max_subarrays; j++) //loop through subarrays
{
	if(j>0) //subarray 1 is always enabled
	{
		if (get(('subarray' + (j+1) + '_enable')) == 0) //skip over disabled subarrays
			{ continue; }
		else
			{ subarrays[j] = 1; }
	}
	var_str = 'subarray' + to_string(j+1) + '_dc_voltage';
	vdc_ts = get(var_str); //Volts
	vdc_hi[j] = max(vdc_ts); //Volts
	var_str = 'subarray' + to_string(j+1) + '_voc';
	voc_ts = get(var_str); //Volts
	voc_hi[j] = max(voc_ts); //Volts
	
	//Loop for sampling V inputs to the inverter, and recording the lowest Vdc input in the year:
	for(i=0; i<8760;i++)
	{
		if(sunup[i] == 0)
			{ vlow_boundary = false; }		//Ignores voltage values during night time	
		
		if(sunup[i] == 1) 
		{
			//Ignoring the hour up until sunrise is complete:
			if((sunup[i-1] == 0) && (vdc_ts[i] > 0)) 		//If sunrise happened in the previous hour (Sometimes sunup jumps from 0 to 1)
				{ vlow_boundary = true; }
			elseif((sunup[i-1] == 2) && (vdc_ts[i] > 0)) 	//Sometimes sunup jumps from 0 to 1 rather than 0 to 2
				{ vlow_boundary = true; }
			//Ignore the final hour when the sun is setting - and Vdc input to the inverter is rapidly falling
			if((sunup[i+1] == 3) || (sunup[i+1] == 0))
				{ vlow_boundary = false; }
			//Candidate for lowest Vdc input to the inverter will now only be recorded between (and excluding) the hours of sunrise & sunset:
			if((vlow_boundary != false ) && (vdc_ts[i] < vdc_low[j])) //lowest voltage seen when the sun is up (system is operating)			
				{ vdc_low[j] = vdc_ts[i]; } //Volts
		}
	}
	vdc_ts = null;
	voc_ts = null;
}

// worst case design Voc
// from Brooks (2010) "Array Voltage Considerations" Solar Pro Magazine Issue 3.6 Oct/Nov 2020
vmp_min_design = ( module.vmp + ( macro.t_max + macro.t_adj - t_stc ) * module.gpmp/100 * module.vmp ); // single module
voc_max_design = ( module.voc + ( macro.t_min - t_stc ) * module.bvoc/100 * module.voc ); // single module

////////////////////////////////////////////////////////////////////////////////
// design suggestions
////////////////////////////////////////////////////////////////////////////////
out('Generating design suggestions ');
// check 1: number of strings based on dc-ac ratio
dcac_ok = true;
//n = 0;
//strings_in_parallel_new = strings_in_parallel[0];

if ( nameplate_dcac < dcac_min || nameplate_dcac > dcac_max ) 
	{ dcac_ok = false; }

// check 2: modules per string based on temperature-adjusted voc
modules_per_string_max = floor( inverter.vdcmax / voc_max_design );
modules_per_string_min = ceil( inverter.vmppt_min / vmp_min_design );
voc_system = true;
max_modules_per_string = 0;
for ( i = 0 ; i < max_subarrays ; i++) 
{
	this_modules_per_string = modules_per_string[i];
	if ( max_modules_per_string < this_modules_per_string ) { max_modules_per_string = this_modules_per_string; }
	voc_ok[i] = true;
	if ( (voc_max_design * modules_per_string[i] ) > inverter.vdcmax ) // temperature adjusted array voc > inverter vdcmax 
		{ voc_ok[i] = false; }
	if(voc_ok[i] == false) 
		{ voc_system = false; }
}

modules_same = [];
modules_diff = [];
if ( module.lib != {} ) // module model has library
{
	voc_old = to_int( module.voc * 100 ) / 100;
	pmp_old = to_real( module.pmp );
	voc = module.lib_voc;
	vmp = module.lib_vmp;
	imp = module.lib_imp;
	name = module.lib_name;
	manufacturer = module.lib_manufacturer;
	num_same = 0;
	num_diff = 0;
	num_modules_in_library = #module{'lib'}{name};
	outln(' based on ' + num_modules_in_library + ' modules in library.');
	for (i = 0; i < num_modules_in_library; i++) // i=0 is header
	{
		voc_new = to_int( to_real( module{'lib'}{voc}[i] ) * 100 ) / 100;
		pmp_new = to_real( module{'lib'}{vmp}[i] ) * to_real( module{'lib'}{imp}[i] );
		dcac_new = pmp_new / 1000 * num_modules / nameplate_ac;
		module_ok =
				( voc_new > vmp_min_design ) && ( voc_new < voc_max_design ) && // new module voc is within design limits
				voc_new * max_modules_per_string < inverter.vdcmax && // subarray with longest string new voc is less than inverter mppt_max
				//abs( voc_old - voc_new )  < 2 && // voc of new module is reasonably close to voc of old module
				//pmp_new >= 0.9 * pmp_old && // pmp of new modules is within 90% of old module to assure dc/ac ratio is within acceptable range
				( dcac_new > dcac_min && dcac_new < dcac_max ) &&
				lower(module.name) != lower(module{'lib'}{name}[i]); // new module is not same as old module, capitalization is not consistent in library
		if ( module_ok && lower(module.manufacturer) == lower(module{'lib'}{manufacturer}[i]) )
		{	
			modules_same[num_same] = [ module{'lib'}{name}[i] , pmp_new , voc_new ];
			num_same++;
		}
		elseif ( module_ok )
		{
			modules_diff[num_diff] = [ module{'lib'}{name}[i], pmp_new , voc_new ];
			num_diff++;
		}
	}
}

// sort module tables by rated string Voc
stable_sort(modules_same,2);
stable_sort(modules_diff,2);
num_modules_same = #modules_same;
num_modules_diff = #modules_diff;
modules_same = shorten_array(modules_same, 50);
modules_diff = shorten_array(modules_diff, 50);

////////////////////////////////////////////////////////////////////////////////
// Create graphs as .png files
////////////////////////////////////////////////////////////////////////////////

num_plots = 0;
for ( j=0; j < max_subarrays; j++ )
{
	if ( vdc_hi[j] > -999 )
	{
		if ( sum(subarrays) > 1 )
			pre_str = 'Subarray ' + to_string(j+1) + ' ';
		else
			pre_str = '';
		// if Vmppt_max != Vdc_max, show a line for each value in graph, 
		// otherwise show one line for both
		if ( inverter.vmppt_max == inverter.vdcmax )
		{
			line_labels = ['V_mpptmin','V_mpptmax = V_dcmax'];
			line_data = [ inverter.vmppt_min , inverter.vmppt_max ];
		}
		else
		{
			line_labels = ['V_mpptmin','V_mpptmax', 'V_dcmax'];
			line_data = [ inverter.vmppt_min , inverter.vmppt_max , inverter.vdcmax ];
		}	
			
		voperating_graphs[num_plots] = bar_graph_with_limit_lines( {
			'title' = 'Figure ' + to_string(num_plots+1) + ': ' + pre_str + 'String Voltages', // underscore makes subscript
			'line_data' = line_data, // vmppt_min, vmppt_max, and Vdcmax if Vdcmax != Vmppt_max
			'line_labels' = line_labels,
			'bar_data' = [voc_max_design * modules_per_string[j], voc_hi[j], vdc_hi[j], vdc_low[j], vmp_min_design * modules_per_string[j] ], // one value for each bar
			'bar_label' = '',
			'x_label' = 'VDC',
			'y_labels' = ['Max Design Voc','Max Operating Voc','Max Operating Vdc','Min Operating Vdc','Min Design Vdc'], // one label for each bar
			 'export_graph' = true} );
		num_plots++;
	}	
}

////////////////////////////////////////////////////////////////////////////////
// Arrays of data to be exported to HTML or CSV
////////////////////////////////////////////////////////////////////////////////
tabletitle_params = 'Parameters Used for System Sizing';
tabledata_params[0][0] = 'Parameter';
tabledata_params[0][1] = 'Value';
tabledata_params[1][0] = 'Module Capacity, Pmp (W)';
tabledata_params[1][1] = module.pmp;
tabledata_params[2][0] = 'Inverter DC capacity, Pdco (W)';
tabledata_params[2][1] = inverter.pdco;
tabledata_params[3][0] = 'Inverter MPPT voltage range, Vmppt_min &ndash; Vmppt_max (VDC)';
tabledata_params[3][1] = [ inverter.vmppt_min , inverter.vmppt_max ];
tabledata_params[4][0] = 'Inverter maximum voltage, Vdcmax (VDC)';
tabledata_params[4][1] = inverter.vdcmax;
tabledata_params[5][0] = 'String open circuit voltage, Voc (VDC)';
tabledata_params[5][1] = module.voc * modules_per_string[0];
tabledata_params[6][0] = 'Module Voc temperature coefficient, &beta;Voc (%/&deg;C)';
tabledata_params[6][1] = module.bvoc;
tabledata_params[7][0] = 'Module Pmp temperature coefficient, &gamma;Pmp (%/&deg;C)';
tabledata_params[7][1] = module.gpmp;
tabledata_params[8][0] = 'Ambient temperature range from weather file, T<sub>amb_min</sub> &ndash; T<sub>amb_max</sub> (&deg;C)';
tabledata_params[8][1] = [ t_dry_min , t_dry_max ];
tabledata_params[9][0] = 'Maximum design ambient temperature, Tmax (&deg;C)';
tabledata_params[9][1] = macro.t_max;
tabledata_params[10][0] = 'Minimum design ambient temperature, Tmin (&deg;C)';
tabledata_params[10][1] = macro.t_min;
tabledata_params[11][0] = 'Temperature adjustment for mounting, T<sub>adj</sub> (&deg;C)';
tabledata_params[11][1] = macro.t_adj;
tabledata_params[12][0] = 'Mounting type implied by temperature correction inputs';
tabledata_params[12][1] = module.mounting;

tabletitle_dcac = 'DC/AC Ratio for Four Different Light-induced Degradation (LID) Scenarios';
tabledata_dcac[0][0] = '';
tabledata_dcac[1][0] = 'Nameplate';
tabledata_dcac[2][0] = 'Year 1 with LID';
if ( analysis_period > 1 )
	{ tabledata_dcac[3][0] = 'Year ' + analysis_period + '  with LID and 0.5% annual DC degradation'; }
for( i=0; i<#lid; i++ )
{
	tabledata_dcac[0][i+1] = sprintf('%.1f%%', ( 1 - lid[i] ) * 100 );
	tabledata_dcac[1][i+1] = nameplate_dcac;
	tabledata_dcac[2][i+1] = first_yr_dcac[i];
	if ( #last_yr_dcac > 0 )
		{ tabledata_dcac[3][i+1] = last_yr_dcac[i]; }
}

tabletitle_powerloss = 'Estimated Power Losses Due to Inverter Voltage Clipping and Power Limiting';
tabledata_powerloss[0][0] = '';
tabledata_powerloss[0][1] = 'Power Limiting';
tabledata_powerloss[0][2] = 'MPPT Voltage Clipping';
tabledata_powerloss[1][0] = 'Total kWh/year lost';
tabledata_powerloss[1][1] = inv_powerlimitloss;
tabledata_powerloss[1][2] = mpptloss;
tabledata_powerloss[2][0] = 'Number of time steps (hourly or subhourly)';
tabledata_powerloss[2][1] = [inv_powerlimitloss_num_ts,clipping_time_moderate*num_ts,clipping_time_severe*num_ts]; // change background color when value exceeds 5% and 10% of timesteps per year
tabledata_powerloss[2][2] = [mpptloss_num_ts,clipping_time_moderate*num_ts,clipping_time_severe*num_ts];
tabledata_powerloss[3][0] = 'Total kWh/year lost as % of inverter DC input';
tabledata_powerloss[3][1] = [inv_powerlimitloss_percent_dc,clipping_energy_moderate*100,clipping_energy_severe*100]; // change background color when when value exceeds 20% and 50%
tabledata_powerloss[3][2] = [mpptloss_percent_dc,clipping_energy_moderate*100,clipping_energy_severe*100];
tabledata_powerloss[4][0] = 'Total kWh/year lost as % of inverter AC output';
tabledata_powerloss[4][1] = [inv_powerlimitloss_percent_ac,clipping_energy_moderate*100,clipping_energy_severe*100];
tabledata_powerloss[4][2] = [mpptloss_percent_ac,clipping_energy_moderate*100,clipping_energy_severe*100];

tabletitle_modules_same = 'Modules from the same manufacturer that meet the inverter voltage requirements. Table displays up to 50 modules that result in the highest rated string Voc.';
//find index for how many subarrays are enabled:

count = 0;
tabledata_modules_same[0][0] = 'Module';
tabledata_modules_same[0][1] = 'Array Power (kW)';
for (i = 2 ; i < (2 + max_subarrays) ; i++) {
	if(get('subarray'+ to_string(i-1) + '_enable') != 0) 
	{
		count = count + 1;
		tabledata_modules_same[0][count + 1] = 'Subarray ' + to_string(i-1) + ' String Voc (VDC)';
	}
}
tabledata_modules_same[0][count + 2] = 'Nameplate DC/AC Ratio';

c = 0;
for(column = 2 ; column < (max_subarrays + 2) ; column++){
	if(get('subarray'+ to_string(column-1) + '_enable') != 0) 
	{
		c = c + 1;
		for (i=0; i<#modules_same; i++ )
		{
			tabledata_modules_same[i+1][0] = modules_same[i][0];
			tabledata_modules_same[i+1][1] = modules_same[i][1] * num_modules / 1000; // pmp
			tabledata_modules_same[i+1][c + 1] = modules_same[i][2] * modules_per_string[column - 2]; // voc
			tabledata_modules_same[i+1][count + 2]	= modules_same[i][1] * num_modules / 1000 / nameplate_ac; // dc/ac ratio
		}
	}
}

count_diff = 0;
tabletitle_modules_diff = 'Modules from different manufacturers that meet the inverter voltage requirements. Table displays up to 50 modules that result in the highest rated string Voc.';
tabledata_modules_diff[0][0] = 'Module';
tabledata_modules_diff[0][1] = 'Array Power (kW)';
for (i = 2 ; i < (2 + max_subarrays) ; i++) {
	if(get('subarray'+ to_string(i-1) + '_enable') != 0) {
		count_diff = count_diff + 1;
		tabledata_modules_diff[0][count_diff +1] = 'Subarray ' + to_string(i-1) + ' String Voc (VDC)';
	}
}
tabledata_modules_diff[0][count_diff + 2] = 'Nameplate DC/AC Ratio';

c = 0;
for(column_diff = 2 ; column_diff < (max_subarrays + 2) ; column_diff++){
	if(get('subarray'+ to_string(column_diff - 1) + '_enable') != 0) {
		c = c + 1;
		for (i=0; i<#modules_diff; i++ )
		{
			tabledata_modules_diff[i+1][0] = modules_diff[i][0];
			tabledata_modules_diff[i+1][1] = modules_diff[i][1] * num_modules / 1000; // pmp
			tabledata_modules_diff[i+1][c + 1] = modules_diff[i][2] * modules_per_string[column_diff - 2]; // voc
			tabledata_modules_diff[i+1][count_diff + 2] = modules_diff[i][1] * num_modules / 1000 / nameplate_ac; // dc/ac ratio
		}
	}
}
////////////////////////////////////////////////////////////////////////////////
// Export to CSV
////////////////////////////////////////////////////////////////////////////////

// TO DO

////////////////////////////////////////////////////////////////////////////////
// Create HTML report
////////////////////////////////////////////////////////////////////////////////
num_table = 0;
str = '<html><body><h1>System Sizing Information</h1><p>This information is based';
str += ' on the inputs and simulation results for the "' + active_case() + '" case.</p>';

str += '<h2>Parameters Used for System Sizing</h2>';
num_table++;
str += html_table ( { 'arr' = tabledata_params , 'row_headers' = false , 'title' = 'Table ' + num_table + ': ' + tabletitle_params });
str += '<p>The parameters for the system sizing algorithm are from the ';
str += ' Module, Inverter, and System Design input pages, macro inputs, and weather file.</p>';
str += '<p>The mounting type is based on the temperature correction inputs on the Module page,';
str += ' and is shown in the table to help you ensure that the design temperature adjustment value you choose';
str += ' for the design temperature calculations is consistent with your model inputs.</p>';

if ( sim_msg != '' )
{
	str += '<p><table bgcolor=#ffffa5 width=100%><tr><td><strong>Simulation message:</strong><br />' + sim_msg + '</td></tr></table></p>';
}

str += '<h2>Power Losses from Inverter Power Limiting and Voltage Clipping</h2>';
str += '<p>Power limiting losses occur when the array power output exceeds the inverter DC';
str += ' power rating. Voltage clipping losses occur when the array operating voltage falls';
str += ' outside of the inverter MPPT voltage range. Depending on your design goals,';
str += ' some power limiting or voltage clipping losses may be acceptable.</p>';

num_table++;
str += html_table( {'arr' = tabledata_powerloss, 'row_headers' = false, 'title' = 'Table ' + num_table + ': ' + tabletitle_powerloss } );
str += '<p>Table ' + num_table + ' shows the amount of power limiting and voltage';
str += ' clipping from the simulation results, which give you an estimate of what to expect from the real system.';
str += ' Colors indicate:</p>';
str += '<ul><li>Red: More than 10% of time steps of the year, or more than 50% of annual power output.</li>';
str += '<li>Orange: More than 5% of time steps or 20% of output.</li>';
str += '<li>Clear: Values are within acceptable range, less than 5% of time steps or 20% of annual power output.</li></ul>';
str += '<p>The figure(s) below show the inverter rated MPPT voltage range with worst case';
str += ' design maximum open-circuit voltage and minimum maximum-power voltage, along with';
str += ' the operating open circuit, minimum, and maximum voltages from the';
str += ' simulation results for each subarray in the system.</p>';

for (i=0; i<#voperating_graphs; i++)
{
	str += '<p align="center"><img src="' + voperating_graphs[i] + '" /></p>';
}	
num_fig = i;	
str += '<p>The equations for the design string voltages use parameters from Table 1:</p>';
str += '<p align="center"><font face="verdana">V<sub>dc , min_design</sub>';
str += ' = [ V<sub>mp</sub> + ( T<sub>max</sub> + T<sub>adj</sub> - T<sub>stc</sub> ) * &gamma;P<sub>mp</sub>/100% * P<sub>mp</sub> ] * modules_per_string</font></p>'; 
str += '<p align="center"><font face="verdana">V<sub>oc , max_design</sub>';
str += ' = [ V<sub>oc</sub> + ( T<sub>low</sub> - T<sub>stc</sub> ) * &beta;V<sub>oc</sub>/100% * V<sub>oc</sub> ] * modules_per_string</font></p>'; // TO DO check Voc units %/C vs V/C in table and equations

//DC-AC Ratio Information
is_degradation = analysis_period > 1;
str += '<h2>DC/AC Ratio and Degradation Assumptions</h2>';
str += '<p>DC/AC ratio is the array total nameplate capacity in DC kW divided by the inverter';
str += ' total nameplate capacity in AC kW, and is a way to describe the relative size of the array and inverter.</p>';
num_table++;
str += html_table( {'arr' = tabledata_dcac, 'row_headers' = true, 'title' = 'Table ' + num_table + ': ' +  tabletitle_dcac } );
str += '<p>Table ' + num_table + ' shows how the DC/AC ratio depends on the assumptions';
str += ' you make about light-induced degradation (LID) in Year 1';
str += ? is_degradation [ '' , ' and module degradation over the analysis period' ];
str += '. The nameplate DC/AC ratio is the value you see on the System Design page that';
str += ' describes the size of your system. The nameplate DC/AC ratio';
str += ' does not change with LID, which does not take effect until after the system';
str += ' begins operating in Year 1.';
str += ' The DC/AC ratios shown in the table account for LID in Year 1 ';
str += ? is_degradation [ '' , ' and degradation from the Lifetime page in Year ' + to_string(analysis_period) ];
str +=  ' for four LID scenarios covering the typical range of 1.5% for mono-crystalline';
str += ' modules to a 3% worst-case scenario.</p>';

str += '<h2>Tips for System Sizing</h2>';

str += '<p>The nameplate DC/AC ratio of your system is ' + num_to_str( nameplate_dcac, 2 ) + ' ';

if (dcac_ok)
	str += 'and is within the reasonable range of ' + num_to_str( dcac_min , 2 ) + ' &ndash; ' + num_to_str( dcac_max , 2 ) + '. Some designs use DC/AC ratios of up to 1.5.';
elseif (get('calculated_dcac_ratio') < dcac_min)
{
	
	str += 'and is below the range of ' + num_to_str( dcac_min , 2 ) + ' &ndash; ' + num_to_str( dcac_max , 2 );
	str += '. Try any of the following to increase the DC/AC ratio: </p><ul><li>Increase the number of strings in parallel</li><li>Decrease the number of inverters</li><li>Choose a larger module</li><li>Choose a smaller inverter</li></ul>';
//	str += ' to ' + strings_in_parallel_new + ' to resolve this issue.';		//Does not apply incase of multiple subarrays
}
else //if (get('dcac_ratio') > dcac_min) 
{
	str += 'and is over the range of ' + num_to_str( dcac_min , 2 ) + ' &ndash; ' + num_to_str( dcac_max , 2 );
	str += '. Some designs use DC/AC ratios as high as 1.5, but if you want a lower ratio, try any of the following:</p> <ul><li>Reduce the number of strings in parallel</li><li>Increase the number of inverters</li><li>Choose a smaller module</li><li>Choose a larger inverter</li></ul>';
//	str += ' to ' + strings_in_parallel_new + ' to resolve this issue.';		//Does not apply incase of multiple subarrays
}

//str +='</p>';

/*str += '<p>The maximum design open-circuit voltage of the subarrays in your system is:</p> ';
str += '<ul>';
str += '<li>Subarray 1: ' + num_to_str( voc_max_design * modules_per_string[0], 0) + ' V<sub>DC</sub>';*/
str += '<p>The Figure(s) above indicate that the subarray design or operating voltages ';
if ( voc_ok[0] && voc_ok[1] && voc_ok[2] && voc_ok[3] )
{
	str += ' are within the inverter MPPT limits.';
}
else
{
	str += ' fall outside the inverter MPPT limits for one or more subarray. This may be acceptable if <em>operating</em> voltages are within the limits but <em>design</em> voltages are outside the limits.';
}
str +='</p>';

str += '<p>Your system uses the <em>' + module.name + '</em> module and <em>' + replace(inverter.name,':','') + '</em> inverter with a MPPT voltage range of ' + inverter.vmppt_min + ' VDC to ' + inverter.vmppt_max + ' VDC. There are ' +  num_modules_same  + ' modules from the same manufacturer and ' + num_modules_diff + ' modules in the library from different manufacturers that would result in a rated open circuit voltage within that range for the longest string in the array, which has ' + modules_per_string_max + ' modules per string. </p>';

if ( #modules_same > 1 )
{
	num_table++;
	str += html_table ( { 'arr' = tabledata_modules_same , 'row_headers' = false , 'title' = 'Table ' + num_table + ': ' + tabletitle_modules_same });
}
else { str+='<p>There are no modules in the library from the same manufacturer that meet the voltage and power requirements for the longest string in the system.</p>';}

if ( #modules_diff > 1 )
{
	num_table++;
	str += html_table ( { 'arr' = tabledata_modules_diff , 'row_headers' = false , 'title' = 'Table ' + num_table + ': ' + tabletitle_modules_diff });
}
else { str+='<p>There are no modules in the library from a different manufacturer that meet the voltage and power requirements for this inverter.</p>'; }

str += '</body></html>';
newplot( true );

// save html to file and open file in default web browser
// this is useful for converting to other formats like pdf or docx

if ( macro.show_in_browser == 'Yes' )
{
	html_file = cwd() + '/' + active_case() + '.html';
	write_text_file( html_file , str );
	browse( html_file );
}
else
{
	html_dialog(str, 'System Sizing Information', [300,300,800,600]); //custom window title and size
}

outln('Done. If you do not see an HTML report, try minimizing the SAM window to see if is hidden behind the window.'); 	
