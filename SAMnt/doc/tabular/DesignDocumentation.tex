% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
\geometry{margin=1in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{amsmath}
% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

%%% The "real" document content comes below...

\title{Tabular Browser Design Documentation}
\author{Nicholas DiOrio, National Renewable Energy Laboratory}
%\date{} 

\begin{document}
\maketitle

\section{Introduction}
The tabular results browser in SAM provides the user the capability to easily display and compare matrix data.  This document is intended for internal use only to provide reference for the design of the tabular browser in case of future problems.  Basic code paths will be listed, as well as intended behavior.  For functions which have been particulary difficult to get correct, inputs, outputs, and additional details will be explained.

\section{Code Paths}
\subsection{Running a simulation}
The general code path which occurs when running a simulation is:\\
\\
\texttt{
MainWindow::OnCaseMenu \\
\indent CaseWindow::RunBaseCase \\
 \indent \indent	Simulation::DispatchThreads \\
 \indent \indent		CaseWindow::UpdateResults \\
 \indent \indent \indent			CaseWindow::Setup \\
 \indent \indent \indent \indent			TabularBrowser::Setup \\
 \indent \indent \indent \indent \indent				TabularBrowser::UpdateAll \\
 \indent \indent \indent			CaseWindow::GetTabularBrowser \\
 \indent \indent \indent \indent				TabularBrowser::SelectVariables \\
 \indent \indent \indent \indent \indent					TabularBrowser::UpdateAll \\
}
\\
As can be seen, the tabular browser is updated twice when a simulation is run.  More investigation needs to be done to understand if this is correct. Within TabularBrowser, a new or updated simulation results in calls to UpdateAll.  This function encapsulates checks for adding variables, removing variables, and updating variable sizes on the existing grids. The following illustrates the order of the calls within UpdateAll, with the understanding that some logic exists to choose when to call these functions or not.  \\
\\
\\
\texttt{
TabularBrowser::UpdateAll \\
\indent TabularBrowser::UpdateSelectionList \\
\indent TabularBrowser::RemoveUnusedVariables \\
\indent TabularBrowser::ProcessAdded \\
\indent TabularBrowser::UpdateSelectionExpansion \\
}
\subsection{OnPageClosed}
When a page in the tabular browser is closed, a page-closed event is generated, at which point internal data structures need to be cleaned up, and the existing grids need to be updated. The primary tasks which must occur are to remove all of the variables on the closed-grid and then redraw the existing grids.\\
\\
\texttt{
TabularBrowser::OnPageClosed \\
\indent TabularBrowser::ProcessRemovedAll \\
\indent TabularBrowser::UpdateAll
}
\subsection{OnPageChanged}
Every time a user clicks on a notebook tab which results in a change of page from the previously selected tab to the new selection, a page-changed event is generated. The event handling for this is relatively simple.  The code simply points local variables to reflect the currently selected grid.

\subsection{OnVarSel}
Every time a user clicks to add or remove a variable from the current grid, a variable-select event is generated.  To handle this event, the code simply checks whether the check-box is selected or deselected and then processes the addition or removal:\\
\\
\texttt{
TabularBrowser::OnVarSel \\
\indent TabularBrowser::ProcessAdded\\
\indent TabularBrowser::ProcessRemoved\\
\indent TabularBrowser::SetLastSelection \\
}

\section{Data Structures}
The internal data structures relevent to the TabularBrowser are: \\
\\
\begin{tabular}{l | p{11cm} }
\hline
\texttt{m\_notebook} & the wxAuiNotebook which holds a wxExtGridCtrl on every tab \\ \hline
\texttt{m\_grid} & the currently selected wxExtGridCtrl \\ \hline
\texttt{m\_gridTable} & the underlying table containing the data for the currently selected grid \\ \hline
\texttt{m\_gridMap} & a map which associates grid size to a pointer to that grid \\ \hline
\texttt{m\_gridTableMap} & a map which associates grid size to a pointer to the underlying data table \\ \hline
\texttt{m\_tabLabelsMap} & a map which associates grid size to the label of the tab \\ \hline
\texttt{m\_selectedVars} & a string array containing names of every variable selected across all grids \\ \hline
\texttt{m\_selectedVarsBySizeMap} & a map which associates variable name to the grid size \\ \hline
\texttt{m\_selectedVarsMap} & a map which associates grid size to the array of variable names on that particular grid \\ \hline
\texttt{m\_numberOfTabs} & the number of tabs (grids) \\ \hline
\texttt{m\_lastSize} & the size of the last selected grid \\ \hline
\texttt{m\_key} & an integer which increments when a matrix is added, allowing a way to keep track of grids of the same size \\ 
\hline
\end{tabular}

\section{Main Functions}
\subsection{ProcessAdded}
\textbf{Inputs} \\
\texttt{wxString name} - the name of the variable to add \\
\\
\textbf{Outputs}\\
\texttt{none} \\
\\
\textbf{Description}
The \texttt{ProcessAdded} function is called for one variable at a time. The function checks whether or not the size of the grid associated with the variable has changed.  If the size has changed, \texttt{ProcessRemoved} is called before proceeding. If \texttt{ProcessAdded} is called and a variable needs to be added, it will be added to \texttt{m\_selectedVars}, \texttt{m\_selectedVarsMap}, and \texttt{m\_selectedVarsBySizeMap}. The variable size will be used to update \texttt{m\_lastSize}.  Finally, the notebook, grid, and case will be updated.

\subsection{ProcessRemoved}
\textbf{Inputs} \\
\texttt{wxString name} - the name of the variable to remove \\
\texttt{bool update\_grid} - boolean choice on whether to call for grid update \\
\\
\textbf{Outputs}\\
\texttt{none} \\
\\
\textbf{Description}
The \texttt{ProcessRemoved} function is called for one variable at a time. The variable is removed from \texttt{m\_selectedVars}, \texttt{m\_selectedVarsMap}, and \texttt{m\_selectedVarsBySizeMap}. In the event that more variables exist on the current grid, the variable size will be used to update \texttt{m\_lastSize}, and if \texttt{update\_grid} is true, the grid and case will be updated.  If no more variables exist on the current grid, a call is made to \texttt{ProcessRemovedAll}.

\subsection{ProcessRemovedAll}
\textbf{Inputs} \\
\texttt{ArraySizeKey removed\_size} - the size of grid to remove variables for \\
\\
\textbf{Outputs}\\
\texttt{none} \\
\\
\textbf{Description}
The \texttt{ProcessRemovedAll} function is called to remove all similiarly-sized variables from internal data structures, including the deletion of the underlying grid, grid table, and notebook page. The variables are removed from \texttt{m\_selectedVars}, \texttt{m\_selectedVarsMap}, \texttt{m\_selectedVarsBySizeMap}, \texttt{m\_tabLabelsMap}, and \texttt{m\_gridMap}, \texttt{m\_gridTableMap}. The variable \texttt{m\_numberOfTabs} is decremented.

\subsection{GetVariableSize}
\textbf{Inputs} \\
\texttt{int index} - the index of the variable within m\_selectedVars to retrieve size information for \\
\\
\textbf{Outputs}\\
\texttt{ArraySizeKey var\_size} - the variable size.  If the variable size is not found, the returned size will have 0 rows, 0 columns \\
\\
\textbf{Description}
The function first calls \texttt{GetStoredVariableSize} to search internal TabularBrowser data structures for the variable size.  If the information is not stored, the function calls \texttt{GetSimulationVariableSize}, which queries the simulation object for information about the variable.  

\subsection{CheckSizeChanged}
\textbf{Inputs} \\
\texttt{int index} - the index of the variable within m\_selectedVars to retrieve size information for \\
\\
\textbf{Outputs}\\
\texttt{bool changed} - true if the variable size is changed, else false \\
\\
\textbf{Description}
This function was designed to detect a variable size change in the event that a simulation is re-run with the Lifetime setting changed.  The function first calls \texttt{GetStoredVariableSize} to search internal TabularBrowser data structures for the variable size.  If the information is  stored, the function calls \\ \texttt{GetSimulationVariableSize}, which queries the simulation object for information about the size of the variable after the most recent simulation.  Of note is that if the variable size is for a matrix, there is also an associated key.  The \texttt{ArraySizeKey} retrieved from the simulation object duplicates the key present in the stored object so that the two sizes can be compared.  If the stored size does not match the simulation size, the function returns true, else false.

\subsection{RemoveUnusedVariables}
\textbf{Inputs} \\
\texttt{none} \\
\\
\textbf{Outputs}\\
\texttt{none} \\
\\
\textbf{Description}
This function was designed to account for the scenario where a simulation is re-run with the Lifetime setting changed, such that some variables will have changed size and disappear from the grids they were previously on.  Previously, SAM would crash under this scenario.  The function loops over \texttt{m\_selectedVarsMap}. In each loop, it extracts the variable size and list of variables at that size.  The simulation object is queried for the each variable on the grid.  If the variable is not found within the simulation, \texttt{ProcessRemoved} is called for that variable.  If the variable is still found, a call is made to \texttt{CheckSizeChanged}.  If the variable has changed size, \texttt{ProcessRemoved} is called, followed by \texttt{ProcessAdded} to update internal data structures with the correct size information.  Finally, the grid and case are updated.

\subsection{UpdateNotebook}
\textbf{Inputs} \\
\texttt{ArraySizeKey grid\_size} \\
\texttt{wxString name} \\
\\
\textbf{Outputs}\\
\texttt{none} \\
\\
\textbf{Description}
This function was designed to update the tabs available within the notebook.  If \texttt{m\_gridMap} does not contain a grid at the input size, a new grid is created and placed onto a new page.  The \texttt{m\_tabLabelsMap} is updated with the appropriate label for that variable size, and \texttt{m\_numberOfTabs} is incremented.

\subsection{UpdateGridSpecific}
\textbf{Inputs} \\
\texttt{wxExtGridCtrl *\& grid} - a pointer to the grid to update, called by reference \\
\texttt{ResultsTable *\& grid\_table} - a pointer to the ResultsTable, called by reference  \\
\texttt{wxArrayString selected\_vars} - the selected variable to load on the grid \\
\\
\textbf{Outputs}\\
\texttt{none} \\
\\
\textbf{Description}
This function was designed to update the variables on the selected grid. Of note, is that the grid and grid map are passed as references so they can be internally allocated, modified, and returned.  The function always deletes the underlying ResultsTable for the current grid, and reloads the information with a call to \texttt{LoadData}.  Grid properties such as the size of row labels, column size, column labels, font, and font weight are specified.  When the data is loaded, the grid is drawn and refreshed on the screen.

\subsection{UpdateCase}
\textbf{Inputs} \\
\texttt{none} \\
\\
\textbf{Outputs}\\
\texttt{none} \\
\\
\textbf{Description}
This function is designed to update the current case data browser variables with the variables selected within the TabularBrowser.  

\subsection{LoadData}
\textbf{Inputs} \\
\texttt{Simulation *results} - the simulation object obtained from running a new simulation\\
\texttt{wxArrayString \&vars} - the variables to load \\
\\
\textbf{Outputs}\\
\texttt{none} \\
\\
\textbf{Description}
This function is called from \texttt{UpdateGridSpecific} and is designed to load the selected variables from the simulation object onto the appropriately sized grid and grid table.  The variables are loaded from the simulation object and classified as matrices, arrays, or single values.  For matrix data, optional user-interface hints are parsed and the appropriate row and column labels are assigned.

\section{User Interface Hints}
This powerful feature allows a programmer to specify custom output hints  within \texttt{ssc} compute modules.  User interface (UI) hints specified within \texttt{ssc} are passed and parsed within the Simulation object for use in the TabularBrowser (and potentially other places).  Currently, UI hints are used to: \\
\\
- Specify custom header labels within the data selection list \\
- Specify custom row and column labels for matrix outputs \\
\\
The set of currently available UI hints and how to use them will be documented below.

\subsection{UI hints for custom group labels}
UI hints for custom group labels are implemented in \texttt{SAMnt} within \texttt{PopulateSelectionList}.  
\\
The key to implement a custom group label is: \texttt{GROUP}\\
\\
Currently, the implemented hints are:\\
\begin{tabular}{l | p{13cm}}
\hline
\texttt{UR\_MTP} & Utility rate data by tier\/period \\ \hline
\texttt{UR\_AM} & Utility rate data by year \\ 
\hline
\end{tabular}

\subsection{UI hints for row labels}
UI hints for row and column labels are implemented in \texttt{TabularBrowser::LoadData}.  The labels are defined in custom function within \texttt{TabularBrowser} such as \texttt{MakeTimeOfDay}.  \\
\\
The key to implement a row label is: \texttt{ROW\_LABEL}.\\
\\
The currently available row labels are: \\
\begin{tabular}{l | p{13cm}}
\hline
\texttt{HOURS\_OF\_DAY} &  lists the rows as hours of the day.  Assumes 24 rows, goes from 12 am to 11 pm \\ \hline
\texttt{UR\_PERIODS} & lists the rows as utility rate periods.  Assumes 12 rows, goes from period 1 to 12 \\ \hline
\texttt{UR\_PERIODNUMS} & lists the rows as period numbers, with a reduced matrix size to show only non-zero periods \\ \hline
\texttt{UR\_TIERS} & lists the rows as tier numbers.  Assumes 6 rows, goes from tier 1 to 6 \\ \hline
\texttt{UR\_TIERNUMS} & lists the rows as tier numbers, with a reduced matrix size to show only non-zero tiers \\ \hline
\texttt{MONTHS} & lists the rows as months.  Assumes 12 rows, goes from January to February \\ \hline
\texttt{NO\_ROW\_LABEL} & lists the row labels as blanks. \\ \hline
\end{tabular}
\subsection{UI hints for column labels}
The key to implement a row label is: \texttt{COL\_LABEL}.\\
\\
\begin{tabular}{l | p{12cm}}
\hline 
\texttt{HOURS\_OF\_DAY} & lists the columns as hours of the day.  Assumes 24 rows, goes from 12 am to 11 pm \\ \hline
\texttt{UR\_PERIODS} & lists the columns as utility rate periods.  Assumes 12 rows, goes from period 1 to 12 \\ \hline
\texttt{UR\_PERIODNUMS} & lists the columns as period numbers, with a reduced matrix size to show only non-zero periods \\ \hline
\texttt{UR\_TIERS} & lists the columns as tier numbers.  Assumes 6 rows, goes from tier 1 to 6 \\ \hline
\texttt{UR\_TIERNUMS} & lists the columns as tier numbers, with a reduced matrix size to show only non-zero tiers \\ \hline
\texttt{MONTHS} & lists the columns as months.  Assumes 12 rows, goes from January to February \\ \hline
\texttt{XY\_POSITION} & lists the columns as "X Position (m)" and "Y Position (m)" \\ \hline
\texttt{OPTICAL\_EFFICIENCY} & lists the columns as "Azimuth Angle (deg)", "Elevation Angle (deg)", and "Optical Efficiency (-)"\\ \hline
\texttt{FLUX\_MAPS} & lists the columns as "Azimuth Angle (deg)", "Elevation Angle (deg)", and "Panel i Absorbed Flux (kW/m2)" for i:N panels \\ \hline
\end{tabular} 
\subsection{UI hints for format specifiers}
Format specifiers can be used to format data output in a certain way, for instance, formatting currency or time.  \\
\\
The key to implement a format specifier is: \texttt{FORMAT\_SPEC}.\\
\\
Only one format specifier is currently available.  In the event that no format specifier is listed, matrix data will be formated as a real value. \\
\begin{tabular}{l | p{12cm}}
\hline 
\texttt{CURRENCY} & lists the data in a currency format \\ \hline
\end{tabular}
\subsection{Adding a UI hint within SSC}
To implement the UI hints in SSC, go to the variable table at the top of the compute module.  The last field in the table is for UI hints.  To enter a UI hint, enter the key and associated value like: \\
\\
\texttt{"KEY=VALUE"} \\
\\
To enter multiple hints, seperate them by commas with no spaces, such as:\\
\\
\texttt{"KEY1=VALUE1,KEY2=VALUE2"}\\
\\
This is illustrated by the real example from \texttt{cmod\_utilityrate4}\\
\\
\texttt{"COL\_LABEL=MONTHS,FORMAT\_SPEC=CURRENCY,GROUP=UR\_AM"}

\section{Bugs and Pitfalls}
\subsection{Changing from single year to lifetime mode}
When changing from a single year to lifetime mode or vice versa, special care must be taken within the tabular browser implementation to properly update internal data structures.  Crashes would previously occur when a dual-variable (one that changes size depending on the "Lifetime" setting" was listed in the results browser under the original size and the simulation was rerun under a different setting.  
\subsection{Maintaining window docking between simulations}
When making changes to the tabular browser, it is important to ensure that custom window docking is maintained when re-running a simulation.  It is not entirely clear what causes the docking positions to be deleted, possibly calling \texttt{UpdateGridSpecific} from \texttt{ProcessRemoved}, or a change to \texttt{m\_notebook}.

\end{document}
